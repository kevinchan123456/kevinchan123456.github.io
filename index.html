
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>biz: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">

				<option value="file0">git.synology.inc/sast/access-system/server/agent/internal/biz/app_info.go (0.0%)</option>

				<option value="file1">git.synology.inc/sast/access-system/server/agent/internal/biz/controller.go (80.8%)</option>

				<option value="file2">git.synology.inc/sast/access-system/server/agent/internal/biz/operation.go (0.0%)</option>

				<option value="file3">git.synology.inc/sast/access-system/server/agent/internal/biz/upnp.go (0.0%)</option>

				<option value="file4">git.synology.inc/sast/access-system/server/agent/internal/service/controller.go (82.1%)</option>

				<option value="file5">git.synology.inc/sast/access-system/server/agent/internal/service/forward_agent.go (0.0%)</option>

				<option value="file6">git.synology.inc/sast/access-system/server/agent/internal/service/forward_controller.go (0.0%)</option>

				<option value="file7">git.synology.inc/sast/access-system/server/agent/internal/service/forward_operation.go (0.0%)</option>

				<option value="file8">git.synology.inc/sast/access-system/server/agent/internal/service/forward_sync.go (0.0%)</option>

				<option value="file9">git.synology.inc/sast/access-system/server/agent/internal/service/forward_upnp.go (0.0%)</option>

				<option value="file10">git.synology.inc/sast/access-system/server/agent/internal/service/from_agent.go (0.0%)</option>

				<option value="file11">git.synology.inc/sast/access-system/server/agent/internal/service/operation.go (17.7%)</option>

				<option value="file12">git.synology.inc/sast/access-system/server/agent/internal/service/upnp.go (0.0%)</option>

				<option value="file13">git.synology.inc/sast/access-system/server/gateway/helper/json.go (71.4%)</option>

				<option value="file14">git.synology.inc/sast/access-system/server/gateway/internal/service/agent.go (87.5%)</option>

				<option value="file15">git.synology.inc/sast/access-system/server/gateway/internal/service/controller.go (79.7%)</option>

				<option value="file16">git.synology.inc/sast/access-system/server/gateway/internal/service/forward_agent.go (0.0%)</option>

				<option value="file17">git.synology.inc/sast/access-system/server/gateway/internal/service/forward_controller.go (0.0%)</option>

				<option value="file18">git.synology.inc/sast/access-system/server/gateway/internal/service/forward_operation.go (0.0%)</option>

				<option value="file19">git.synology.inc/sast/access-system/server/gateway/internal/service/forward_sync.go (0.0%)</option>

				<option value="file20">git.synology.inc/sast/access-system/server/gateway/internal/service/forward_upnp.go (0.0%)</option>

				<option value="file21">git.synology.inc/sast/access-system/server/gateway/internal/service/from_agent_dynamic.go (0.0%)</option>

				<option value="file22">git.synology.inc/sast/access-system/server/gateway/internal/service/from_agent_static.go (0.0%)</option>

				<option value="file23">git.synology.inc/sast/access-system/server/gateway/internal/service/operation.go (63.8%)</option>

				<option value="file24">git.synology.inc/sast/access-system/server/gateway/internal/service/service.go (0.0%)</option>

				<option value="file25">git.synology.inc/sast/access-system/server/gateway/internal/service/sync.go (0.0%)</option>

				<option value="file26">git.synology.inc/sast/access-system/server/gateway/internal/service/upnp.go (0.0%)</option>

				<option value="file27">git.synology.inc/sast/access-system/server/web/internal/biz/access_rule.go (0.0%)</option>

				<option value="file28">git.synology.inc/sast/access-system/server/web/internal/biz/agent.go (55.3%)</option>

				<option value="file29">git.synology.inc/sast/access-system/server/web/internal/biz/controller.go (100.0%)</option>

				<option value="file30">git.synology.inc/sast/access-system/server/web/internal/biz/door.go (100.0%)</option>

				<option value="file31">git.synology.inc/sast/access-system/server/web/internal/biz/dsm.go (0.0%)</option>

				<option value="file32">git.synology.inc/sast/access-system/server/web/internal/biz/general.go (0.0%)</option>

				<option value="file33">git.synology.inc/sast/access-system/server/web/internal/biz/group.go (0.0%)</option>

				<option value="file34">git.synology.inc/sast/access-system/server/web/internal/biz/id_point.go (100.0%)</option>

				<option value="file35">git.synology.inc/sast/access-system/server/web/internal/biz/import.go (0.0%)</option>

				<option value="file36">git.synology.inc/sast/access-system/server/web/internal/biz/import_validator.go (0.0%)</option>

				<option value="file37">git.synology.inc/sast/access-system/server/web/internal/biz/schedule.go (100.0%)</option>

				<option value="file38">git.synology.inc/sast/access-system/server/web/internal/biz/user.go (0.0%)</option>

				<option value="file39">git.synology.inc/sast/access-system/server/web/internal/biz/user_credential.go (44.2%)</option>

				<option value="file40">git.synology.inc/sast/access-system/server/web/internal/biz/zone.go (100.0%)</option>

				<option value="file41">git.synology.inc/sast/access-system/server/web/internal/service/access_rule.go (0.0%)</option>

				<option value="file42">git.synology.inc/sast/access-system/server/web/internal/service/agent.go (100.0%)</option>

				<option value="file43">git.synology.inc/sast/access-system/server/web/internal/service/controller.go (84.0%)</option>

				<option value="file44">git.synology.inc/sast/access-system/server/web/internal/service/discovery.go (0.0%)</option>

				<option value="file45">git.synology.inc/sast/access-system/server/web/internal/service/door.go (100.0%)</option>

				<option value="file46">git.synology.inc/sast/access-system/server/web/internal/service/dsm.go (0.0%)</option>

				<option value="file47">git.synology.inc/sast/access-system/server/web/internal/service/general.go (0.0%)</option>

				<option value="file48">git.synology.inc/sast/access-system/server/web/internal/service/group.go (0.0%)</option>

				<option value="file49">git.synology.inc/sast/access-system/server/web/internal/service/import.go (100.0%)</option>

				<option value="file50">git.synology.inc/sast/access-system/server/web/internal/service/internal_agent.go (100.0%)</option>

				<option value="file51">git.synology.inc/sast/access-system/server/web/internal/service/operation.go (0.0%)</option>

				<option value="file52">git.synology.inc/sast/access-system/server/web/internal/service/schedule.go (0.0%)</option>

				<option value="file53">git.synology.inc/sast/access-system/server/web/internal/service/sync.go (0.0%)</option>

				<option value="file54">git.synology.inc/sast/access-system/server/web/internal/service/upnp.go (0.0%)</option>

				<option value="file55">git.synology.inc/sast/access-system/server/web/internal/service/user.go (0.0%)</option>

				<option value="file56">git.synology.inc/sast/access-system/server/web/internal/service/user_credential.go (99.2%)</option>

				<option value="file57">git.synology.inc/sast/access-system/server/web/internal/service/zone.go (0.0%)</option>

				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>

				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>

			</div>
		</div>
		<div id="content">

		<pre class="file" id="file0" style="display: none">package biz

import (
        "context"

        "git.synology.inc/sast/access-system/server/agent/internal/data"
        "github.com/go-kratos/kratos/v2/log"
)

type AppInfoUseCase struct {
        log  *log.Helper
        data data.DataInterface
}

type AppInfo struct {
        ID      string `json:"id"`
        Version string `json:"version"`
        Name    string `json:"name"`
}

var info = AppInfo{
        ID:      "id-dev",
        Version: "v1-dev",
        Name:    "name-dev",
}

func NewAppInfoUseCase(d data.DataInterface, logger log.Logger) (*AppInfoUseCase, error) <span class="cov0" title="0">{
        uc := &amp;AppInfoUseCase{
                log:  log.NewHelper(logger),
                data: d,
        }

        err := uc.RefreshInfo()

        uc.log.Infof("app info: %+v", info)

        return uc, err
}</span>

func SetAppVersion(version string) <span class="cov0" title="0">{
        if version != "" </span><span class="cov0" title="0">{
                info.Version = version
        }</span> else<span class="cov0" title="0"> {
                info.Version = "empty-version"
        }</span>
}

func SetAppName(name string) <span class="cov0" title="0">{
        if name != "" </span><span class="cov0" title="0">{
                info.ID = name
        }</span> else<span class="cov0" title="0"> {
                info.ID = "empty-name"
        }</span>
}

func (uc *AppInfoUseCase) GetAppInfo() *AppInfo <span class="cov0" title="0">{
        return &amp;info
}</span>

func (uc *AppInfoUseCase) RefreshInfo() error <span class="cov0" title="0">{
        infoInDB, err := uc.data.GetAgentInfo(context.Background())
        if err != nil </span><span class="cov0" title="0">{
                uc.log.Errorf("failed to get agent info: %+v", err)
                return ErrorCanNotGetAgentInfo("failed to get agent info: %s", err.Error())
        }</span>

        <span class="cov0" title="0">info.ID = infoInDB.ID

        return nil</span>
}
</pre>

		<pre class="file" id="file1" style="display: none">package biz

import (
        "context"

        "git.synology.inc/sast/access-system/server/agent/internal/data"
        "git.synology.inc/sast/access-system/server/agent/internal/datastore"
        "github.com/go-kratos/kratos/v2/log"
)

//go:generate bash ../../../mock.sh

type ControllerUseCaseInterface interface {
        AddController(ctx context.Context, c *datastore.Controller) (string, error)
        UpdateController(ctx context.Context, c *datastore.Controller) error
        DeleteController(ctx context.Context, c *datastore.Controller) error
        ListController(ctx context.Context) ([]*datastore.Controller, error)
        GetController(ctx context.Context, c *datastore.Controller) (*datastore.Controller, error)
}

type ControllerUseCase struct {
        data data.DataInterface
        log  *log.Helper
}

func NewControllerUseCase(d data.DataInterface, logger log.Logger) ControllerUseCaseInterface <span class="cov8" title="1">{
        return &amp;ControllerUseCase{data: d, log: log.NewHelper(logger)}
}</span>

func (uc *ControllerUseCase) AddController(ctx context.Context, c *datastore.Controller) (string, error) <span class="cov8" title="1">{
        uc.log.Infof("AddController: %+v", c)

        cid, err := uc.data.AddController(ctx, c)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov8" title="1">return cid, nil</span>
}

func (uc *ControllerUseCase) UpdateController(ctx context.Context, c *datastore.Controller) error <span class="cov8" title="1">{
        uc.log.Infof("UpdateController: %+v", c)

        err := uc.data.UpdateController(ctx, c)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (uc *ControllerUseCase) DeleteController(ctx context.Context, c *datastore.Controller) error <span class="cov8" title="1">{
        uc.log.Infof("DeleteController: %+v", c)

        err := uc.data.DeleteController(ctx, c)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (uc *ControllerUseCase) GetController(ctx context.Context, c *datastore.Controller) (*datastore.Controller, error) <span class="cov8" title="1">{
        uc.log.Infof("GetController: %+v", c)

        c, err := uc.data.GetController(ctx, c)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return c, nil</span>
}

func (uc *ControllerUseCase) ListController(ctx context.Context) ([]*datastore.Controller, error) <span class="cov8" title="1">{
        uc.log.Infof("ListController")

        cs, err := uc.data.ListController(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return cs, nil</span>
}
</pre>

		<pre class="file" id="file2" style="display: none">package biz

import (
        "context"

        "git.synology.inc/sast/access-system/server/agent/internal/conf"
        "git.synology.inc/sast/access-system/server/agent/internal/data"
        "git.synology.inc/sast/access-system/server/agent/internal/datastore"
        "git.synology.inc/sast/access-system/server/agent/internal/doorhandler"
        "github.com/go-kratos/kratos/v2/log"
)

//go:generate bash ../../../mock.sh

type OperationUseCaseInterface interface {
        DoorAPI
        UserAPI
        CredentialAPI
        AccessProfileAPI
        IDPointAPI
}

type DoorAPI interface {
        TestConnection(ctx context.Context, c *conf.Operation, controller *Controller) (*TestConnectionResponse, error)
        ListAccessPoint(ctx context.Context, c *conf.Operation, controllerID string) (*doorhandler.ListAccessPointResponse, error)
        AccessDoor(ctx context.Context, c *conf.Operation, controllerID string, doorEntity string) error
        UnlockDoor(ctx context.Context, c *conf.Operation, controllerID string, doorEntity string) error
        LockDoor(ctx context.Context, c *conf.Operation, controllerID string, doorEntity string) error
}

type UserAPI interface {
        CreateUser(ctx context.Context, c *conf.Operation, controllerID string, req *doorhandler.CreateUserRequest,
        ) (*doorhandler.CreateUserResponse, error)
        ListUser(ctx context.Context, c *conf.Operation, controllerID string) (*doorhandler.ListUserResponse, error)
        UpdateUser(ctx context.Context, c *conf.Operation, controllerID string, req *doorhandler.UpdateUserRequest) error
        DeleteUser(ctx context.Context, c *conf.Operation, controllerID string, req *doorhandler.DeleteUserRequest) error
}

type CredentialAPI interface {
        CreateCredential(ctx context.Context, c *conf.Operation, controllerID string, req *doorhandler.CreateCredentialRequest,
        ) (*doorhandler.CreateCredentialResponse, error)
        ListCredential(ctx context.Context, c *conf.Operation, controllerID string) (*doorhandler.ListCredentialResponse, error)
        UpdateCredential(ctx context.Context, c *conf.Operation, controllerID string, req *doorhandler.UpdateCredentialRequest) error
        DeleteCredential(ctx context.Context, c *conf.Operation, controllerID string, req *doorhandler.DeleteCredentialRequest) error
}

type AccessProfileAPI interface {
        CreateAccessProfile(ctx context.Context, c *conf.Operation, controllerID string, req *doorhandler.CreateAccessProfileRequest,
        ) (*doorhandler.CreateAccessProfileResponse, error)
        ListAccessProfile(ctx context.Context, c *conf.Operation, controllerID string) (*doorhandler.ListAccessProfileResponse, error)
        UpdateAccessProfile(ctx context.Context, c *conf.Operation, controllerID string, req *doorhandler.UpdateAccessProfileRequest) error
        DeleteAccessProfile(ctx context.Context, c *conf.Operation, controllerID string, req *doorhandler.DeleteAccessProfileRequest) error
}

type IDPointAPI interface {
        GetReaderLastCard(ctx context.Context, c *conf.Operation, controllerID string, req *doorhandler.GetReaderLastCardRequest,
        ) (*doorhandler.GetReaderLastCardResponse, error)
}

type OperationUseCase struct {
        data data.DataInterface
        log  *log.Helper
}

func NewOperationUseCase(d data.DataInterface, logger log.Logger) OperationUseCaseInterface <span class="cov0" title="0">{
        return &amp;OperationUseCase{data: d, log: log.NewHelper(logger)}
}</span>

func (uc *OperationUseCase) getController(ctx context.Context, controllerID string) (*Controller, error) <span class="cov0" title="0">{
        selectController := &amp;datastore.Controller{
                ID: controllerID,
        }

        controller, err := uc.data.GetController(ctx, selectController)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;Controller{
                Vendor:   controller.Vendor,
                Model:    controller.Model,
                Address:  "http://" + controller.IP,
                Account:  controller.Account,
                Password: controller.Password,
        }, nil</span>
}

func (uc *OperationUseCase) initHandler(ctx context.Context, c *conf.Operation, controllerID string,
) (doorhandler.DoorHandler, *doorhandler.Controller, error) <span class="cov0" title="0">{

        controller, err := uc.getController(ctx, controllerID)
        if err != nil </span><span class="cov0" title="0">{
                uc.log.Errorf("get controller failed: %s", err.Error())
                return nil, nil, ErrorInitOperation("get controller failed: %s", err.Error())
        }</span>

        <span class="cov0" title="0">handler, err := doorhandler.NewDoorHandler(c, uc.log, controller.Vendor, controller.Model)
        if err != nil </span><span class="cov0" title="0">{
                uc.log.Errorf("init door handler failed: %s", err.Error())
                return nil, nil, ErrorInitOperation("init door handler failed: %s", err.Error())
        }</span>

        <span class="cov0" title="0">hanCon := &amp;doorhandler.Controller{
                ID:       controllerID,
                Address:  controller.Address,
                Account:  controller.Account,
                Password: controller.Password,
        }

        return handler, hanCon, nil</span>
}

func (uc *OperationUseCase) AccessDoor(ctx context.Context, c *conf.Operation, controllerID string, doorEntity string) error <span class="cov0" title="0">{
        // Init
        handler, controller, err := uc.initHandler(ctx, c, controllerID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Arrange
        <span class="cov0" title="0">operationRequest := &amp;doorhandler.OperationRequest{
                DoorEntity: doorEntity,
        }
        uc.log.Debugf("access door request: %+v", operationRequest)

        // Act
        err = handler.AccessDoor(ctx, controller, operationRequest)
        if err != nil </span><span class="cov0" title="0">{
                uc.log.Errorf("access door failed: %s", err.Error())
                return ErrorAccessDoorError("access door failed: %s", err.Error())
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (uc *OperationUseCase) UnlockDoor(ctx context.Context, c *conf.Operation, controllerID string, doorEntity string) error <span class="cov0" title="0">{
        // Init
        handler, controller, err := uc.initHandler(ctx, c, controllerID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Arrange
        <span class="cov0" title="0">operationRequest := &amp;doorhandler.OperationRequest{
                DoorEntity: doorEntity,
        }
        uc.log.Debugf("unlock door request: %+v", operationRequest)

        // Act
        err = handler.UnlockDoor(ctx, controller, operationRequest)
        if err != nil </span><span class="cov0" title="0">{
                uc.log.Errorf("unlock door failed: %s", err.Error())
                return ErrorUnlockDoorError("unlock door failed: %s", err.Error())
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (uc *OperationUseCase) LockDoor(ctx context.Context, c *conf.Operation, controllerID string, doorEntity string) error <span class="cov0" title="0">{
        // Init
        handler, controller, err := uc.initHandler(ctx, c, controllerID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Arrange
        <span class="cov0" title="0">operationRequest := &amp;doorhandler.OperationRequest{
                DoorEntity: doorEntity,
        }
        uc.log.Debugf("lock door request: %+v", operationRequest)

        // Act
        err = handler.LockDoor(ctx, controller, operationRequest)
        if err != nil </span><span class="cov0" title="0">{
                uc.log.Errorf("lock door failed: %s", err.Error())
                return ErrorLockDoorError("lock door failed: %s", err.Error())
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (uc *OperationUseCase) ListAccessPoint(ctx context.Context, c *conf.Operation, controllerID string,
) (*doorhandler.ListAccessPointResponse, error) <span class="cov0" title="0">{

        // Init
        handler, controller, err := uc.initHandler(ctx, c, controllerID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Act
        <span class="cov0" title="0">resp, err := handler.ListAccessPoint(ctx, controller)
        if err != nil </span><span class="cov0" title="0">{
                uc.log.Errorf("list access point failed: %s", err.Error())
                return nil, ErrorListAccessPointError("list access point failed: %s", err.Error())
        }</span>

        // Return
        <span class="cov0" title="0">return resp, nil</span>
}

func (uc *OperationUseCase) TestConnection(ctx context.Context, c *conf.Operation, controller *Controller,
) (*TestConnectionResponse, error) <span class="cov0" title="0">{

        // Using list access point to check controller connection currently

        // Init
        handler, err := doorhandler.NewDoorHandler(c, uc.log, controller.Vendor, controller.Model)
        if err != nil </span><span class="cov0" title="0">{
                uc.log.Errorf("init door handler failed: %s", err.Error())
                return nil, ErrorInitOperation("init door handler failed: %s", err.Error())
        }</span>

        <span class="cov0" title="0">hanCon := &amp;doorhandler.Controller{
                ID:       "test_connection",
                Address:  "http://" + controller.Address,
                Account:  controller.Account,
                Password: controller.Password,
        }

        // Act
        resp, err := handler.ListAccessPoint(ctx, hanCon)
        if err != nil </span><span class="cov0" title="0">{
                uc.log.Errorf("list access point failed: %s", err.Error())
                return nil, ErrorListAccessPointError("list access point failed: %s", err.Error())
        }</span>

        // Return
        <span class="cov0" title="0">res := &amp;TestConnectionResponse{
                Doors:    resp.Doors,
                IDPoints: resp.IDPoints,
        }

        // Return
        return res, nil</span>
}

func (uc *OperationUseCase) CreateUser(ctx context.Context, c *conf.Operation, controllerID string,
        req *doorhandler.CreateUserRequest) (*doorhandler.CreateUserResponse, error) <span class="cov0" title="0">{

        uc.log.Debugf("create user request: %+v", req)

        // Init
        handler, controller, err := uc.initHandler(ctx, c, controllerID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Act
        <span class="cov0" title="0">resp, err := handler.CreateUser(ctx, controller, req)
        if err != nil </span><span class="cov0" title="0">{
                uc.log.Errorf("create user failed: %s", err.Error())
                return nil, ErrorCreateUserError("create user failed: %s", err.Error())
        }</span>

        // Return
        <span class="cov0" title="0">return resp, nil</span>
}

func (uc *OperationUseCase) ListUser(ctx context.Context, c *conf.Operation, controllerID string) (*doorhandler.ListUserResponse, error) <span class="cov0" title="0">{
        // Init
        handler, controller, err := uc.initHandler(ctx, c, controllerID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Act
        <span class="cov0" title="0">resp, err := handler.ListUser(ctx, controller)
        if err != nil </span><span class="cov0" title="0">{
                uc.log.Errorf("list user failed: %s", err.Error())
                return nil, ErrorListUserError("list user failed: %s", err.Error())
        }</span>

        // Return
        <span class="cov0" title="0">return resp, nil</span>
}

func (uc *OperationUseCase) UpdateUser(ctx context.Context, c *conf.Operation, controllerID string,
        req *doorhandler.UpdateUserRequest) error <span class="cov0" title="0">{

        uc.log.Debugf("update user request: %+v", req)

        // Init
        handler, controller, err := uc.initHandler(ctx, c, controllerID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Act
        <span class="cov0" title="0">err = handler.UpdateUser(ctx, controller, req)
        if err != nil </span><span class="cov0" title="0">{
                uc.log.Errorf("update user failed: %s", err.Error())
                return ErrorUpdateUserError("update user failed: %s", err.Error())
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (uc *OperationUseCase) DeleteUser(ctx context.Context, c *conf.Operation, controllerID string,
        req *doorhandler.DeleteUserRequest) error <span class="cov0" title="0">{

        uc.log.Debugf("delete user request: %+v", req)

        // Init
        handler, controller, err := uc.initHandler(ctx, c, controllerID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Act
        <span class="cov0" title="0">err = handler.DeleteUser(ctx, controller, req)
        if err != nil </span><span class="cov0" title="0">{
                uc.log.Errorf("delete user failed: %s", err.Error())
                return ErrorDeleteUserError("delete user failed: %s", err.Error())
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (uc *OperationUseCase) CreateCredential(ctx context.Context, c *conf.Operation, controllerID string,
        req *doorhandler.CreateCredentialRequest) (*doorhandler.CreateCredentialResponse, error) <span class="cov0" title="0">{

        uc.log.Debugf("create credential request: %+v", req)

        // Init
        handler, controller, err := uc.initHandler(ctx, c, controllerID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Act
        <span class="cov0" title="0">resp, err := handler.CreateCredential(ctx, controller, req)
        if err != nil </span><span class="cov0" title="0">{
                uc.log.Errorf("create credential failed: %s", err.Error())
                return nil, ErrorCreateCredentialError("create credential failed: %s", err.Error())
        }</span>
        <span class="cov0" title="0">return resp, nil</span>
}

func (uc *OperationUseCase) ListCredential(ctx context.Context, c *conf.Operation,
        controllerID string) (*doorhandler.ListCredentialResponse, error) <span class="cov0" title="0">{

        // Init
        handler, controller, err := uc.initHandler(ctx, c, controllerID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Act
        <span class="cov0" title="0">resp, err := handler.ListCredential(ctx, controller)
        if err != nil </span><span class="cov0" title="0">{
                uc.log.Errorf("list user failed: %s", err.Error())
                return nil, ErrorListCredentialError("list user failed: %s", err.Error())
        }</span>

        // Return
        <span class="cov0" title="0">return resp, nil</span>
}

func (uc *OperationUseCase) UpdateCredential(ctx context.Context, c *conf.Operation, controllerID string,
        req *doorhandler.UpdateCredentialRequest) error <span class="cov0" title="0">{

        uc.log.Debugf("update credential request: %+v", req)

        // Init
        handler, controller, err := uc.initHandler(ctx, c, controllerID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Act
        <span class="cov0" title="0">err = handler.UpdateCredential(ctx, controller, req)
        if err != nil </span><span class="cov0" title="0">{
                uc.log.Errorf("update credential failed: %s", err.Error())
                return ErrorUpdateCredentialError("update credential failed: %s", err.Error())
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (uc *OperationUseCase) DeleteCredential(ctx context.Context, c *conf.Operation, controllerID string,
        req *doorhandler.DeleteCredentialRequest) error <span class="cov0" title="0">{

        uc.log.Debugf("delete credential request: %+v", req)

        // Init
        handler, controller, err := uc.initHandler(ctx, c, controllerID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Act
        <span class="cov0" title="0">err = handler.DeleteCredential(ctx, controller, req)
        if err != nil </span><span class="cov0" title="0">{
                uc.log.Errorf("delete credential failed: %s", err.Error())
                return ErrorDeleteCredentialError("delete credential failed: %s", err.Error())
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (uc *OperationUseCase) CreateAccessProfile(ctx context.Context, c *conf.Operation, controllerID string,
        req *doorhandler.CreateAccessProfileRequest) (*doorhandler.CreateAccessProfileResponse, error) <span class="cov0" title="0">{

        uc.log.Debugf("create access profile request: %+v", req)

        // Init
        handler, controller, err := uc.initHandler(ctx, c, controllerID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Act
        <span class="cov0" title="0">resp, err := handler.CreateAccessProfile(ctx, controller, req)
        if err != nil </span><span class="cov0" title="0">{
                uc.log.Errorf("create access profile failed: %s", err.Error())
                return nil, ErrorCreateAccessProfileError("create access profile failed: %s", err.Error())
        }</span>
        <span class="cov0" title="0">return resp, nil</span>
}

func (uc *OperationUseCase) ListAccessProfile(ctx context.Context, c *conf.Operation,
        controllerID string) (*doorhandler.ListAccessProfileResponse, error) <span class="cov0" title="0">{

        // Init
        handler, controller, err := uc.initHandler(ctx, c, controllerID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Act
        <span class="cov0" title="0">resp, err := handler.ListAccessProfile(ctx, controller)
        if err != nil </span><span class="cov0" title="0">{
                uc.log.Errorf("list access profile failed: %s", err.Error())
                return nil, ErrorListAccessProfileError("list access profile failed: %s", err.Error())
        }</span>
        <span class="cov0" title="0">return resp, nil</span>
}

func (uc *OperationUseCase) UpdateAccessProfile(ctx context.Context, c *conf.Operation, controllerID string,
        req *doorhandler.UpdateAccessProfileRequest) error <span class="cov0" title="0">{

        uc.log.Debugf("update access profile request: %+v", req)

        // Init
        handler, controller, err := uc.initHandler(ctx, c, controllerID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Act
        <span class="cov0" title="0">err = handler.UpdateAccessProfile(ctx, controller, req)
        if err != nil </span><span class="cov0" title="0">{
                uc.log.Errorf("update access profile failed: %s", err.Error())
                return ErrorUpdateAccessProfileError("update access profile failed: %s", err.Error())
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (uc *OperationUseCase) DeleteAccessProfile(ctx context.Context, c *conf.Operation,
        controllerID string, req *doorhandler.DeleteAccessProfileRequest) error <span class="cov0" title="0">{

        uc.log.Debugf("delete access profile request: %s", req)

        // Init
        handler, controller, err := uc.initHandler(ctx, c, controllerID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Act
        <span class="cov0" title="0">err = handler.DeleteAccessProfile(ctx, controller, req)
        if err != nil </span><span class="cov0" title="0">{
                uc.log.Errorf("delete access profile failed: %s", err.Error())
                return ErrorDeleteAccessProfileError("delete access profile failed: %s", err.Error())
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (uc *OperationUseCase) GetReaderLastCard(ctx context.Context, c *conf.Operation,
        controllerID string, req *doorhandler.GetReaderLastCardRequest) (*doorhandler.GetReaderLastCardResponse, error) <span class="cov0" title="0">{

        uc.log.Debugf("get reader last card request: %+v", req)

        // Init
        handler, controller, err := uc.initHandler(ctx, c, controllerID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Act
        <span class="cov0" title="0">resp, err := handler.GetReaderLastCard(ctx, controller, req)
        if err != nil </span><span class="cov0" title="0">{
                uc.log.Errorf("get reader last card failed: %s", err.Error())
                return nil, ErrorGetReaderLastCardError("get reader last card failed: %s", err.Error())
        }</span>

        // Return
        <span class="cov0" title="0">return resp, nil</span>
}
</pre>

		<pre class="file" id="file3" style="display: none">package biz

import (
        "context"

        "git.synology.inc/sast/3rd-party/goupnp.git"
        "git.synology.inc/sast/access-system/server/agent/internal/conf"
        "github.com/go-kratos/kratos/v2/log"
)

type UpnpUseCase struct {
        c   *conf.Upnp
        log *log.Helper
}

func NewUpnpUseCase(c *conf.Upnp, logger log.Logger) *UpnpUseCase <span class="cov0" title="0">{
        goupnp.HTTPClientReadTimeout = c.GetHttpClientReadTimeout().AsDuration()
        return &amp;UpnpUseCase{
                c:   c,
                log: log.NewHelper(logger),
        }
}</span>

func (uc *UpnpUseCase) Search(ctx context.Context, deviceChan chan goupnp.MaybeRootDevice) <span class="cov0" title="0">{
        uc.log.Infof("Starting UpnpSearch")

        errorChan := make(chan error)
        defer close(errorChan)

        go func() </span><span class="cov0" title="0">{
                err := goupnp.DiscoverDevicesCtxAsync(ctx, "upnp:rootdevice", deviceChan, errorChan)
                if err != nil </span><span class="cov0" title="0">{
                        uc.log.Errorf("Error discovering devices: %v", err)
                }</span>
        }()

        <span class="cov0" title="0">&lt;-errorChan
        uc.log.Infof("UpnpSearch Complete")</span>
}
</pre>

		<pre class="file" id="file4" style="display: none">package service

import (
        "context"

        controllerV1 "git.synology.inc/sast/access-system/server/agent/api/controller/v1"
        "git.synology.inc/sast/access-system/server/agent/internal/biz"
        "git.synology.inc/sast/access-system/server/agent/internal/datastore"
        "google.golang.org/protobuf/types/known/emptypb"
)

type ControllerService struct {
        controllerV1.UnimplementedControllerServer

        controllerUseCase biz.ControllerUseCaseInterface
}

func NewControllerService(controllerUseCase biz.ControllerUseCaseInterface) *ControllerService <span class="cov8" title="1">{
        return &amp;ControllerService{
                controllerUseCase: controllerUseCase,
        }
}</span>

func (s *ControllerService) AddController(ctx context.Context, req *controllerV1.AddControllerRequest,
) (*controllerV1.AddControllerReply, error) <span class="cov8" title="1">{

        addController := &amp;datastore.Controller{
                ID:       req.GetId(),
                IP:       req.GetIp(),
                Vendor:   req.GetVendor(),
                Model:    req.GetModel(),
                Name:     req.GetName(),
                Account:  req.GetAccount(),
                Password: req.GetPassword(),
                State:    datastore.ControllerStateConnected,
        }

        cid, err := s.controllerUseCase.AddController(ctx, addController)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return &amp;controllerV1.AddControllerReply{
                Id: cid,
        }, nil</span>
}

func (s *ControllerService) UpdateController(ctx context.Context, req *controllerV1.UpdateControllerRequest,
) (*emptypb.Empty, error) <span class="cov8" title="1">{

        updateController := &amp;datastore.Controller{
                ID:       req.GetId(),
                IP:       req.GetIp(),
                Vendor:   req.GetVendor(),
                Model:    req.GetModel(),
                Name:     req.GetName(),
                Account:  req.GetAccount(),
                Password: req.GetPassword(),
                State:    datastore.ControllerStateConnected,
        }

        err := s.controllerUseCase.UpdateController(ctx, updateController)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return &amp;emptypb.Empty{}, nil</span>
}

func (s *ControllerService) DeleteController(ctx context.Context, req *controllerV1.DeleteControllerRequest,
) (*emptypb.Empty, error) <span class="cov8" title="1">{

        deleteController := &amp;datastore.Controller{
                ID: req.GetId(),
        }

        err := s.controllerUseCase.DeleteController(ctx, deleteController)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return &amp;emptypb.Empty{}, nil</span>
}

func (s *ControllerService) GetController(ctx context.Context, req *controllerV1.GetControllerRequest,
) (*controllerV1.GetControllerReply, error) <span class="cov8" title="1">{

        selectController := &amp;datastore.Controller{
                ID: req.GetId(),
        }

        c, err := s.controllerUseCase.GetController(ctx, selectController)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return &amp;controllerV1.GetControllerReply{
                Controller: c.ToPbController(),
        }, nil</span>
}

func (s *ControllerService) ListController(ctx context.Context, _ *controllerV1.ListControllerRequest,
) (*controllerV1.ListControllerReply, error) <span class="cov8" title="1">{

        cs, err := s.controllerUseCase.ListController(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">controllers := &amp;controllerV1.ListControllerReply{
                Controllers: make([]*controllerV1.ControllerInfo, 0, len(cs)),
        }
        for _, controller := range cs </span><span class="cov8" title="1">{
                controllers.Controllers = append(controllers.Controllers, controller.ToPbController())
        }</span>

        <span class="cov8" title="1">return controllers, nil</span>
}
</pre>

		<pre class="file" id="file5" style="display: none">package service

import (
        "context"

        forwardAgentV1 "git.synology.inc/sast/access-system/server/gateway/api/forward_agent/v1"
        "github.com/go-kratos/kratos/v2/log"
)

type ForwardAgentService struct {
        log *log.Helper
}

func NewForwardAgentService(logger log.Logger) *ForwardAgentService <span class="cov0" title="0">{
        return &amp;ForwardAgentService{
                log: log.NewHelper(logger),
        }
}</span>

func (s *ForwardAgentService) PingAgent(ctx context.Context, req *forwardAgentV1.PingAgentRequest,
        resChan chan *forwardAgentV1.PingAgentReply) <span class="cov0" title="0">{

        // Defer func to prevent sent to close channel
        defer func() </span><span class="cov0" title="0">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        s.log.Errorf("recover from resChan %+v", r)
                }</span>
        }()

        <span class="cov0" title="0">agent := &amp;forwardAgentV1.AgentInfo{
                Id:    req.GetAgentId(),
                State: forwardAgentV1.AgentState_CONNECTED,
        }

        resChan &lt;- &amp;forwardAgentV1.PingAgentReply{
                Error:     nil,
                RequestId: req.GetRequestId(),
                Agent:     agent,
        }</span>
}
</pre>

		<pre class="file" id="file6" style="display: none">package service

import (
        "context"
        "fmt"

        grpcServerSideRequest "git.synology.inc/sast/access-system/grpc-server-side-request.git"
        "git.synology.inc/sast/access-system/server/agent/internal/biz"
        "git.synology.inc/sast/access-system/server/agent/internal/datastore"
        forwardControllerV1 "git.synology.inc/sast/access-system/server/gateway/api/forward_controller/v1"
        "github.com/go-kratos/kratos/v2/log"
)

type ForwardControllerService struct {
        controllerUseCase biz.ControllerUseCaseInterface
        log               *log.Helper
}

func NewForwardControllerService(controllerUseCase biz.ControllerUseCaseInterface, logger log.Logger) *ForwardControllerService <span class="cov0" title="0">{
        return &amp;ForwardControllerService{
                controllerUseCase: controllerUseCase,
                log:               log.NewHelper(logger),
        }
}</span>

func (s *ForwardControllerService) AddController(ctx context.Context, req *forwardControllerV1.AddControllerRequest,
        resChan chan *forwardControllerV1.AddControllerReply) <span class="cov0" title="0">{
        // Arrange
        addController := &amp;datastore.Controller{
                ID:       req.GetId(),
                IP:       req.GetIp(),
                Vendor:   req.GetVendor(),
                Model:    req.GetModel(),
                Name:     req.GetName(),
                Account:  req.GetAccount(),
                Password: req.GetPassword(),
                State:    datastore.ControllerStateConnected,
        }

        // Act
        cid, err := s.controllerUseCase.AddController(ctx, addController)
        if err != nil </span><span class="cov0" title="0">{
                resChan &lt;- grpcServerSideRequest.NewErrorResponse[forwardControllerV1.AddControllerReply](req.RequestId,
                        grpcServerSideRequest.ErrorCodeUnknownError, fmt.Sprintf("error adding controller: %s", err.Error()))
                return
        }</span>

        // Return
        <span class="cov0" title="0">resChan &lt;- &amp;forwardControllerV1.AddControllerReply{
                Error:     nil,
                RequestId: req.GetRequestId(),
                Id:        cid,
        }</span>
}

func (s *ForwardControllerService) UpdateController(ctx context.Context, req *forwardControllerV1.UpdateControllerRequest,
        resChan chan *forwardControllerV1.UpdateControllerReply) <span class="cov0" title="0">{
        // Arrange
        updateController := &amp;datastore.Controller{
                ID:       req.GetId(),
                IP:       req.GetIp(),
                Vendor:   req.GetVendor(),
                Model:    req.GetModel(),
                Name:     req.GetName(),
                Account:  req.GetAccount(),
                Password: req.GetPassword(),
                State:    datastore.ControllerStateConnected,
        }

        // Act
        err := s.controllerUseCase.UpdateController(ctx, updateController)
        if err != nil </span><span class="cov0" title="0">{
                resChan &lt;- grpcServerSideRequest.NewErrorResponse[forwardControllerV1.UpdateControllerReply](req.RequestId,
                        grpcServerSideRequest.ErrorCodeUnknownError, fmt.Sprintf("error updating controller: %s", err.Error()))
                return
        }</span>

        // Return
        <span class="cov0" title="0">resChan &lt;- &amp;forwardControllerV1.UpdateControllerReply{
                Error:     nil,
                RequestId: req.GetRequestId(),
        }</span>
}

func (s *ForwardControllerService) DeleteController(ctx context.Context, req *forwardControllerV1.DeleteControllerRequest,
        resChan chan *forwardControllerV1.DeleteControllerReply) <span class="cov0" title="0">{
        // Arrange
        deleteController := &amp;datastore.Controller{
                ID: req.GetId(),
        }

        // Act
        err := s.controllerUseCase.DeleteController(ctx, deleteController)
        if err != nil </span><span class="cov0" title="0">{
                resChan &lt;- grpcServerSideRequest.NewErrorResponse[forwardControllerV1.DeleteControllerReply](req.RequestId,
                        grpcServerSideRequest.ErrorCodeUnknownError, fmt.Sprintf("error deleting controller: %s", err.Error()))
                return
        }</span>

        // Return
        <span class="cov0" title="0">resChan &lt;- &amp;forwardControllerV1.DeleteControllerReply{
                Error:     nil,
                RequestId: req.GetRequestId(),
        }</span>
}

func (s *ForwardControllerService) GetController(ctx context.Context, req *forwardControllerV1.GetControllerRequest,
        resChan chan *forwardControllerV1.GetControllerReply) <span class="cov0" title="0">{
        // Arrange
        selectController := &amp;datastore.Controller{
                ID: req.GetId(),
        }

        // Act
        c, err := s.controllerUseCase.GetController(ctx, selectController)
        if err != nil </span><span class="cov0" title="0">{
                resChan &lt;- grpcServerSideRequest.NewErrorResponse[forwardControllerV1.GetControllerReply](req.RequestId,
                        grpcServerSideRequest.ErrorCodeUnknownError, fmt.Sprintf("error getting controller: %s", err.Error()))
                return
        }</span>

        // Return
        <span class="cov0" title="0">resChan &lt;- &amp;forwardControllerV1.GetControllerReply{
                Error:      nil,
                RequestId:  req.GetRequestId(),
                Controller: c.ToForwardController(),
        }</span>
}

func (s *ForwardControllerService) ListController(ctx context.Context, req *forwardControllerV1.ListControllerRequest,
        resChan chan *forwardControllerV1.ListControllerReply) <span class="cov0" title="0">{
        // Act
        cs, err := s.controllerUseCase.ListController(ctx)
        if err != nil </span><span class="cov0" title="0">{
                resChan &lt;- grpcServerSideRequest.NewErrorResponse[forwardControllerV1.ListControllerReply](req.RequestId,
                        grpcServerSideRequest.ErrorCodeUnknownError, fmt.Sprintf("error list controller: %s", err.Error()))
                return
        }</span>

        // Convert
        <span class="cov0" title="0">controllers := make([]*forwardControllerV1.ControllerInfo, 0, len(cs))
        for _, controller := range cs </span><span class="cov0" title="0">{
                controllers = append(controllers, controller.ToForwardController())
        }</span>

        // Return
        <span class="cov0" title="0">resChan &lt;- &amp;forwardControllerV1.ListControllerReply{
                Error:       nil,
                RequestId:   req.GetRequestId(),
                Controllers: controllers,
        }</span>
}
</pre>

		<pre class="file" id="file7" style="display: none">package service

import (
        "context"
        "fmt"

        grpcServerSideRequest "git.synology.inc/sast/access-system/grpc-server-side-request.git"
        "git.synology.inc/sast/access-system/server/agent/internal/biz"
        "git.synology.inc/sast/access-system/server/agent/internal/conf"
        "git.synology.inc/sast/access-system/server/agent/internal/doorhandler"
        forwardOperationV1 "git.synology.inc/sast/access-system/server/gateway/api/forward_operation/v1"
        "github.com/go-kratos/kratos/v2/log"
)

type ForwardOperationService struct {
        c                *conf.Operation
        operationUseCase biz.OperationUseCaseInterface
        log              *log.Helper
}

func NewForwardOperationService(c *conf.Operation, operationUseCase biz.OperationUseCaseInterface, logger log.Logger,
) *ForwardOperationService <span class="cov0" title="0">{

        return &amp;ForwardOperationService{
                c:                c,
                operationUseCase: operationUseCase,
                log:              log.NewHelper(logger),
        }
}</span>

func (s *ForwardOperationService) TestConnection(ctx context.Context, req *forwardOperationV1.TestConnectionRequest,
        resChan chan *forwardOperationV1.TestConnectionReply) <span class="cov0" title="0">{

        // Defer func to prevent sent to close channel
        defer func() </span><span class="cov0" title="0">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        s.log.Info("recover from resChan")
                }</span>
        }()

        <span class="cov0" title="0">controller := &amp;biz.Controller{
                Vendor:   req.GetVendor(),
                Model:    req.GetModel(),
                Address:  req.GetIp(),
                Account:  req.GetAccount(),
                Password: req.GetPassword(),
        }

        _, err := s.operationUseCase.TestConnection(ctx, s.c, controller)
        if err != nil </span><span class="cov0" title="0">{
                resChan &lt;- grpcServerSideRequest.NewErrorResponse[forwardOperationV1.TestConnectionReply](req.RequestId,
                        grpcServerSideRequest.ErrorCodeUnknownError, fmt.Sprintf("test connection error: %s", err.Error()))
                return
        }</span>

        // Return
        <span class="cov0" title="0">resChan &lt;- &amp;forwardOperationV1.TestConnectionReply{
                Error:     nil,
                RequestId: req.GetRequestId(),
        }</span>
}

func (s *ForwardOperationService) AccessDoor(ctx context.Context, req *forwardOperationV1.AccessDoorRequest,
        resChan chan *forwardOperationV1.AccessDoorReply) <span class="cov0" title="0">{

        // Defer func to prevent sent to close channel
        defer func() </span><span class="cov0" title="0">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        s.log.Info("recover from resChan")
                }</span>
        }()

        <span class="cov0" title="0">err := s.operationUseCase.AccessDoor(ctx, s.c, req.GetControllerId(), req.GetDoorEntity())
        if err != nil </span><span class="cov0" title="0">{
                resChan &lt;- grpcServerSideRequest.NewErrorResponse[forwardOperationV1.AccessDoorReply](req.RequestId,
                        grpcServerSideRequest.ErrorCodeUnknownError, fmt.Sprintf("error accessing door: %s", err.Error()))
                return
        }</span>

        // Return
        <span class="cov0" title="0">resChan &lt;- &amp;forwardOperationV1.AccessDoorReply{
                Error:     nil,
                RequestId: req.GetRequestId(),
        }</span>
}

func (s *ForwardOperationService) UnlockDoor(ctx context.Context, req *forwardOperationV1.UnlockDoorRequest,
        resChan chan *forwardOperationV1.UnlockDoorReply) <span class="cov0" title="0">{

        // Defer func to prevent sent to close channel
        defer func() </span><span class="cov0" title="0">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        s.log.Info("recover from resChan")
                }</span>
        }()

        <span class="cov0" title="0">err := s.operationUseCase.UnlockDoor(ctx, s.c, req.GetControllerId(), req.GetDoorEntity())
        if err != nil </span><span class="cov0" title="0">{
                resChan &lt;- grpcServerSideRequest.NewErrorResponse[forwardOperationV1.UnlockDoorReply](req.RequestId,
                        grpcServerSideRequest.ErrorCodeUnknownError, fmt.Sprintf("error unlocking door: %s", err.Error()))
                return
        }</span>

        // Return
        <span class="cov0" title="0">resChan &lt;- &amp;forwardOperationV1.UnlockDoorReply{
                Error:     nil,
                RequestId: req.GetRequestId(),
        }</span>
}

func (s *ForwardOperationService) LockDoor(ctx context.Context, req *forwardOperationV1.LockDoorRequest,
        resChan chan *forwardOperationV1.LockDoorReply) <span class="cov0" title="0">{

        // Defer func to prevent sent to close channel
        defer func() </span><span class="cov0" title="0">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        s.log.Info("recover from resChan")
                }</span>
        }()

        <span class="cov0" title="0">err := s.operationUseCase.LockDoor(ctx, s.c, req.GetControllerId(), req.GetDoorEntity())
        if err != nil </span><span class="cov0" title="0">{
                resChan &lt;- grpcServerSideRequest.NewErrorResponse[forwardOperationV1.LockDoorReply](req.RequestId,
                        grpcServerSideRequest.ErrorCodeUnknownError, fmt.Sprintf("error locking door: %s", err.Error()))
                return
        }</span>

        // Return
        <span class="cov0" title="0">resChan &lt;- &amp;forwardOperationV1.LockDoorReply{
                Error:     nil,
                RequestId: req.GetRequestId(),
        }</span>
}

func (s *ForwardOperationService) ListAccessPoints(ctx context.Context, req *forwardOperationV1.ListAccessPointsRequest,
        resChan chan *forwardOperationV1.ListAccessPointsReply) <span class="cov0" title="0">{

        // Defer func to prevent sent to close channel
        defer func() </span><span class="cov0" title="0">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        s.log.Info("recover from resChan")
                }</span>
        }()

        <span class="cov0" title="0">res, err := s.operationUseCase.ListAccessPoint(ctx, s.c, req.GetControllerId())
        if err != nil </span><span class="cov0" title="0">{
                resChan &lt;- grpcServerSideRequest.NewErrorResponse[forwardOperationV1.ListAccessPointsReply](req.RequestId,
                        grpcServerSideRequest.ErrorCodeUnknownError, fmt.Sprintf("error listing access points: %s", err.Error()))
                return
        }</span>

        <span class="cov0" title="0">doors := make([]*forwardOperationV1.Door, 0, len(res.Doors))
        idPoints := make([]*forwardOperationV1.IDPoint, 0, len(res.IDPoints))

        for _, door := range res.Doors </span><span class="cov0" title="0">{
                d := &amp;forwardOperationV1.Door{
                        Token:    door.Token,
                        Name:     door.Name,
                        Entity:   door.Entity,
                        Enabled:  door.Enabled,
                        IdPoints: make([]*forwardOperationV1.IDPoint, 0, len(door.IDPoint)),
                }

                for _, idPoint := range door.IDPoint </span><span class="cov0" title="0">{
                        d.IdPoints = append(d.IdPoints, &amp;forwardOperationV1.IDPoint{
                                Token: idPoint.Token,
                        })
                }</span>

                <span class="cov0" title="0">doors = append(doors, d)</span>
        }

        <span class="cov0" title="0">for _, idPoint := range res.IDPoints </span><span class="cov0" title="0">{
                idPoints = append(idPoints, &amp;forwardOperationV1.IDPoint{
                        Token:     idPoint.Token,
                        Type:      idPoint.Type,
                        Direction: idPoint.Direction,
                })
        }</span>

        // Return
        <span class="cov0" title="0">resChan &lt;- &amp;forwardOperationV1.ListAccessPointsReply{
                Error:     nil,
                RequestId: req.GetRequestId(),
                Doors:     doors,
                IdPoints:  idPoints,
        }</span>
}

func (s *ForwardOperationService) GetReaderLastCard(ctx context.Context, req *forwardOperationV1.GetReaderLastCardRequest,
        resChan chan *forwardOperationV1.GetReaderLastCardReply) <span class="cov0" title="0">{

        // Defer func to prevent sent to close channel
        defer func() </span><span class="cov0" title="0">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        s.log.Info("recover from resChan")
                }</span>
        }()

        <span class="cov0" title="0">request := &amp;doorhandler.GetReaderLastCardRequest{
                Token: req.GetReaderToken(),
        }

        res, err := s.operationUseCase.GetReaderLastCard(ctx, s.c, req.GetControllerId(), request)
        if err != nil </span><span class="cov0" title="0">{
                resChan &lt;- grpcServerSideRequest.NewErrorResponse[forwardOperationV1.GetReaderLastCardReply](req.RequestId,
                        grpcServerSideRequest.ErrorCodeUnknownError, fmt.Sprintf("error get reader last card number: %s", err.Error()))
                return
        }</span>

        // Return
        <span class="cov0" title="0">resChan &lt;- &amp;forwardOperationV1.GetReaderLastCardReply{
                Error:        nil,
                RequestId:    req.GetRequestId(),
                Card:         res.Card,
                CardNumber:   res.CardNumber,
                FacilityCode: res.FacilityCode,
        }</span>
}
</pre>

		<pre class="file" id="file8" style="display: none">package service

import (
        "context"
        "fmt"

        grpcServerSideRequest "git.synology.inc/sast/access-system/grpc-server-side-request.git"
        "git.synology.inc/sast/access-system/server/internal/taskqueue"
        taskqueueSync "git.synology.inc/sast/access-system/server/internal/taskqueue/sync"
        "git.synology.inc/sast/access-system/server/internal/taskqueue/task"
        "git.synology.inc/sast/access-system/server/internal/taskqueue/taskbase"
        "github.com/go-kratos/kratos/v2/log"
        "github.com/samber/lo"

        "git.synology.inc/sast/access-system/server/agent/internal/biz"
        "git.synology.inc/sast/access-system/server/agent/internal/conf"
        "git.synology.inc/sast/access-system/server/agent/internal/data"
        "git.synology.inc/sast/access-system/server/agent/internal/datastore"
        "git.synology.inc/sast/access-system/server/agent/internal/doorhandler"
        forwardSyncV1 "git.synology.inc/sast/access-system/server/gateway/api/forward_sync/v1"

        syncV1 "git.synology.inc/sast/access-system/server/gateway/api/sync/v1"
)

const (
        forwardSyncTaskQueueName    = "forward_sync"
        controllerQueueNameTemplate = "controller_%s"
)

type ForwardSyncService struct {
        log  *log.Helper
        data data.DataInterface

        // task queue ,cancel, and routine cancel
        agentQueueManager       taskqueue.TaskQueueManager
        agentQueueManagerCancel func()
        agentQueueRoutineCancel func()

        byControllerQueueRoutineContext map[string]context.Context
        byControllerQueueRoutineCancel  map[string]func()

        operationUseCase biz.OperationUseCaseInterface
        operationConf    *conf.Operation
}

func NewForwardSyncService(operationUseCase biz.OperationUseCaseInterface,
        c *conf.Operation, cs *conf.Sync, d data.DataInterface, logger log.Logger) (*ForwardSyncService, func(), error) <span class="cov0" title="0">{

        // cancel function should cancel all running routines on task queue
        tqm, cancel, err := taskqueue.NewTaskQueueManager(cs.GetTaskQueue(), logger)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, ErrorSyncInitTaskQueueFail("failed to create task queue manager: %s", err.Error())
        }</span>

        <span class="cov0" title="0">forwardSyncService := &amp;ForwardSyncService{
                log:                     log.NewHelper(logger),
                data:                    d,
                operationUseCase:        operationUseCase,
                operationConf:           c,
                agentQueueManager:       tqm,
                agentQueueManagerCancel: cancel,
                agentQueueRoutineCancel: nil,
        }

        err = forwardSyncService.init()
        if err != nil </span><span class="cov0" title="0">{
                return nil, forwardSyncService.Close, ErrorSyncInitServiceFail("failed to init sync service: %s", err.Error())
        }</span>

        <span class="cov0" title="0">return forwardSyncService, forwardSyncService.Close, nil</span>
}

func (s *ForwardSyncService) getControllerQueueName(controllerID string) string <span class="cov0" title="0">{
        return fmt.Sprintf(controllerQueueNameTemplate, controllerID)
}</span>

// handlerMap is big because it contains many kinds of tasks
//
//nolint:funlen
func (s *ForwardSyncService) setupForwardSyncQueue() error <span class="cov0" title="0">{
        s.log.Debugf("forward sync service setup task queue")

        err := s.agentQueueManager.CreateQueue(forwardSyncTaskQueueName)
        if err != nil </span><span class="cov0" title="0">{
                s.log.Errorf("failed to create task queue: %s", err.Error())
                return ErrorSyncInitTaskQueueFail("failed to create task queue: %s", err.Error())
        }</span>

        // setup sync queue routine env context
        <span class="cov0" title="0">bgCtx := context.Background()
        routineCtx := context.WithValue(bgCtx, taskbase.TaskResourceAgentData, s.data)
        routineCtx, cancel := context.WithCancel(routineCtx)
        s.agentQueueRoutineCancel = func() </span><span class="cov0" title="0">{
                cancel()
                err := s.agentQueueManager.DeleteQueue(forwardSyncTaskQueueName)
                if err != nil </span><span class="cov0" title="0">{
                        s.log.Errorf("failed to delete task queue: %s", err.Error())
                }</span>
        }

        <span class="cov0" title="0">handlerMap := map[string]taskbase.TaskHandler{
                taskqueueSync.SyncResetControllerTaskID: func(ctx context.Context, t taskbase.Task) error </span><span class="cov0" title="0">{
                        task, ok := t.(*taskqueueSync.SyncResetControllerTask)
                        if !ok </span><span class="cov0" title="0">{
                                s.log.Errorf("failed to cast task to SyncResetControllerTask, error: %s", err.Error())
                                return ErrorPrerunTaskFail("failed to cast task to SyncResetControllerTask, error: %s",
                                        err.Error())
                        }</span>
                        <span class="cov0" title="0">s.log.Infof("agent run sync reset controller task, controller: %s", task.ControllerID)

                        err = s.resetController(ctx, task.ControllerID)
                        if err != nil </span><span class="cov0" title="0">{
                                s.log.Errorf("failed to reset controller, controller: %s, error: %s", task.ControllerID, err.Error())
                                return ErrorRunTaskFail("failed to reset controller, controller: %s, error: %s",
                                        task.ControllerID, err.Error())
                        }</span>

                        <span class="cov0" title="0">return nil</span>
                },
                taskqueueSync.SyncInitControllerTaskID: func(ctx context.Context, t taskbase.Task) error <span class="cov0" title="0">{
                        task, ok := t.(*taskqueueSync.SyncInitControllerTask)
                        if !ok </span><span class="cov0" title="0">{
                                s.log.Errorf("failed to cast task to SyncInitControllerTask, error: %s", err.Error())
                                return ErrorPrerunTaskFail("failed to cast task to SyncInitControllerTask, error: %s",
                                        err.Error())
                        }</span>
                        <span class="cov0" title="0">s.log.Infof("agent run sync init controller task, controller: %s", task.ControllerInfo.Id)

                        // TODO: task handler may be controller-model dependent, may need to be moved into door handler
                        for _, user := range task.Users </span><span class="cov0" title="0">{
                                err = s.syncUserToController(ctx, task.ControllerInfo.Id, user)
                                if err != nil </span><span class="cov0" title="0">{
                                        s.log.Errorf("failed to sync user to controller, user: %+v, controller: %s, error: %s",
                                                user, task.ControllerInfo.Id, err.Error())
                                        return ErrorRunTaskFail("failed to sync user to controller, user: %+v, controller: %s, error: %s",
                                                user, task.ControllerInfo.Id, err.Error())
                                }</span>
                        }
                        <span class="cov0" title="0">return nil</span>
                },
                taskqueueSync.SyncAddUserTaskID: func(ctx context.Context, t taskbase.Task) error <span class="cov0" title="0">{
                        task, ok := t.(*taskqueueSync.SyncAddUserTask)
                        if !ok </span><span class="cov0" title="0">{
                                s.log.Errorf("failed to cast task to SyncAddUserTask, error: %s", err.Error())
                                return ErrorPrerunTaskFail("failed to cast task to SyncAddUserTask, error: %s", err.Error())
                        }</span>
                        <span class="cov0" title="0">s.log.Infof("agent run sync add user task, task: %+v", task)

                        for _, user := range task.Users </span><span class="cov0" title="0">{
                                err = s.syncUserToController(ctx, task.ControllerInfo.Id, user)
                                if err != nil </span><span class="cov0" title="0">{
                                        s.log.Errorf("failed to sync user to controller, user: %+v, controller: %s, error: %s",
                                                user, task.ControllerInfo.Id, err.Error())
                                        return ErrorRunTaskFail("failed to sync user to controller, user: %+v, controller: %s, error: %s",
                                                user, task.ControllerInfo.Id, err.Error())
                                }</span>
                        }
                        <span class="cov0" title="0">return nil</span>
                },
                taskqueueSync.SyncDeleteUserTaskID: func(ctx context.Context, t taskbase.Task) error <span class="cov0" title="0">{
                        task, ok := t.(*taskqueueSync.SyncDeleteUserTask)
                        if !ok </span><span class="cov0" title="0">{
                                s.log.Errorf("failed to cast task to SyncDeleteUserTask, error: %s", err.Error())
                                return ErrorPrerunTaskFail("failed to cast task to SyncDeleteUserTask, error: %s", err.Error())
                        }</span>
                        <span class="cov0" title="0">s.log.Infof("agent run sync delete user task, task: %+v", task)

                        err = s.unsyncUserToController(ctx, task.ControllerInfo.Id, task.User)
                        if err != nil </span><span class="cov0" title="0">{
                                s.log.Errorf("failed to unsync user to controller, user: %+v, controller: %s, error: %s",
                                        task.User, task.ControllerInfo.Id, err.Error())
                                return ErrorRunTaskFail("failed to unsync user to controller, user: %+v, controller: %s, error: %s",
                                        task.User, task.ControllerInfo.Id, err.Error())
                        }</span>

                        <span class="cov0" title="0">return nil</span>
                },
                taskqueueSync.SyncAddAccessRuleTaskID: func(ctx context.Context, t taskbase.Task) error <span class="cov0" title="0">{
                        task, ok := t.(*taskqueueSync.SyncAddAccessRuleTask)
                        if !ok </span><span class="cov0" title="0">{
                                s.log.Errorf("failed to cast task to SyncAddAccessRuleTask, error: %s", err.Error())
                                return ErrorPrerunTaskFail("failed to cast task to SyncAddAccessRuleTask, error: %s",
                                        err.Error())
                        }</span>
                        <span class="cov0" title="0">s.log.Infof("agent run sync add access rule task, task: %+v", task)

                        _, err = s.syncAccessRuleToController(ctx, task.ControllerInfo.Id, task.AccessRule)
                        if err != nil </span><span class="cov0" title="0">{
                                s.log.Errorf("failed to sync access rule to controller, access rule: %+v, controller: %s, error: %s",
                                        task.AccessRule, task.ControllerInfo.Id, err.Error())
                                return ErrorRunTaskFail(
                                        "failed to sync access rule to controller, access rule: %+v, controller: %s, error: %s",
                                        task.AccessRule, task.ControllerInfo.Id, err.Error())
                        }</span>

                        <span class="cov0" title="0">return nil</span>
                },
                taskqueueSync.SyncDeleteAccessRuleTaskID: func(ctx context.Context, t taskbase.Task) error <span class="cov0" title="0">{
                        task, ok := t.(*taskqueueSync.SyncDeleteAccessRuleTask)
                        if !ok </span><span class="cov0" title="0">{
                                s.log.Errorf("failed to cast task to SyncDeleteAccessRuleTask, error: %s", err.Error())
                                return ErrorPrerunTaskFail("failed to cast task to SyncDeleteAccessRuleTask, error: %s",
                                        err.Error())
                        }</span>
                        <span class="cov0" title="0">s.log.Infof("agent run sync delete access rule task, task: %+v", task)

                        err = s.unsyncAccessRuleToController(ctx, task.ControllerInfo.Id, task.AccessRule)
                        if err != nil </span><span class="cov0" title="0">{
                                s.log.Errorf("failed to unsync access rule to controller, access rule: %+v, controller: %s, error: %s",
                                        task.AccessRule, task.ControllerInfo.Id, err.Error())
                                return ErrorRunTaskFail(
                                        "failed to unsync access rule to controller, access rule: %+v, controller: %s, error: %s",
                                        task.AccessRule, task.ControllerInfo.Id, err.Error())
                        }</span>

                        <span class="cov0" title="0">return nil</span>
                },
                taskqueueSync.SyncAccessRuleAddUserTaskID: func(ctx context.Context, t taskbase.Task) error <span class="cov0" title="0">{
                        task, ok := t.(*taskqueueSync.SyncAccessRuleAddUserTask)
                        if !ok </span><span class="cov0" title="0">{
                                s.log.Errorf("failed to cast task to SyncAccessRuleAddUserTask, error: %s", err.Error())
                                return ErrorPrerunTaskFail("failed to cast task to SyncAccessRuleAddUserTask, error: %s",
                                        err.Error())
                        }</span>
                        <span class="cov0" title="0">s.log.Infof("agent run sync access rule add user task, task: %+v", task)

                        syncAccessRule, err := s.data.GetSyncAccessRule(ctx, task.AccessRuleInfo.GetId())
                        if err != nil </span><span class="cov0" title="0">{
                                s.log.Errorf("failed to get sync access rule, error: %s", err.Error())
                                return ErrorRunTaskFail("failed to get sync access rule, error: %s", err.Error())
                        }</span>

                        // TODO: query once with IN syntax
                        <span class="cov0" title="0">for _, userInfo := range task.UsersInfo </span><span class="cov0" title="0">{
                                syncUser, err := s.data.GetSyncUser(ctx, userInfo.GetId())
                                if err != nil </span><span class="cov0" title="0">{
                                        // TODO: user not found in sync user, maybe trigger sync user to controller?
                                        s.log.Errorf("failed to get sync user, error: %s", err.Error())
                                        return ErrorRunTaskFail("failed to get sync user, error: %s", err.Error())
                                }</span>

                                <span class="cov0" title="0">err = s.syncCredentialWithNewAccessRule(ctx, task.ControllerInfo.Id, syncAccessRule.Token,
                                        syncUser.Token, userInfo)
                                if err != nil </span><span class="cov0" title="0">{
                                        s.log.Errorf("failed to sync user credential to controller, user: %+v, controller: %s, error: %s",
                                                userInfo, task.ControllerInfo.Id, err.Error())
                                        return ErrorRunTaskFail(
                                                "failed to sync user credential to controller, user: %+v, controller: %s, error: %s",
                                                userInfo, task.ControllerInfo.Id, err.Error())
                                }</span>
                        }

                        <span class="cov0" title="0">return nil</span>
                },
                taskqueueSync.SyncAccessRuleDeleteUserTaskID: func(ctx context.Context, t taskbase.Task) error <span class="cov0" title="0">{
                        task, ok := t.(*taskqueueSync.SyncAccessRuleDeleteUserTask)
                        if !ok </span><span class="cov0" title="0">{
                                s.log.Errorf("failed to get SyncAccessRuleDeleteUserTask from bytes, error: %s", err.Error())
                                return ErrorPrerunTaskFail("failed to get SyncAccessRuleDeleteUserTask from bytes, error: %s",
                                        err.Error())
                        }</span>
                        <span class="cov0" title="0">s.log.Infof("agent run sync access rule delete user task, task: %+v", task)

                        err = s.updateUserWithDeletedAccessRule(ctx, task.ControllerInfo.Id, task.AccessRuleInfo, task.UsersInfo)
                        if err != nil </span><span class="cov0" title="0">{
                                s.log.Errorf("failed to update user with deleted access rule, controller: %s, error: %s",
                                        task.ControllerInfo.Id, err.Error())
                                return ErrorRunTaskFail("failed to update user with deleted access rule, controller: %s, error: %s",
                                        task.ControllerInfo.Id, err.Error())
                        }</span>
                        <span class="cov0" title="0">return nil</span>
                },
                taskqueueSync.SyncAccessRuleAddDoorTaskID: func(ctx context.Context, t taskbase.Task) error <span class="cov0" title="0">{
                        task, ok := t.(*taskqueueSync.SyncAccessRuleAddDoorTask)
                        if !ok </span><span class="cov0" title="0">{
                                s.log.Errorf("failed to cast task to SyncAccessRuleAddDoorTask, error: %s", err.Error())
                                return ErrorPrerunTaskFail("failed to cast task to SyncAccessRuleAddDoorTask, error: %s", err.Error())
                        }</span>
                        <span class="cov0" title="0">s.log.Infof("agent run sync access rule add door task, task: %+v", task)

                        err = s.syncDoorToController(ctx, task.ControllerInfo.GetId(), task.AccessRuleInfo, task.DoorsInfo)
                        if err != nil </span><span class="cov0" title="0">{
                                s.log.Errorf("failed to sync door to controller, controller: %s, error: %s",
                                        task.ControllerInfo.Id, err.Error())
                                return ErrorRunTaskFail("failed to sync door to controller, controller: %s, error: %s",
                                        task.ControllerInfo.Id, err.Error())
                        }</span>
                        <span class="cov0" title="0">return nil</span>
                },
                taskqueueSync.SyncAccessRuleDeleteDoorTaskID: func(ctx context.Context, t taskbase.Task) error <span class="cov0" title="0">{
                        task, ok := t.(*taskqueueSync.SyncAccessRuleDeleteDoorTask)
                        if !ok </span><span class="cov0" title="0">{
                                s.log.Errorf("failed to cast task to SyncAccessRuleDeleteDoorTask, error: %s", err.Error())
                                return ErrorPrerunTaskFail("failed to cast task to SyncAccessRuleDeleteDoorTask, error: %s",
                                        err.Error())
                        }</span>
                        <span class="cov0" title="0">s.log.Infof("agent run sync access rule delete door task, task: %+v", task)

                        err = s.unsyncDoorToController(ctx, task.ControllerInfo.GetId(), task.AccessRuleInfo, task.DoorsInfo)
                        if err != nil </span><span class="cov0" title="0">{
                                s.log.Errorf("failed to unsync door to controller, controller: %s, error: %s",
                                        task.ControllerInfo.Id, err.Error())
                                return ErrorRunTaskFail("failed to unsync door to controller, controller: %s, error: %s",
                                        task.ControllerInfo.Id, err.Error())
                        }</span>
                        <span class="cov0" title="0">return nil</span>
                },
                taskqueueSync.SyncAddCredentialTaskID: func(ctx context.Context, t taskbase.Task) error <span class="cov0" title="0">{
                        task, ok := t.(*taskqueueSync.SyncAddCredentialTask)
                        if !ok </span><span class="cov0" title="0">{
                                s.log.Errorf("failed to cast task to SyncAddCredentialTask, error: %s", err.Error())
                                return ErrorPrerunTaskFail("failed to cast task to SyncAddCredentialTask, error: %s", err.Error())
                        }</span>
                        <span class="cov0" title="0">s.log.Infof("agent run sync add credential task, task: %+v", task)

                        err = s.syncCredentialWithNewCredentials(ctx, task.ControllerInfo.Id, task.AccessRulesInfo, task.UserInfo)
                        if err != nil </span><span class="cov0" title="0">{
                                s.log.Errorf("failed to sync credential to controller, controller: %s, error: %s",
                                        task.ControllerInfo.Id, err.Error())
                                return ErrorRunTaskFail("failed to sync credential to controller, controller: %s, error: %s",
                                        task.ControllerInfo.Id, err.Error())
                        }</span>
                        <span class="cov0" title="0">return nil</span>
                },
                taskqueueSync.SyncDeleteCredentialTaskID: func(ctx context.Context, t taskbase.Task) error <span class="cov0" title="0">{
                        task, ok := t.(*taskqueueSync.SyncDeleteCredentialTask)
                        if !ok </span><span class="cov0" title="0">{
                                s.log.Errorf("failed to cast task to SyncDeleteCredentialTask, error: %s", err.Error())
                                return ErrorPrerunTaskFail("failed to cast task to SyncDeleteCredentialTask, error: %s", err.Error())
                        }</span>
                        <span class="cov0" title="0">s.log.Infof("agent run sync delete credential task, task: %+v", task)

                        unsyncCredential, err := s.data.GetSyncCredential(ctx, task.CredentialInfo.GetId())
                        if err != nil </span><span class="cov0" title="0">{
                                s.log.Errorf("failed to get unsync credential, error: %s", err.Error())
                                return ErrorRunTaskFail("failed to get unsync credential, error: %s", err.Error())
                        }</span>

                        <span class="cov0" title="0">err = s.unsyncCredentialToController(ctx, task.ControllerInfo.Id, unsyncCredential)
                        if err != nil </span><span class="cov0" title="0">{
                                s.log.Errorf("failed to unsync credential to controller, controller: %s, error: %s",
                                        task.ControllerInfo.Id, err.Error())
                                return ErrorRunTaskFail("failed to unsync credential to controller, controller: %s, error: %s",
                                        task.ControllerInfo.Id, err.Error())
                        }</span>

                        <span class="cov0" title="0">return nil</span>
                },
        }

        <span class="cov0" title="0">err = s.agentQueueManager.RegisterRunner(forwardSyncTaskQueueName, routineCtx, handlerMap)
        if err != nil </span><span class="cov0" title="0">{
                s.log.Errorf("failed to register runner, error: %s", err.Error())
                return ErrorSyncInitTaskQueueFail("failed to register runner, error: %s", err.Error())
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (s *ForwardSyncService) setupByControllerQueue() error <span class="cov0" title="0">{
        s.log.Debugf("forward sync service setup by controller queue")

        controllers, err := s.data.ListController(context.Background())
        if err != nil </span><span class="cov0" title="0">{
                s.log.Errorf("failed to list controllers: %s", err.Error())
                return ErrorSyncInitServiceFail("setup by controller queue failed to list controllers: %s", err.Error())
        }</span>

        <span class="cov0" title="0">for _, controller := range controllers </span><span class="cov0" title="0">{
                controllerID := controller.ID
                queueName := s.getControllerQueueName(controllerID)
                err := s.agentQueueManager.CreateQueue(queueName)
                if err != nil </span><span class="cov0" title="0">{
                        s.log.Errorf("failed to create task queue: %s", err.Error())
                        return ErrorSyncInitTaskQueueFail("failed to create task queue for controller %s: %s",
                                controllerID, err.Error())
                }</span>

                // setup sync queue routine env context
                <span class="cov0" title="0">bgCtx := context.Background()
                routineCtx := context.WithValue(bgCtx, taskbase.TaskResourceAgentData, s.data)
                routineCtx, cancel := context.WithCancel(routineCtx)

                s.byControllerQueueRoutineContext[controllerID] = routineCtx
                s.byControllerQueueRoutineCancel[controllerID] = cancel

                // TODO: move controller task handler to here and dispatch task from agent queue
                handlerMap := map[string]taskbase.TaskHandler{
                        taskqueueSync.SyncResetControllerTaskID: func(ctx context.Context, t taskbase.Task) error </span><span class="cov0" title="0">{
                                s.log.Infof("agent sync reset controller task run")
                                return nil
                        }</span>,
                }

                <span class="cov0" title="0">err = s.agentQueueManager.RegisterRunner(queueName, routineCtx, handlerMap)
                if err != nil </span><span class="cov0" title="0">{
                        s.log.Errorf("failed to register runner: %s", err.Error())
                        return ErrorSyncInitTaskQueueFail("failed to register runner for controller %s: %s",
                                controllerID, err.Error())
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func (s *ForwardSyncService) init() error <span class="cov0" title="0">{
        s.log.Debugf("forward sync service init")

        err := s.setupForwardSyncQueue()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = s.setupByControllerQueue()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (s *ForwardSyncService) resetController(ctx context.Context, controllerID string) error <span class="cov0" title="0">{
        s.log.Infof("reset controller, controller: %s", controllerID)

        // delete all users on controller
        listUserResp, err := s.operationUseCase.ListUser(ctx, s.operationConf, controllerID)
        if err != nil </span><span class="cov0" title="0">{
                s.log.Errorf("list user on controller %s failed, error: %s", controllerID, err.Error())
                return ErrorSyncResetControllerFail("list user on controller %s failed, error: %s", controllerID, err.Error())
        }</span>

        <span class="cov0" title="0">for _, user := range listUserResp.Users </span><span class="cov0" title="0">{
                deleteUserReq := &amp;doorhandler.DeleteUserRequest{
                        Token: user.Token,
                }

                err = s.operationUseCase.DeleteUser(ctx, s.operationConf, controllerID, deleteUserReq)
                if err != nil </span><span class="cov0" title="0">{
                        s.log.Errorf("delete user %s on controller %s failed, error: %s", user.Token, controllerID, err.Error())
                        return ErrorSyncResetControllerFail("delete user %s on controller %s failed, error: %s",
                                user.Token, controllerID, err.Error())
                }</span>
        }

        // delete all credentials on controller
        <span class="cov0" title="0">listCredentialResp, err := s.operationUseCase.ListCredential(ctx, s.operationConf, controllerID)
        if err != nil </span><span class="cov0" title="0">{
                s.log.Errorf("list credential on controller %s failed, error: %s", controllerID, err.Error())
                return ErrorSyncResetControllerFail("list credential on controller %s failed, error: %s",
                        controllerID, err.Error())
        }</span>

        <span class="cov0" title="0">for _, credential := range listCredentialResp.Credentials </span><span class="cov0" title="0">{
                deleteCredentialReq := &amp;doorhandler.DeleteCredentialRequest{
                        Token: credential.Token,
                }

                err = s.operationUseCase.DeleteCredential(ctx, s.operationConf, controllerID, deleteCredentialReq)
                if err != nil </span><span class="cov0" title="0">{
                        s.log.Errorf("delete credential %s on controller %s failed, error: %s",
                                credential.Token, controllerID, err.Error())
                        return ErrorSyncResetControllerFail("delete credential %s on controller %s failed, error: %s",
                                credential.Token, controllerID, err.Error())
                }</span>
        }

        // delete all access rules on controller
        <span class="cov0" title="0">listAccessProfileResp, err := s.operationUseCase.ListAccessProfile(ctx, s.operationConf, controllerID)
        if err != nil </span><span class="cov0" title="0">{
                s.log.Errorf("list access profile on controller %s failed, error: %s", controllerID, err.Error())
                return ErrorSyncResetControllerFail("list access profile on controller %s failed, error: %s",
                        controllerID, err.Error())
        }</span>

        <span class="cov0" title="0">for _, accessProfile := range listAccessProfileResp.AccessProfiles </span><span class="cov0" title="0">{
                deleteAccessProfileReq := &amp;doorhandler.DeleteAccessProfileRequest{
                        Token: accessProfile.Token,
                }

                err = s.operationUseCase.DeleteAccessProfile(ctx, s.operationConf, controllerID, deleteAccessProfileReq)
                if err != nil </span><span class="cov0" title="0">{
                        s.log.Errorf("delete access profile %s on controller %s failed, error: %s",
                                accessProfile.Token, controllerID, err.Error())
                        return ErrorSyncResetControllerFail("delete access profile %s on controller %s failed, error: %s",
                                accessProfile.Token, controllerID, err.Error())
                }</span>
        }

        <span class="cov0" title="0">s.log.Infof("reset controller %s success", controllerID)

        return nil</span>
}

func (s *ForwardSyncService) syncAccessRuleToController(ctx context.Context, controllerID string,
        ar *syncV1.AccessRuleInfo) (string, error) <span class="cov0" title="0">{

        s.log.Infof("sync access rule to controller %s, access rule: %+v", controllerID, ar)

        // TODO: sync schedule and access profile
        schedules := []string{"standard_always"}

        accessPolicies := make([]*doorhandler.AccessPolicy, 0, len(ar.Doors))
        for _, door := range ar.Doors </span><span class="cov0" title="0">{
                accessPolicies = append(accessPolicies, &amp;doorhandler.AccessPolicy{
                        AccessPoint: door.GetToken(),
                        Schedule:    schedules,
                })
        }</span>

        // Create access profile
        <span class="cov0" title="0">createAccessProfileReq := &amp;doorhandler.CreateAccessProfileRequest{
                AccessProfile: doorhandler.AccessProfile{
                        Name:         ar.GetName(),
                        Description:  ar.GetDescription(),
                        Enabled:      true,
                        Schedule:     schedules,
                        AccessPolicy: accessPolicies,
                        // access system does not have valid from to for access profile, only user
                        ValidFrom: "",
                        ValidTo:   "",
                },
        }
        createAccessProfileResp, err := s.operationUseCase.CreateAccessProfile(ctx, s.operationConf, controllerID, createAccessProfileReq)
        if err != nil </span><span class="cov0" title="0">{
                s.log.Errorf("create access profile %+v failed, error: %s", createAccessProfileReq, err.Error())
                return "", ErrorSyncAccessRuleToControllerFail("create access profile %+v failed, error: %s",
                        createAccessProfileReq, err.Error())
        }</span>
        <span class="cov0" title="0">if createAccessProfileResp == nil </span><span class="cov0" title="0">{
                s.log.Errorf("create access profile %+v failed, resp is nil", createAccessProfileReq)
                return "", ErrorSyncAccessRuleToControllerFail("create access profile %+v failed, resp is nil",
                        createAccessProfileReq)
        }</span>

        <span class="cov0" title="0">s.log.Infof("access profile created, token: %s", createAccessProfileResp.Token)

        // save unique id to token mapping in db
        err = s.data.AddSyncAccessRule(ctx, controllerID, ar.GetId(), createAccessProfileResp.Token)
        if err != nil </span><span class="cov0" title="0">{
                s.log.Errorf("sync access rule failed, error: %s", err.Error())
                return "", ErrorSyncAccessRuleToControllerFail("sync sync access rule failed, error: %s", err.Error())
        }</span>

        <span class="cov0" title="0">return createAccessProfileResp.Token, nil</span>
}

func (s *ForwardSyncService) unsyncAccessRuleToController(ctx context.Context, controllerID string,
        ar *syncV1.AccessRuleInfo) error <span class="cov0" title="0">{

        s.log.Infof("unsync access rule to controller %s, access rule: %+v", controllerID, ar)

        unsyncAccessRule, err := s.data.GetSyncAccessRule(ctx, ar.GetId())
        if err != nil </span><span class="cov0" title="0">{
                s.log.Errorf("get sync access rule failed, error: %s", err.Error())
                return ErrorUnsyncAccessRuleToControllerFail("get sync access rule failed, error: %s", err.Error())
        }</span>

        // controller will not remove access rule from credential automatically when access rule is deleted
        // so we need to remove access rule from credential manually
        <span class="cov0" title="0">for _, syncCredential := range unsyncAccessRule.SyncCredentials </span><span class="cov0" title="0">{
                s.log.Infof("remove access rule from credential on controller, credential: %s, access rule: %s",
                        syncCredential.Token, unsyncAccessRule.Token)

                err = s.updateCredentialWithDeletedAccessRule(ctx, controllerID, syncCredential.Token, unsyncAccessRule.Token)
                if err != nil </span><span class="cov0" title="0">{
                        s.log.Errorf("update credential with deleted access rule failed, credential: %s, access rule: %s, error: %s",
                                syncCredential.Token, unsyncAccessRule.Token, err.Error())
                        return ErrorUnsyncAccessRuleToControllerFail(
                                "update credential with deleted access rule failed, credential: %s, access rule: %s, error: %s",
                                syncCredential.Token, unsyncAccessRule.Token, err.Error())
                }</span>
        }

        // delete access profile
        <span class="cov0" title="0">deleteAccessProfileReq := &amp;doorhandler.DeleteAccessProfileRequest{
                Token: unsyncAccessRule.Token,
        }
        err = s.operationUseCase.DeleteAccessProfile(ctx, s.operationConf, controllerID, deleteAccessProfileReq)
        if err != nil </span><span class="cov0" title="0">{
                s.log.Errorf("delete access profile failed, access profile: %s, error: %s",
                        deleteAccessProfileReq, err.Error())
                return ErrorUnsyncAccessRuleToControllerFail(
                        "delete access profile failed, access profile: %s, error: %s", deleteAccessProfileReq, err.Error())
        }</span>

        <span class="cov0" title="0">s.log.Infof("access profile deleted, id: %s token: %s", unsyncAccessRule.ID, unsyncAccessRule.Token)

        // save unique id to token mapping in db
        err = s.data.RemoveSyncAccessRule(ctx, ar.GetId())
        if err != nil </span><span class="cov0" title="0">{
                s.log.Errorf("unsync access rule failed, error: %s", err.Error())
                return ErrorUnsyncAccessRuleToControllerFail("unsync sync access rule failed, error: %s", err.Error())
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (s *ForwardSyncService) addCredentialsToController(ctx context.Context, controllerID string,
        accessRuleTokens []string, userToken string, user *syncV1.UserInfo,
        userCredential *syncV1.UserCredentialInfo) error <span class="cov0" title="0">{

        s.log.Infof("add credential to controller, access rule tokens: %+v, user token: %s, user: %+v, credential: %+v",
                accessRuleTokens, userToken, user, userCredential)

        // TODO: get user token from db instead of passing in
        // create credential
        createCredentialReq := &amp;doorhandler.CreateCredentialRequest{
                Credential: doorhandler.Credential{
                        UserToken:               userToken,
                        Description:             user.GetDescription(),
                        ValidFrom:               user.GetValidFrom(),
                        ValidTo:                 user.GetValidUntil(),
                        Enabled:                 true,
                        Attribute:               true, // TODO: check how this one is used
                        Status:                  "Enabled",
                        CredentialAccessProfile: []*doorhandler.CredentialAccessProfile{},
                },
        }

        // add access rules to credential
        for _, accessRuleToken := range accessRuleTokens </span><span class="cov0" title="0">{
                createCredentialReq.Credential.CredentialAccessProfile =
                        append(createCredentialReq.Credential.CredentialAccessProfile,
                                &amp;doorhandler.CredentialAccessProfile{
                                        // TODO: check how this valid duration is used, not shown on web UI
                                        ValidFrom:     "",
                                        ValidTo:       "",
                                        AccessProfile: accessRuleToken,
                                },
                        )
        }</span>

        // add credential data
        <span class="cov0" title="0">switch userCredential.GetType() </span>{
        case syncV1.UserCredentialType_UNKNOWN:<span class="cov0" title="0">
                s.log.Errorf("unknown user credential type")
                return ErrorAddCredentialToControllerFail("unknown user credential type")</span>
        case syncV1.UserCredentialType_PIN:<span class="cov0" title="0">
                createCredentialReq.Credential.PIN = userCredential.GetPin()</span>
        case syncV1.UserCredentialType_CARD:<span class="cov0" title="0">
                createCredentialReq.Credential.CardNr = userCredential.GetCardNumber()
                // axis's card &amp; facility code eqauls to the web facility code
                createCredentialReq.Credential.Card = userCredential.GetFacilityCode()</span>
        }

        // send create credential request
        <span class="cov0" title="0">createCredentialResp, err := s.operationUseCase.CreateCredential(ctx, s.operationConf, controllerID, createCredentialReq)
        if err != nil </span><span class="cov0" title="0">{
                s.log.Errorf("create credential for user %+v failed, error: %s", user, err.Error())
                return ErrorAddCredentialToControllerFail("create credential for user %+v failed, error: %s",
                        user, err.Error())
        }</span>
        <span class="cov0" title="0">if createCredentialResp == nil </span><span class="cov0" title="0">{
                s.log.Errorf("create credential for user %+v failed, resp is nil", user)
                return ErrorAddCredentialToControllerFail("create credential for user %+v failed, resp is nil", user)
        }</span>

        <span class="cov0" title="0">s.log.Infof("credential created, token: %s", createCredentialResp.Token)
        // save unique id to token mapping in db
        err = s.data.AddSyncCredential(ctx, user.GetId(), userCredential.GetId(),
                createCredentialResp.Token, accessRuleTokens)
        if err != nil </span><span class="cov0" title="0">{
                s.log.Errorf("add sync user failed, error: %s", err.Error())
                return ErrorAddCredentialToControllerFail("add sync user failed, error: %s", err.Error())
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (s *ForwardSyncService) updateCredentialWithNewAccessRule(ctx context.Context, controllerID string,
        accessRuleToken string, credentialToken string) error <span class="cov0" title="0">{

        // TODO: use axis GetCredential API with token
        listCredentialResp, err := s.operationUseCase.ListCredential(ctx, s.operationConf, controllerID)
        if err != nil </span><span class="cov0" title="0">{
                s.log.Errorf("list credential on controller %s failed, error: %s", controllerID, err.Error())
                return ErrorSyncUpdateCredentialWithNewAccessRuleFail("list credential on controller %s failed, error: %s",
                        controllerID, err.Error())
        }</span>

        <span class="cov0" title="0">filteredCredential := lo.Filter(listCredentialResp.Credentials, func(c *doorhandler.Credential, _ int) bool </span><span class="cov0" title="0">{
                return c.Token == credentialToken
        }</span>)

        <span class="cov0" title="0">if len(filteredCredential) == 0 </span><span class="cov0" title="0">{
                s.log.Errorf("credential %s not found on controller %s", credentialToken, controllerID)
                return ErrorSyncUpdateCredentialWithNewAccessRuleFail("credential %s not found on controller %s",
                        credentialToken, controllerID)
        }</span> else<span class="cov0" title="0"> if len(filteredCredential) &gt; 1 </span><span class="cov0" title="0">{
                s.log.Errorf("multiple credential %s found on controller %s", credentialToken, controllerID)
                return ErrorSyncUpdateCredentialWithNewAccessRuleFail("multiple credential %s found on controller %s",
                        credentialToken, controllerID)
        }</span>

        // take the only one filtered as target credential
        <span class="cov0" title="0">targetCredential := filteredCredential[0]
        // check if credential already has access rule
        if lo.ContainsBy(targetCredential.CredentialAccessProfile, func(cap *doorhandler.CredentialAccessProfile) bool </span><span class="cov0" title="0">{
                return cap.AccessProfile == accessRuleToken
        }</span>) <span class="cov0" title="0">{

                s.log.Infof("credential %s already has access rule %s", targetCredential.Token, accessRuleToken)
                return nil
        }</span>
        // add access rule to credential
        <span class="cov0" title="0">if targetCredential.CredentialAccessProfile == nil </span><span class="cov0" title="0">{
                targetCredential.CredentialAccessProfile = make([]*doorhandler.CredentialAccessProfile, 0)
        }</span>
        <span class="cov0" title="0">targetCredential.CredentialAccessProfile = append(targetCredential.CredentialAccessProfile,
                &amp;doorhandler.CredentialAccessProfile{
                        // TODO: check how this valid duration is used, not shown on web UI
                        ValidFrom:     "",
                        ValidTo:       "",
                        AccessProfile: accessRuleToken,
                },
        )

        updateCredentialReq := &amp;doorhandler.UpdateCredentialRequest{
                Credential: *targetCredential,
        }

        err = s.operationUseCase.UpdateCredential(ctx, s.operationConf, controllerID, updateCredentialReq)
        if err != nil </span><span class="cov0" title="0">{
                s.log.Errorf("update credential %s with new access rule %s failed, error: %s",
                        targetCredential.Token, accessRuleToken, err.Error())
                return ErrorSyncUpdateCredentialWithNewAccessRuleFail(
                        "update credential %s with new access rule %s failed, error: %s",
                        targetCredential.Token, accessRuleToken, err.Error())
        }</span>

        <span class="cov0" title="0">err = s.data.AddSyncCredentialAccessRule(ctx, credentialToken, []string{accessRuleToken})
        if err != nil </span><span class="cov0" title="0">{
                s.log.Errorf("add sync credential access rule failed, credential: %s, access rule: %s, error: %s",
                        credentialToken, accessRuleToken, err.Error())
                return ErrorSyncUpdateCredentialWithNewAccessRuleFail(
                        "add sync credential access rule failed, credential: %s, access rule: %s, error: %s",
                        credentialToken, accessRuleToken, err.Error())
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (s *ForwardSyncService) updateCredentialWithDeletedAccessRule(ctx context.Context, controllerID string,
        credentialToken string, accessRuleToken string) error <span class="cov0" title="0">{

        // TODO: use axis GetCredential API with token
        listCredentialResp, err := s.operationUseCase.ListCredential(ctx, s.operationConf, controllerID)
        if err != nil </span><span class="cov0" title="0">{
                s.log.Errorf("list credential on controller %s failed, error: %s", controllerID, err.Error())
                return ErrorUpdateCredentialWithDeletedAccessRuleFail("list credential on controller %s failed, error: %s",
                        controllerID, err.Error())
        }</span>

        <span class="cov0" title="0">filteredCredential := lo.Filter(listCredentialResp.Credentials, func(c *doorhandler.Credential, _ int) bool </span><span class="cov0" title="0">{
                return c.Token == credentialToken
        }</span>)

        <span class="cov0" title="0">if len(filteredCredential) == 0 </span><span class="cov0" title="0">{
                s.log.Errorf("credential %s not found on controller %s", credentialToken, controllerID)
                return ErrorUpdateCredentialWithDeletedAccessRuleFail("credential %s not found on controller %s",
                        credentialToken, controllerID)
        }</span> else<span class="cov0" title="0"> if len(filteredCredential) &gt; 1 </span><span class="cov0" title="0">{
                s.log.Errorf("multiple credential %s found on controller %s", credentialToken, controllerID)
                return ErrorUpdateCredentialWithDeletedAccessRuleFail("multiple credential %s found on controller %s",
                        credentialToken, controllerID)
        }</span>

        // take the only one filtered as target credential
        <span class="cov0" title="0">targetCredential := filteredCredential[0]
        // check if credential already has access rule
        if !lo.ContainsBy(targetCredential.CredentialAccessProfile, func(cap *doorhandler.CredentialAccessProfile) bool </span><span class="cov0" title="0">{
                return cap.AccessProfile == accessRuleToken
        }</span>) <span class="cov0" title="0">{

                s.log.Infof("credential already unsync access rule, credential: %s, access rule: %s",
                        targetCredential.Token, accessRuleToken)
                return nil
        }</span>
        // remove access rule from credential
        <span class="cov0" title="0">targetCredential.CredentialAccessProfile = lo.Filter(targetCredential.CredentialAccessProfile,
                func(cap *doorhandler.CredentialAccessProfile, _ int) bool </span><span class="cov0" title="0">{
                        return cap.AccessProfile != accessRuleToken
                }</span>)
        <span class="cov0" title="0">updateCredentialReq := &amp;doorhandler.UpdateCredentialRequest{
                Credential: *targetCredential,
        }

        // TODO: share code with updateCredentialWithNewAccessRule
        err = s.operationUseCase.UpdateCredential(ctx, s.operationConf, controllerID, updateCredentialReq)
        if err != nil </span><span class="cov0" title="0">{
                s.log.Errorf("update credential %s with deleted access rule %s failed, error: %s",
                        targetCredential.Token, accessRuleToken, err.Error())
                return ErrorUpdateCredentialWithDeletedAccessRuleFail(
                        "update credential %s with deleted access rule %s failed, error: %s",
                        targetCredential.Token, accessRuleToken, err.Error())
        }</span>

        <span class="cov0" title="0">err = s.data.AddSyncCredentialAccessRule(ctx, credentialToken, []string{accessRuleToken})
        if err != nil </span><span class="cov0" title="0">{
                s.log.Errorf("add sync credential access rule failed, credential: %s, access rule: %s, error: %s",
                        credentialToken, accessRuleToken, err.Error())
                return ErrorUpdateCredentialWithDeletedAccessRuleFail(
                        "add sync credential access rule failed, credential: %s, access rule: %s, error: %s",
                        credentialToken, accessRuleToken, err.Error())
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (s *ForwardSyncService) syncCredentialWithNewAccessRule(ctx context.Context, controllerID string,
        accessRuleToken string, userToken string, user *syncV1.UserInfo) error <span class="cov0" title="0">{

        // for each credential of user
        // check if credential is already created, if yes, add access rule to credential
        // check if credential is already created, if no, create credential with access rule
        for _, userCredential := range user.GetUserCredentials() </span><span class="cov0" title="0">{
                syncCredential, err := s.data.GetSyncCredential(ctx, userCredential.GetId())

                if datastore.IsSyncCredentialNotFound(err) </span><span class="cov0" title="0">{
                        // credential not found, create new credential
                        err = s.addCredentialsToController(ctx, controllerID, []string{accessRuleToken}, userToken,
                                user, userCredential)
                        if err != nil </span><span class="cov0" title="0">{
                                s.log.Errorf("create credential for user %+v failed, credential id: %s, error: %s",
                                        user, userCredential.GetId(), err.Error())
                                return ErrorSyncCredentialWithNewAccessRuleFail(
                                        "create credential for user %+v failed, credential id: %s, error: %s",
                                        user, userCredential.GetId(), err.Error())
                        }</span>
                        <span class="cov0" title="0">continue</span>
                }

                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        s.log.Errorf("get sync credential failed, error: %s", err.Error())
                        return ErrorSyncCredentialWithNewAccessRuleFail("get sync credential failed, error: %s", err.Error())
                }</span>

                <span class="cov0" title="0">err = s.updateCredentialWithNewAccessRule(ctx, controllerID, accessRuleToken, syncCredential.Token)
                if err != nil </span><span class="cov0" title="0">{
                        s.log.Errorf("update credential %s with new access rule %s failed, error: %s",
                                syncCredential.Token, accessRuleToken, err.Error())
                        return ErrorSyncCredentialWithNewAccessRuleFail(
                                "update credential %s with new access rule %s failed, error: %s",
                                syncCredential.Token, accessRuleToken, err.Error())
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func (s *ForwardSyncService) syncCredentialWithNewCredentials(ctx context.Context, controllerID string,
        accessRulesInfo []*syncV1.AccessRuleInfo, user *syncV1.UserInfo) error <span class="cov0" title="0">{

        // get access rule tokens from db
        accessRuleIDs := lo.Map(accessRulesInfo, func(ar *syncV1.AccessRuleInfo, _ int) string </span><span class="cov0" title="0">{
                return ar.GetId()
        }</span>)
        <span class="cov0" title="0">syncAccessRules, err := s.data.ListSyncAccessRuleByIDs(ctx, accessRuleIDs)
        if err != nil </span><span class="cov0" title="0">{
                s.log.Errorf("list sync access rule failed, error: %s", err.Error())
                return ErrorSyncCredentialWithNewCredentialsFail("list sync access rule failed, error: %s", err.Error())
        }</span>
        <span class="cov0" title="0">accessRuleTokens := lo.Map(syncAccessRules, func(ar *datastore.SyncAccessRule, _ int) string </span><span class="cov0" title="0">{
                return ar.Token
        }</span>)

        // get user token from db
        <span class="cov0" title="0">syncUser, err := s.data.GetSyncUser(ctx, user.GetId())
        if err != nil </span><span class="cov0" title="0">{
                s.log.Errorf("get sync user failed, error: %s", err.Error())
                return ErrorSyncCredentialWithNewCredentialsFail("get sync user failed, error: %s", err.Error())
        }</span>

        // for each credential of user and each access rule
        // check if credential is already created, if yes, do nothing (because only new credentials are added)
        // check if credential is already created, if no, create credential with all access rule
        <span class="cov0" title="0">for _, userCredential := range user.GetUserCredentials() </span><span class="cov0" title="0">{
                _, err := s.data.GetSyncCredential(ctx, userCredential.GetId())

                // error not found
                if datastore.IsSyncCredentialNotFound(err) </span><span class="cov0" title="0">{
                        // credential not found, create new credential
                        err = s.addCredentialsToController(ctx, controllerID, accessRuleTokens, syncUser.Token,
                                user, userCredential)
                        if err != nil </span><span class="cov0" title="0">{
                                s.log.Errorf("create credential for user %+v failed, credential id: %s, error: %s",
                                        user, userCredential.GetId(), err.Error())
                                return ErrorSyncCredentialWithNewCredentialsFail(
                                        "create credential for user %+v failed, credential id: %s, error: %s",
                                        user, userCredential.GetId(), err.Error())
                        }</span>
                        <span class="cov0" title="0">continue</span>
                }

                // error others
                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        s.log.Errorf("get sync credential failed, error: %s", err.Error())
                        return ErrorSyncCredentialWithNewCredentialsFail("get sync credential failed, error: %s", err.Error())
                }</span>

                // already exist, don't do anything because only new credentials are added
        }

        <span class="cov0" title="0">return nil</span>
}

func (s *ForwardSyncService) unsyncCredentialToController(ctx context.Context, controllerID string,
        unsyncCredential *datastore.SyncCredential) error <span class="cov0" title="0">{

        s.log.Infof("unsync credential to controller, controller: %s, credential: %+v", controllerID, unsyncCredential)

        deleteCredentialReq := &amp;doorhandler.DeleteCredentialRequest{
                Token: unsyncCredential.Token,
        }

        err := s.operationUseCase.DeleteCredential(ctx, s.operationConf, controllerID, deleteCredentialReq)
        if err != nil </span><span class="cov0" title="0">{
                s.log.Errorf("delete credential on controller failed, controller: %s, credential: %s, token: %s error: %s",
                        controllerID, unsyncCredential.ID, unsyncCredential.Token, err.Error())
                return ErrorUnsyncCredentialToControllerFail(
                        "delete credential on controller failed, controller: %s, credential: %s, token: %s error: %s",
                        controllerID, unsyncCredential.ID, unsyncCredential.Token, err.Error())
        }</span>

        <span class="cov0" title="0">err = s.data.RemoveSyncCredential(ctx, unsyncCredential.ID)
        if err != nil </span><span class="cov0" title="0">{
                s.log.Errorf("delete sync credential failed, credential: %s, error: %s",
                        unsyncCredential.ID, err.Error())
                return ErrorUnsyncCredentialToControllerFail("delete sync credential failed, error: %s", err.Error())
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (s *ForwardSyncService) syncUserToController(ctx context.Context, controllerID string,
        user *syncV1.UserInfo) error <span class="cov0" title="0">{

        // Create user to controller
        createUserReq := &amp;doorhandler.CreateUserRequest{
                FirstName:   user.GetFirstName(),
                LastName:    user.GetLastName(),
                Description: user.GetDescription(),
        }
        createUserResp, err := s.operationUseCase.CreateUser(ctx, s.operationConf, controllerID, createUserReq)
        if err != nil </span><span class="cov0" title="0">{
                s.log.Errorf("add user %+v to controller %s failed, error: %s", user, controllerID, err.Error())
                return ErrorSyncUserToControllerFail("add user %+v to controller %s failed, error: %s",
                        user, controllerID, err.Error())
        }</span>
        <span class="cov0" title="0">if createUserResp == nil </span><span class="cov0" title="0">{
                s.log.Errorf("add user %+v to controller %s failed, resp is nil", user, controllerID)
                return ErrorSyncUserToControllerFail("add user %+v to controller %s failed, resp is nil",
                        user, controllerID)
        }</span>
        <span class="cov0" title="0">s.log.Infof("add user %s to controller %s success, token: %s",
                user.GetFirstName()+" "+user.GetLastName(), controllerID, createUserResp.Token)

        // save unique id to token mapping in db
        err = s.data.AddSyncUser(ctx, controllerID, user.GetId(), createUserResp.Token)
        if err != nil </span><span class="cov0" title="0">{
                s.log.Errorf("add sync user failed, error: %s", err.Error())
                return ErrorSyncUserToControllerFail("add sync user failed, error: %s", err.Error())
        }</span>

        <span class="cov0" title="0">for _, accessRuleInfo := range user.GetAccessRules() </span><span class="cov0" title="0">{
                accessRuleToken, err := s.syncAccessRuleToController(ctx, controllerID, accessRuleInfo)
                if err != nil </span><span class="cov0" title="0">{
                        s.log.Errorf("create access rule %+v failed, error: %s", accessRuleInfo, err.Error())
                        return ErrorSyncUserToControllerFail("create access rule %+v failed, error: %s",
                                accessRuleInfo, err.Error())
                }</span>

                <span class="cov0" title="0">s.log.Infof("access profiles created, name: %s, token: %s", accessRuleInfo.GetName(), accessRuleToken)

                err = s.syncCredentialWithNewAccessRule(ctx, controllerID, accessRuleToken, createUserResp.Token, user)
                if err != nil </span><span class="cov0" title="0">{
                        s.log.Errorf("create credential for user %+v failed, error: %s", user, err.Error())
                        return ErrorSyncUserToControllerFail("create credential for user %+v failed, error: %s",
                                user, err.Error())
                }</span>

                <span class="cov0" title="0">s.log.Infof("credentials created, user %s", user.GetFirstName()+" "+user.GetLastName())</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func (s *ForwardSyncService) unsyncUserToController(ctx context.Context, controllerID string,
        user *syncV1.UserInfo) error <span class="cov0" title="0">{

        s.log.Infof("unsync user to controller %s, user: %+v", controllerID, user)

        unsyncUser, err := s.data.GetSyncUser(ctx, user.GetId())
        if err != nil </span><span class="cov0" title="0">{
                s.log.Errorf("failed to get unsync user: %s", err.Error())
                return ErrorUnsyncUserToControllerFail("failed to get sync user: %s", err.Error())
        }</span>

        // credential in door is NOT removed when user is removed, so we need to remove them manually
        <span class="cov0" title="0">unsyncCredentials, err := s.data.GetSyncCredentialBySyncUserID(ctx, unsyncUser.ID)
        if err != nil </span><span class="cov0" title="0">{
                s.log.Errorf("failed to get sync credential: %s", err.Error())
                return ErrorUnsyncUserToControllerFail("failed to get sync credential: %s", err.Error())
        }</span>
        <span class="cov0" title="0">for _, unsyncCredential := range unsyncCredentials </span><span class="cov0" title="0">{
                err = s.unsyncCredentialToController(ctx, controllerID, unsyncCredential)
                if err != nil </span><span class="cov0" title="0">{
                        s.log.Errorf("failed to unsync credential, credential: %s, error: %s", unsyncCredential.ID, err.Error())
                        return ErrorUnsyncUserToControllerFail("failed to unsync credential, credential: %s, error: %s",
                                unsyncCredential.ID, err.Error())
                }</span>

                <span class="cov0" title="0">s.log.Infof("unsync credential %s success", unsyncCredential.ID)</span>
        }

        // delete user from controller
        <span class="cov0" title="0">deleteUserReq := &amp;doorhandler.DeleteUserRequest{
                Token: unsyncUser.Token,
        }
        err = s.operationUseCase.DeleteUser(ctx, s.operationConf, controllerID, deleteUserReq)
        if err != nil </span><span class="cov0" title="0">{
                s.log.Errorf("delete user %+v to controller %s failed, error: %s", user, controllerID, err.Error())
                return ErrorUnsyncUserToControllerFail("delete user %+v to controller %s failed, error: %s",
                        user, controllerID, err.Error())
        }</span>
        <span class="cov0" title="0">s.log.Infof("delete user %s from controller %s success", user.GetFirstName()+" "+user.GetLastName(), controllerID)

        // sync credential in db is removed when sync user is removed
        err = s.data.RemoveSyncUser(ctx, user.GetId())
        if err != nil </span><span class="cov0" title="0">{
                s.log.Errorf("delete sync user failed, error: %s", err.Error())
                return ErrorUnsyncUserToControllerFail("delete sync user failed, error: %s", err.Error())
        }</span>

        // nothing to do for access rule, because access rule is not removed when user is removed

        <span class="cov0" title="0">s.log.Infof("unsync user to controller %s success", controllerID)

        return nil</span>
}

func (s *ForwardSyncService) updateUserWithDeletedAccessRule(ctx context.Context, controllerID string,
        accessRule *syncV1.AccessRuleInfo, users []*syncV1.UserInfo) error <span class="cov0" title="0">{

        s.log.Infof("update user with deleted access rule, controller: %s, access rule: %+v, users: %+v",
                controllerID, accessRule, users)

        unsyncAccessRule, err := s.data.GetSyncAccessRule(ctx, accessRule.GetId())
        if err != nil </span><span class="cov0" title="0">{
                s.log.Errorf("failed to get unsync access rule, error: %s", err.Error())
                return ErrorUpdateUserWithDeletedAccessRuleFail("failed to get sync access rule: %s", err.Error())
        }</span>

        // TODO: optimize db to use IN syntax for less db query
        <span class="cov0" title="0">for _, user := range users </span><span class="cov0" title="0">{
                updateSyncUser, err := s.data.GetSyncUser(ctx, user.GetId())
                if err != nil </span><span class="cov0" title="0">{
                        s.log.Errorf("failed to get unsync user, error: %s", err.Error())
                        return ErrorUpdateUserWithDeletedAccessRuleFail("failed to get sync user: %s", err.Error())
                }</span>

                // for each credential of user, remove access rule from credential
                <span class="cov0" title="0">updateSyncCredentials, err := s.data.GetSyncCredentialBySyncUserID(ctx, updateSyncUser.ID)
                if err != nil </span><span class="cov0" title="0">{
                        s.log.Errorf("failed to get sync credential, error: %s", err.Error())
                        return ErrorUpdateUserWithDeletedAccessRuleFail("failed to get sync credential: %s", err.Error())
                }</span>
                <span class="cov0" title="0">for _, updateSyncCredential := range updateSyncCredentials </span><span class="cov0" title="0">{
                        err = s.updateCredentialWithDeletedAccessRule(ctx, controllerID, updateSyncCredential.Token,
                                unsyncAccessRule.Token)
                        if err != nil </span><span class="cov0" title="0">{
                                s.log.Errorf("failed to unsync credential, credential: %s, error: %s",
                                        updateSyncCredential.ID, err.Error())
                                return ErrorUpdateUserWithDeletedAccessRuleFail(
                                        "failed to unsync credential, credential: %s, error: %s",
                                        updateSyncCredential.ID, err.Error())
                        }</span>

                        <span class="cov0" title="0">s.log.Infof("unsync credential success, id: %s", updateSyncCredential.ID)</span>
                }
        }

        <span class="cov0" title="0">s.log.Infof("update user with deleted access rule success")

        return nil</span>
}

func (s *ForwardSyncService) syncDoorToController(ctx context.Context, controllerID string,
        accessRuleInfo *syncV1.AccessRuleInfo, doorsInfo []*syncV1.DoorInfo) error <span class="cov0" title="0">{

        s.log.Infof("sync door to controller, controller: %s, access rule: %+v, doors: %+v",
                controllerID, accessRuleInfo, doorsInfo)

        // get access profile token from db with id
        syncAccessRule, err := s.data.GetSyncAccessRule(ctx, accessRuleInfo.GetId())
        if err != nil </span><span class="cov0" title="0">{
                s.log.Errorf("failed to get sync access rule: %s", err.Error())
                return ErrorSyncDoorToControllerFail("failed to get sync access rule: %s", err.Error())
        }</span>

        // get access profile data from controller with token
        <span class="cov0" title="0">listAccessProfileResp, err := s.operationUseCase.ListAccessProfile(ctx, s.operationConf, controllerID)
        if err != nil </span><span class="cov0" title="0">{
                s.log.Errorf("list access profile on controller %s failed, error: %s", controllerID, err.Error())
                return ErrorSyncDoorToControllerFail("list access profile on controller %s failed, error: %s",
                        controllerID, err.Error())
        }</span>
        <span class="cov0" title="0">filteredAccessProfile := lo.Filter(listAccessProfileResp.AccessProfiles, func(
                ap *doorhandler.AccessProfile, _ int) bool </span><span class="cov0" title="0">{

                return ap.Token == syncAccessRule.Token
        }</span>)

        <span class="cov0" title="0">if len(filteredAccessProfile) == 0 </span><span class="cov0" title="0">{
                s.log.Errorf("access profile %s not found on controller %s", syncAccessRule.Token, controllerID)
                return ErrorSyncDoorToControllerFail("access profile %s not found on controller %s",
                        syncAccessRule.Token, controllerID)
        }</span> else<span class="cov0" title="0"> if len(filteredAccessProfile) &gt; 1 </span><span class="cov0" title="0">{
                s.log.Errorf("multiple access profile %s found on controller %s", syncAccessRule.Token, controllerID)
                return ErrorSyncDoorToControllerFail("multiple access profile %s found on controller %s",
                        syncAccessRule.Token, controllerID)
        }</span>
        // take the only one filtered as target credential
        <span class="cov0" title="0">targetAccessProfile := filteredAccessProfile[0]

        // get door tokens not already added to access rule
        newlyAddedDoorTokens := lo.FilterMap(doorsInfo, func(di *syncV1.DoorInfo, _ int) (string, bool) </span><span class="cov0" title="0">{
                if lo.ContainsBy(targetAccessProfile.AccessPolicy, func(ap *doorhandler.AccessPolicy) bool </span><span class="cov0" title="0">{
                        return ap.AccessPoint == di.GetToken()
                }</span>) <span class="cov0" title="0">{

                        return "", false
                }</span>
                <span class="cov0" title="0">return di.GetToken(), true</span>
        })

        <span class="cov0" title="0">s.log.Debugf("newly added door tokens: %+v", newlyAddedDoorTokens)
        if len(newlyAddedDoorTokens) == 0 </span><span class="cov0" title="0">{
                s.log.Infof("no new door to add to access profile %s, done", targetAccessProfile.Token)
                return nil
        }</span>

        // TODO: make standaard always constant
        // update access profile to controller
        <span class="cov0" title="0">updateAccessProfileReq := &amp;doorhandler.UpdateAccessProfileRequest{
                AccessProfile: *targetAccessProfile,
        }
        for _, doorToken := range newlyAddedDoorTokens </span><span class="cov0" title="0">{
                updateAccessProfileReq.AccessProfile.AccessPolicy = append(updateAccessProfileReq.AccessProfile.AccessPolicy,
                        &amp;doorhandler.AccessPolicy{
                                AccessPoint: doorToken,
                                Schedule:    []string{"standard_always"},
                        })
        }</span>

        <span class="cov0" title="0">err = s.operationUseCase.UpdateAccessProfile(ctx, s.operationConf, controllerID, updateAccessProfileReq)
        if err != nil </span><span class="cov0" title="0">{
                s.log.Errorf("update access profile %s with new doors failed, error: %s",
                        targetAccessProfile.Token, err.Error())
                return ErrorSyncDoorToControllerFail("update access profile %s with new doors failed, error: %s",
                        targetAccessProfile.Token, err.Error())
        }</span>
        <span class="cov0" title="0">s.log.Infof("update access profile %s with new doors success", targetAccessProfile.Token)

        return nil</span>
}

func (s *ForwardSyncService) unsyncDoorToController(ctx context.Context, controllerID string, accessRuleInfo *syncV1.AccessRuleInfo,
        doorsInfo []*syncV1.DoorInfo) error <span class="cov0" title="0">{

        s.log.Infof("unsync door to controller %s, access rule: %+v, doors: %+v", controllerID, accessRuleInfo, doorsInfo)

        // get access profile token from db with id
        syncAccessRule, err := s.data.GetSyncAccessRule(ctx, accessRuleInfo.GetId())
        if err != nil </span><span class="cov0" title="0">{
                s.log.Errorf("failed to get sync access rule: %s", err.Error())
                return ErrorSyncDoorToControllerFail("failed to get sync access rule: %s", err.Error())
        }</span>

        // get access profile data from controller with token
        <span class="cov0" title="0">listAccessProfileResp, err := s.operationUseCase.ListAccessProfile(ctx, s.operationConf, controllerID)
        if err != nil </span><span class="cov0" title="0">{
                s.log.Errorf("list access profile on controller %s failed, error: %s", controllerID, err.Error())
                return ErrorSyncDoorToControllerFail("list access profile on controller %s failed, error: %s",
                        controllerID, err.Error())
        }</span>
        <span class="cov0" title="0">filteredAccessProfile := lo.Filter(listAccessProfileResp.AccessProfiles, func(ap *doorhandler.AccessProfile, _ int) bool </span><span class="cov0" title="0">{
                return ap.Token == syncAccessRule.Token
        }</span>)

        <span class="cov0" title="0">if len(filteredAccessProfile) == 0 </span><span class="cov0" title="0">{
                s.log.Errorf("access profile %s not found on controller %s", syncAccessRule.Token, controllerID)
                return ErrorSyncDoorToControllerFail("access profile %s not found on controller %s",
                        syncAccessRule.Token, controllerID)
        }</span> else<span class="cov0" title="0"> if len(filteredAccessProfile) &gt; 1 </span><span class="cov0" title="0">{
                s.log.Errorf("multiple access profile %s found on controller %s", syncAccessRule.Token, controllerID)
                return ErrorSyncDoorToControllerFail("multiple access profile %s found on controller %s",
                        syncAccessRule.Token, controllerID)
        }</span>
        // take the only one filtered as target credential
        <span class="cov0" title="0">targetAccessProfile := filteredAccessProfile[0]

        // get door tokens to delete from access rule
        newlyDeletedDoorTokens := lo.FilterMap(doorsInfo, func(di *syncV1.DoorInfo, _ int) (string, bool) </span><span class="cov0" title="0">{
                if lo.ContainsBy(targetAccessProfile.AccessPolicy, func(ap *doorhandler.AccessPolicy) bool </span><span class="cov0" title="0">{
                        return ap.AccessPoint == di.GetToken()
                }</span>) <span class="cov0" title="0">{

                        return di.GetToken(), true
                }</span>
                <span class="cov0" title="0">return "", false</span>
        })

        <span class="cov0" title="0">s.log.Debugf("newly deleted door tokens: %+v", newlyDeletedDoorTokens)
        if len(newlyDeletedDoorTokens) == 0 </span><span class="cov0" title="0">{
                s.log.Infof("no new door to delete to access profile %s, done", targetAccessProfile.Token)
                return nil
        }</span>

        // TODO: make standaard always constant
        // update access profile to controller
        <span class="cov0" title="0">updateAccessProfileReq := &amp;doorhandler.UpdateAccessProfileRequest{
                AccessProfile: *targetAccessProfile,
        }
        updateAccessProfileReq.AccessProfile.AccessPolicy = lo.Filter(targetAccessProfile.AccessPolicy,
                func(ap *doorhandler.AccessPolicy, _ int) bool </span><span class="cov0" title="0">{
                        return !lo.Contains(newlyDeletedDoorTokens, ap.AccessPoint)
                }</span>,
        )

        <span class="cov0" title="0">err = s.operationUseCase.UpdateAccessProfile(ctx, s.operationConf, controllerID, updateAccessProfileReq)
        if err != nil </span><span class="cov0" title="0">{
                s.log.Errorf("update access profile %s with deleted doors failed, error: %s",
                        targetAccessProfile.Token, err.Error())
                return ErrorSyncDoorToControllerFail("update access profile %s with deleted doors failed, error: %s",
                        targetAccessProfile.Token, err.Error())
        }</span>
        <span class="cov0" title="0">s.log.Infof("update access profile %s with deleted doors success", targetAccessProfile.Token)

        return nil</span>
}

func (s *ForwardSyncService) Close() <span class="cov0" title="0">{
        s.log.Infof("forward sync service close")

        // cancel running routine for sync queue
        if s.agentQueueRoutineCancel != nil </span><span class="cov0" title="0">{
                s.agentQueueRoutineCancel()
        }</span>

        // cancel for sync queue manager
        <span class="cov0" title="0">s.agentQueueManagerCancel()</span>
}

func (s *ForwardSyncService) SyncAddAsyncTask(ctx context.Context, req *forwardSyncV1.SyncAddAsyncTaskRequest,
        resChan chan *forwardSyncV1.SyncAddAsyncTaskReply) <span class="cov0" title="0">{

        taskDatas := req.GetTaskDatas()
        taskByteList := lo.Map(taskDatas, func(taskData string, _ int) []byte </span><span class="cov0" title="0">{
                return []byte(taskData)
        }</span>)

        <span class="cov0" title="0">for _, taskBytes := range taskByteList </span><span class="cov0" title="0">{
                t, err := task.FromBytesTo[taskbase.Task](taskBytes)
                if err != nil </span><span class="cov0" title="0">{
                        s.log.Errorf("failed to convert task bytes to task, error: %s", err.Error())
                        resChan &lt;- grpcServerSideRequest.NewErrorResponse[forwardSyncV1.SyncAddAsyncTaskReply](req.RequestId,
                                grpcServerSideRequest.ErrorCodeUnknownError,
                                fmt.Sprintf("failed to convert task bytes to task, error: %s", err.Error()))
                        return
                }</span>

                <span class="cov0" title="0">err = s.agentQueueManager.AddTask(forwardSyncTaskQueueName, ctx, t)
                if err != nil </span><span class="cov0" title="0">{
                        s.log.Errorf("failed to add task to agent queue: %s", err.Error())
                        resChan &lt;- grpcServerSideRequest.NewErrorResponse[forwardSyncV1.SyncAddAsyncTaskReply](req.RequestId,
                                grpcServerSideRequest.ErrorCodeUnknownError, fmt.Sprintf("failed to add task to agent queue: %s", err.Error()))
                        return
                }</span>
        }

        // Return
        <span class="cov0" title="0">resChan &lt;- &amp;forwardSyncV1.SyncAddAsyncTaskReply{
                Error:     nil,
                RequestId: req.GetRequestId(),
        }</span>
}
</pre>

		<pre class="file" id="file9" style="display: none">package service

import (
        "context"

        "git.synology.inc/sast/3rd-party/goupnp.git"
        "git.synology.inc/sast/access-system/server/agent/internal/biz"
        "git.synology.inc/sast/access-system/server/agent/internal/doorhandler"
        forwardUpnpV1 "git.synology.inc/sast/access-system/server/gateway/api/forward_upnp/v1"
        "github.com/go-kratos/kratos/v2/log"
)

type ForwardUpnpService struct {
        upnpUseCase *biz.UpnpUseCase
        log         *log.Helper
}

func NewForwardUpnpService(logger log.Logger, upnpUseCase *biz.UpnpUseCase) *ForwardUpnpService <span class="cov0" title="0">{
        return &amp;ForwardUpnpService{
                upnpUseCase: upnpUseCase,
                log:         log.NewHelper(logger),
        }
}</span>

func (s *ForwardUpnpService) Search(ctx context.Context,
        req *forwardUpnpV1.UpnpSearchRequest, resChan chan *forwardUpnpV1.UpnpSearchReply) <span class="cov0" title="0">{

        // Defer func to prevent sent to close channel
        defer func() </span><span class="cov0" title="0">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        s.log.Info("recover from resChan")
                }</span>
        }()

        // Arrange
        <span class="cov0" title="0">deviceChan := make(chan goupnp.MaybeRootDevice)
        defer close(deviceChan)

        // Act
        go s.upnpUseCase.Search(ctx, deviceChan)

        // Send response to resChan
        for </span><span class="cov0" title="0">{
                select </span>{
                case device, ok := &lt;-deviceChan:<span class="cov0" title="0">
                        if !ok </span><span class="cov0" title="0">{
                                return
                        }</span>

                        <span class="cov0" title="0">if device.Err != nil </span><span class="cov0" title="0">{
                                s.log.Errorf("error discovering devices: %s", device.Err.Error())
                                continue</span>
                        }

                        <span class="cov0" title="0">if device.Root == nil </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        <span class="cov0" title="0">vendor, model := doorhandler.ParseModelName(device.Root.Device.ModelName)
                        resChan &lt;- &amp;forwardUpnpV1.UpnpSearchReply{
                                Error:     nil,
                                RequestId: req.GetRequestId(),
                                Vendor:    vendor,
                                Model:     model,
                                Ip:        device.Root.IP,
                        }</span>
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        s.log.Info("context done - ClientStream")
                        return</span>
                }
        }
}
</pre>

		<pre class="file" id="file10" style="display: none">package service

import (
        "context"
        "io"
        "time"

        "git.synology.inc/sast/access-system/server/agent/internal/biz"
        "git.synology.inc/sast/access-system/server/agent/internal/conf"
        fromAgentV1 "git.synology.inc/sast/access-system/server/gateway/api/from_agent/v1"
        contextController "git.synology.inc/sast/access-system/server/internal/context_controller"
        grpcConn "git.synology.inc/sast/access-system/server/internal/grpc"
        "github.com/go-kratos/kratos/v2/log"
        "google.golang.org/grpc/metadata"
        "google.golang.org/protobuf/types/known/emptypb"
)

type FromAgentService struct {
        externalConfig      *conf.External
        appInfoUseCase      *biz.AppInfoUseCase
        fromAgentClient     fromAgentV1.FromAgentClient
        ctxControllerClient contextController.ClientInterface
        logger              *log.Helper
}

func NewFromAgentService(externalConfig *conf.External, appInfoUseCase *biz.AppInfoUseCase, logger log.Logger) *FromAgentService <span class="cov0" title="0">{
        return &amp;FromAgentService{
                appInfoUseCase: appInfoUseCase,
                externalConfig: externalConfig,
                logger:         log.NewHelper(logger),
        }
}</span>

func (s *FromAgentService) Init(client fromAgentV1.FromAgentClient, ctxControllerClient contextController.ClientInterface) <span class="cov0" title="0">{
        s.fromAgentClient = client
        s.ctxControllerClient = ctxControllerClient
}</span>

func (s *FromAgentService) Keepalive(ctx context.Context) <span class="cov0" title="0">{
        interval := s.externalConfig.GetKeepaliveInterval().AsDuration()
        if interval.Seconds() == 0 </span><span class="cov0" title="0">{
                s.logger.Errorf("keepalive - interval is 0")
                s.ctxControllerClient.Close()
                return
        }</span>

        // Arrange
        <span class="cov0" title="0">agentInfoCtx := metadata.AppendToOutgoingContext(ctx,
                grpcConn.MetaDataAgentID, s.appInfoUseCase.GetAppInfo().ID,
                grpcConn.MetaDataAgentVersion, s.appInfoUseCase.GetAppInfo().Version)

        // Act
        stream, err := s.fromAgentClient.Keepalive(agentInfoCtx)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Errorf("keepalive - failed to create stream: %s", err.Error())
                s.ctxControllerClient.Close()
                return
        }</span>

        // Stream subContext
        <span class="cov0" title="0">subContext, ctxCancel := context.WithCancel(stream.Context())
        defer func() </span><span class="cov0" title="0">{
                s.logger.Infof("keepalive - defer close")
                s.ctxControllerClient.Close()
                ctxCancel()
        }</span>()

        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                ticker := time.NewTicker(interval)
                for </span><span class="cov0" title="0">{
                        select </span>{
                        case &lt;-ctx.Done():<span class="cov0" title="0">
                                ticker.Stop()

                                s.logger.Debugf("keepalive - send - context done")
                                return</span>
                        case &lt;-subContext.Done():<span class="cov0" title="0">
                                ticker.Stop()

                                s.logger.Debugf("keepalive - send - sub context done")
                                return</span>
                        case &lt;-ticker.C:<span class="cov0" title="0">
                                s.logger.Debugf("keepalive - ticker ticked")

                                err := stream.Send(&amp;emptypb.Empty{})
                                if err != nil </span><span class="cov0" title="0">{
                                        s.logger.Errorf("keepalive - failed to send request: %s", err.Error())
                                        return
                                }</span>
                        }
                }
        }()

        // Handle message
        <span class="cov0" title="0">for </span><span class="cov0" title="0">{
                // Receive message
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        s.logger.Debugf("keepalive - receive - context done")
                        return</span>
                case &lt;-subContext.Done():<span class="cov0" title="0">
                        s.logger.Debugf("keepalive - receive - sub context done")
                        return</span>
                default:<span class="cov0" title="0">
                        res, err := stream.Recv()
                        if err == io.EOF </span><span class="cov0" title="0">{
                                s.logger.Infof("keepalive - stream closed with EOF")
                                return
                        }</span>
                        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                                s.logger.Errorf("keepalive - failed to receive request: %s", err.Error())
                                return
                        }</span>
                        <span class="cov0" title="0">s.logger.Infof("keepalive - receive response: %s", res.String())
                        switch res.GetStatus() </span>{
                        case fromAgentV1.KeepaliveStatus_Connected:<span class="cov0" title="0">
                                // Send connected
                                s.logger.Infof("keepalive - stream connected")
                                s.ctxControllerClient.Connected()</span>
                        case fromAgentV1.KeepaliveStatus_Closed:<span class="cov0" title="0">
                                s.logger.Infof("keepalive - stream closed - %v", res.GetErrorMessage())
                                return</span>
                        }
                }
        }
}
</pre>

		<pre class="file" id="file11" style="display: none">package service

import (
        "context"

        operationV1 "git.synology.inc/sast/access-system/server/agent/api/operation/v1"
        "git.synology.inc/sast/access-system/server/agent/internal/biz"
        "git.synology.inc/sast/access-system/server/agent/internal/conf"
        "git.synology.inc/sast/access-system/server/agent/internal/doorhandler"
        "github.com/go-kratos/kratos/v2/log"
        "google.golang.org/protobuf/types/known/emptypb"
)

type OperationService struct {
        operationV1.UnimplementedOperationServer

        operationUseCase biz.OperationUseCaseInterface
        c                *conf.Operation
        log              *log.Helper
}

func NewOperationService(c *conf.Operation, operationUseCase biz.OperationUseCaseInterface, logger log.Logger) *OperationService <span class="cov8" title="1">{
        return &amp;OperationService{
                operationUseCase: operationUseCase,
                c:                c,
                log:              log.NewHelper(logger),
        }
}</span>

func (s *OperationService) TestConnection(ctx context.Context, req *operationV1.TestConnectionRequest,
) (*emptypb.Empty, error) <span class="cov8" title="1">{

        controller := &amp;biz.Controller{
                Vendor:   req.GetVendor(),
                Model:    req.GetModel(),
                Address:  req.GetIp(),
                Account:  req.GetAccount(),
                Password: req.GetPassword(),
        }

        _, err := s.operationUseCase.TestConnection(ctx, s.c, controller)
        if err != nil </span><span class="cov0" title="0">{
                s.log.Errorf("test connection error: %s", err.Error())
                return nil, ErrorInternalError("test connection error: %s", err.Error())
        }</span>

        <span class="cov8" title="1">return &amp;emptypb.Empty{}, nil</span>
}

func (s *OperationService) AccessDoor(ctx context.Context, req *operationV1.AccessDoorRequest) (*emptypb.Empty, error) <span class="cov8" title="1">{
        err := s.operationUseCase.AccessDoor(ctx, s.c, req.GetControllerId(), req.GetDoorEntity())
        if err != nil </span><span class="cov0" title="0">{
                s.log.Errorf("access door error: %s", err.Error())
                return nil, ErrorInternalError("access door error: %s", err.Error())
        }</span>
        <span class="cov8" title="1">return &amp;emptypb.Empty{}, nil</span>
}

func (s *OperationService) UnlockDoor(ctx context.Context, req *operationV1.UnlockDoorRequest) (*emptypb.Empty, error) <span class="cov8" title="1">{
        err := s.operationUseCase.UnlockDoor(ctx, s.c, req.GetControllerId(), req.GetDoorEntity())
        if err != nil </span><span class="cov0" title="0">{
                s.log.Errorf("unlock door error: %s", err.Error())
                return nil, ErrorInternalError("unlock door error: %s", err.Error())
        }</span>
        <span class="cov8" title="1">return &amp;emptypb.Empty{}, nil</span>
}

func (s *OperationService) LockDoor(ctx context.Context, req *operationV1.LockDoorRequest) (*emptypb.Empty, error) <span class="cov8" title="1">{
        err := s.operationUseCase.LockDoor(ctx, s.c, req.GetControllerId(), req.GetDoorEntity())
        if err != nil </span><span class="cov0" title="0">{
                s.log.Errorf("lock door error: %s", err.Error())
                return nil, ErrorInternalError("lock door error: %s", err.Error())
        }</span>
        <span class="cov8" title="1">return &amp;emptypb.Empty{}, nil</span>
}

func (s *OperationService) ListAccessPoint(ctx context.Context, req *operationV1.ListAccessPointRequest,
) (*operationV1.ListAccessPointReply, error) <span class="cov8" title="1">{

        resp, err := s.operationUseCase.ListAccessPoint(ctx, s.c, req.GetControllerId())
        if err != nil </span><span class="cov0" title="0">{
                s.log.Errorf("list access point error: %s", err.Error())
                return nil, ErrorInternalError("list access point error: %s", err.Error())
        }</span>

        <span class="cov8" title="1">doors := make([]*operationV1.Door, 0, len(resp.Doors))
        idPoints := make([]*operationV1.IDPoint, 0, len(resp.IDPoints))

        for _, door := range resp.Doors </span><span class="cov8" title="1">{
                d := &amp;operationV1.Door{
                        Token:                 door.Token,
                        Name:                  door.Name,
                        Entity:                door.Entity,
                        Enabled:               door.Enabled,
                        IdPoints:              make([]*operationV1.IDPoint, 0, len(door.IDPoint)),
                        AuthenticationProfile: door.AuthenticationProfile,
                }

                for _, idPoint := range door.IDPoint </span><span class="cov0" title="0">{
                        d.IdPoints = append(d.IdPoints, &amp;operationV1.IDPoint{
                                Token: idPoint.Token,
                        })
                }</span>

                <span class="cov8" title="1">doors = append(doors, d)</span>
        }

        <span class="cov8" title="1">for _, idPoint := range resp.IDPoints </span><span class="cov8" title="1">{
                idPoints = append(idPoints, &amp;operationV1.IDPoint{
                        Token:     idPoint.Token,
                        Type:      idPoint.Type,
                        Direction: idPoint.Direction,
                })
        }</span>

        <span class="cov8" title="1">return &amp;operationV1.ListAccessPointReply{
                Doors:    doors,
                IdPoints: idPoints,
        }, nil</span>
}

func (s *OperationService) CreateUser(ctx context.Context, req *operationV1.CreateUserRequest) (*operationV1.CreateUserReply, error) <span class="cov0" title="0">{
        createUserRequest := &amp;doorhandler.CreateUserRequest{
                FirstName:   req.GetFirstName(),
                LastName:    req.GetLastName(),
                Description: req.GetDescription(),
        }

        resp, err := s.operationUseCase.CreateUser(ctx, s.c, req.GetControllerId(), createUserRequest)
        if err != nil </span><span class="cov0" title="0">{
                s.log.Errorf("create user error: %s", err.Error())
                return nil, ErrorInternalError("create user error: %s", err.Error())
        }</span>

        <span class="cov0" title="0">return &amp;operationV1.CreateUserReply{
                Token: resp.Token,
        }, nil</span>
}

func (s *OperationService) ListUser(ctx context.Context, req *operationV1.ListUserRequest) (*operationV1.ListUserReply, error) <span class="cov0" title="0">{
        resp, err := s.operationUseCase.ListUser(ctx, s.c, req.GetControllerId())
        if err != nil </span><span class="cov0" title="0">{
                s.log.Errorf("list user error: %s", err.Error())
                return nil, ErrorInternalError("list user error: %s", err.Error())
        }</span>

        <span class="cov0" title="0">users := make([]*operationV1.User, 0, len(resp.Users))
        for i := 0; i &lt; len(resp.Users); i++ </span><span class="cov0" title="0">{
                user := &amp;operationV1.User{
                        Token:       resp.Users[i].Token,
                        Name:        resp.Users[i].Name,
                        Description: resp.Users[i].Description,
                }
                users = append(users, user)
        }</span>

        <span class="cov0" title="0">return &amp;operationV1.ListUserReply{
                Users: users,
        }, nil</span>
}

func (s *OperationService) UpdateUser(ctx context.Context, req *operationV1.UpdateUserRequest) (*emptypb.Empty, error) <span class="cov0" title="0">{
        updateUserRequest := &amp;doorhandler.UpdateUserRequest{
                Token:       req.GetToken(),
                FirstName:   req.GetFirstName(),
                LastName:    req.GetLastName(),
                Description: req.GetDescription(),
        }

        err := s.operationUseCase.UpdateUser(ctx, s.c, req.GetControllerId(), updateUserRequest)
        if err != nil </span><span class="cov0" title="0">{
                s.log.Errorf("update user error: %s", err.Error())
                return nil, ErrorInternalError("update user error: %s", err.Error())
        }</span>

        <span class="cov0" title="0">return &amp;emptypb.Empty{}, nil</span>
}

func (s *OperationService) DeleteUser(ctx context.Context, req *operationV1.DeleteUserRequest) (*emptypb.Empty, error) <span class="cov0" title="0">{
        deleteUserRequest := &amp;doorhandler.DeleteUserRequest{
                Token: req.GetToken(),
        }

        err := s.operationUseCase.DeleteUser(ctx, s.c, req.GetControllerId(), deleteUserRequest)
        if err != nil </span><span class="cov0" title="0">{
                s.log.Errorf("delete user error: %s", err.Error())
                return nil, ErrorInternalError("delete user error: %s", err.Error())
        }</span>

        <span class="cov0" title="0">return &amp;emptypb.Empty{}, nil</span>
}

func (s *OperationService) CreateCredential(ctx context.Context, req *operationV1.CreateCredentialRequest,
) (*operationV1.CreateCredentialReply, error) <span class="cov0" title="0">{

        credentialAccessProfile := make([]*doorhandler.CredentialAccessProfile, 0, len(req.GetCredentialAccessProfile()))
        for _, profile := range req.GetCredentialAccessProfile() </span><span class="cov0" title="0">{
                credentialAccessProfile = append(credentialAccessProfile, &amp;doorhandler.CredentialAccessProfile{
                        ValidFrom:     profile.GetValidFrom(),
                        ValidTo:       profile.GetValidTo(),
                        AccessProfile: profile.GetAccessProfile(),
                })
        }</span>

        <span class="cov0" title="0">createCredentialRequest := &amp;doorhandler.CreateCredentialRequest{
                Credential: doorhandler.Credential{
                        UserToken:               req.GetUserToken(),
                        Description:             req.GetDescription(),
                        ValidFrom:               req.GetValidFrom(),
                        ValidTo:                 req.GetValidTo(),
                        Enabled:                 req.GetEnabled(),
                        Status:                  req.GetStatus(),
                        PIN:                     req.GetPin(),
                        FacilityCode:            req.GetFacilityCode(),
                        CardNr:                  req.GetCardNr(),
                        Card:                    req.GetCard(),
                        Attribute:               req.GetAttribute(),
                        CredentialAccessProfile: credentialAccessProfile,
                },
        }

        resp, err := s.operationUseCase.CreateCredential(ctx, s.c, req.GetControllerId(), createCredentialRequest)
        if err != nil </span><span class="cov0" title="0">{
                s.log.Errorf("create credential error: %s", err.Error())
                return nil, ErrorInternalError("create credential error: %s", err.Error())
        }</span>

        <span class="cov0" title="0">return &amp;operationV1.CreateCredentialReply{
                Token: resp.Token,
        }, nil</span>
}

func (s *OperationService) ListCredential(ctx context.Context, req *operationV1.ListCredentialRequest,
) (*operationV1.ListCredentialReply, error) <span class="cov0" title="0">{

        resp, err := s.operationUseCase.ListCredential(ctx, s.c, req.GetControllerId())

        if err != nil </span><span class="cov0" title="0">{
                s.log.Errorf("list credential error: %s", err.Error())
                return nil, ErrorInternalError("list credential error: %s", err.Error())
        }</span>

        <span class="cov0" title="0">credentials := make([]*operationV1.Credential, 0, len(resp.Credentials))
        for _, cred := range resp.Credentials </span><span class="cov0" title="0">{
                credential := &amp;operationV1.Credential{
                        Token:        cred.Token,
                        UserToken:    cred.UserToken,
                        Description:  cred.Description,
                        ValidFrom:    cred.ValidFrom,
                        ValidTo:      cred.ValidTo,
                        Enabled:      cred.Enabled,
                        Status:       cred.Status,
                        Pin:          cred.PIN,
                        FacilityCode: cred.FacilityCode,
                        CardNr:       cred.CardNr,
                        Card:         cred.Card,
                        Attribute:    cred.Attribute,
                }

                for _, profile := range cred.CredentialAccessProfile </span><span class="cov0" title="0">{
                        credentialAccessProfile := &amp;operationV1.CredentialAccessProfile{
                                ValidFrom:     profile.ValidFrom,
                                ValidTo:       profile.ValidTo,
                                AccessProfile: profile.AccessProfile,
                        }
                        credential.CredentialAccessProfile = append(credential.CredentialAccessProfile, credentialAccessProfile)
                }</span>

                <span class="cov0" title="0">credentials = append(credentials, credential)</span>
        }

        <span class="cov0" title="0">return &amp;operationV1.ListCredentialReply{
                Credentials: credentials,
        }, nil</span>
}

func (s *OperationService) UpdateCredential(ctx context.Context, req *operationV1.UpdateCredentialRequest,
) (*emptypb.Empty, error) <span class="cov0" title="0">{

        credentialAccessProfile := make([]*doorhandler.CredentialAccessProfile, 0, len(req.GetCredentialAccessProfile()))
        for _, profile := range req.GetCredentialAccessProfile() </span><span class="cov0" title="0">{
                credentialAccessProfile = append(credentialAccessProfile, &amp;doorhandler.CredentialAccessProfile{
                        ValidFrom:     profile.GetValidFrom(),
                        ValidTo:       profile.GetValidTo(),
                        AccessProfile: profile.GetAccessProfile(),
                })
        }</span>

        <span class="cov0" title="0">updateCredentialRequest := &amp;doorhandler.UpdateCredentialRequest{
                Credential: doorhandler.Credential{
                        Token:                   req.GetToken(),
                        UserToken:               req.GetUserToken(),
                        Description:             req.GetDescription(),
                        ValidFrom:               req.GetValidFrom(),
                        ValidTo:                 req.GetValidTo(),
                        Enabled:                 req.GetEnabled(),
                        Status:                  req.GetStatus(),
                        PIN:                     req.GetPin(),
                        FacilityCode:            req.GetFacilityCode(),
                        CardNr:                  req.GetCardNr(),
                        Card:                    req.GetCard(),
                        Attribute:               req.GetAttribute(),
                        CredentialAccessProfile: credentialAccessProfile,
                },
        }

        err := s.operationUseCase.UpdateCredential(ctx, s.c, req.GetControllerId(), updateCredentialRequest)
        if err != nil </span><span class="cov0" title="0">{
                s.log.Errorf("update credential error: %s", err.Error())
                return nil, ErrorInternalError("update credential error: %s", err.Error())
        }</span>

        <span class="cov0" title="0">return &amp;emptypb.Empty{}, nil</span>
}

func (s *OperationService) DeleteCredential(ctx context.Context, req *operationV1.DeleteCredentialRequest,
) (*emptypb.Empty, error) <span class="cov0" title="0">{

        deleteCredentialRequest := &amp;doorhandler.DeleteCredentialRequest{
                Token: req.GetToken(),
        }

        err := s.operationUseCase.DeleteCredential(ctx, s.c, req.GetControllerId(), deleteCredentialRequest)
        if err != nil </span><span class="cov0" title="0">{
                s.log.Errorf("delete credential error: %s", err.Error())
                return nil, ErrorInternalError("delete credential error: %s", err.Error())
        }</span>

        <span class="cov0" title="0">return &amp;emptypb.Empty{}, nil</span>
}

func (s *OperationService) CreateAccessProfile(ctx context.Context, req *operationV1.CreateAccessProfileRequest,
) (*operationV1.CreateAccessProfileReply, error) <span class="cov0" title="0">{

        accessPolicy := make([]*doorhandler.AccessPolicy, 0, len(req.GetAccessPolicy()))
        for _, policy := range req.GetAccessPolicy() </span><span class="cov0" title="0">{
                accessPolicy = append(accessPolicy, &amp;doorhandler.AccessPolicy{
                        AccessPoint: policy.GetAccessPoint(),
                })
        }</span>

        <span class="cov0" title="0">createAccessProfileRequest := &amp;doorhandler.CreateAccessProfileRequest{
                AccessProfile: doorhandler.AccessProfile{
                        Description:  req.GetDescription(),
                        Name:         req.GetName(),
                        Enabled:      req.GetEnabled(),
                        ValidFrom:    req.GetValidFrom(),
                        ValidTo:      req.GetValidTo(),
                        Schedule:     req.GetSchedule(),
                        AccessPolicy: accessPolicy,
                },
        }

        resp, err := s.operationUseCase.CreateAccessProfile(ctx, s.c, req.GetControllerId(), createAccessProfileRequest)
        if err != nil </span><span class="cov0" title="0">{
                s.log.Errorf("create access profile error: %s", err.Error())
                return nil, ErrorInternalError("create access profile error: %s", err.Error())
        }</span>

        <span class="cov0" title="0">return &amp;operationV1.CreateAccessProfileReply{
                Token: resp.Token,
        }, nil</span>
}

func (s *OperationService) ListAccessProfile(ctx context.Context, req *operationV1.ListAccessProfileRequest,
) (*operationV1.ListAccessProfileReply, error) <span class="cov0" title="0">{

        resp, err := s.operationUseCase.ListAccessProfile(ctx, s.c, req.GetControllerId())

        if err != nil </span><span class="cov0" title="0">{
                s.log.Errorf("list access profile error: %s", err.Error())
                return nil, ErrorInternalError("list access profile error: %s", err.Error())
        }</span>

        <span class="cov0" title="0">accessProfiles := make([]*operationV1.AccessProfile, 0, len(resp.AccessProfiles))
        for _, profile := range resp.AccessProfiles </span><span class="cov0" title="0">{
                accessProfile := &amp;operationV1.AccessProfile{
                        Token:       profile.Token,
                        Description: profile.Description,
                        Name:        profile.Name,
                        Enabled:     profile.Enabled,
                        ValidFrom:   profile.ValidFrom,
                        ValidTo:     profile.ValidTo,
                        Schedule:    profile.Schedule,
                }

                for _, policy := range profile.AccessPolicy </span><span class="cov0" title="0">{
                        accessPolicy := &amp;operationV1.AccessPolicy{
                                AccessPoint: policy.AccessPoint,
                        }
                        accessProfile.AccessPolicy = append(accessProfile.AccessPolicy, accessPolicy)
                }</span>
                <span class="cov0" title="0">accessProfiles = append(accessProfiles, accessProfile)</span>
        }

        <span class="cov0" title="0">return &amp;operationV1.ListAccessProfileReply{
                AccessProfiles: accessProfiles,
        }, nil</span>
}

func (s *OperationService) UpdateAccessProfile(ctx context.Context, req *operationV1.UpdateAccessProfileRequest,
) (*emptypb.Empty, error) <span class="cov0" title="0">{

        accessPolicy := make([]*doorhandler.AccessPolicy, 0, len(req.GetAccessPolicy()))
        for _, policy := range req.GetAccessPolicy() </span><span class="cov0" title="0">{
                accessPolicy = append(accessPolicy, &amp;doorhandler.AccessPolicy{
                        AccessPoint: policy.GetAccessPoint(),
                })
        }</span>

        <span class="cov0" title="0">updateAccessProfileRequest := &amp;doorhandler.UpdateAccessProfileRequest{
                AccessProfile: doorhandler.AccessProfile{
                        Token:        req.GetToken(),
                        Description:  req.GetDescription(),
                        Name:         req.GetName(),
                        Enabled:      req.GetEnabled(),
                        ValidFrom:    req.GetValidFrom(),
                        ValidTo:      req.GetValidTo(),
                        Schedule:     req.GetSchedule(),
                        AccessPolicy: accessPolicy,
                },
        }

        err := s.operationUseCase.UpdateAccessProfile(ctx, s.c, req.GetControllerId(), updateAccessProfileRequest)
        if err != nil </span><span class="cov0" title="0">{
                s.log.Errorf("update access profile error: %s", err.Error())
                return nil, ErrorInternalError("update access profile error: %s", err.Error())
        }</span>

        <span class="cov0" title="0">return &amp;emptypb.Empty{}, nil</span>
}

func (s *OperationService) DeleteAccessProfile(ctx context.Context, req *operationV1.DeleteAccessProfileRequest,
) (*emptypb.Empty, error) <span class="cov0" title="0">{

        deleteAccessProfileRequest := &amp;doorhandler.DeleteAccessProfileRequest{
                Token: req.GetToken(),
        }

        err := s.operationUseCase.DeleteAccessProfile(ctx, s.c, req.GetControllerId(), deleteAccessProfileRequest)
        if err != nil </span><span class="cov0" title="0">{
                s.log.Errorf("delete access profile error: %s", err.Error())
                return nil, ErrorInternalError("delete access profile error: %s", err.Error())
        }</span>

        <span class="cov0" title="0">return &amp;emptypb.Empty{}, nil</span>
}

func (s *OperationService) GetReaderLastCard(ctx context.Context, req *operationV1.GetReaderLastCardRequest,
) (*operationV1.GetReaderLastCardReply, error) <span class="cov0" title="0">{

        getReaderLastCardRequest := &amp;doorhandler.GetReaderLastCardRequest{
                Token: req.GetReaderToken(),
        }

        resp, err := s.operationUseCase.GetReaderLastCard(ctx, s.c, req.GetControllerId(), getReaderLastCardRequest)
        if err != nil </span><span class="cov0" title="0">{
                s.log.Errorf("get reader last card error: %s", err.Error())
                return nil, ErrorInternalError("get reader last card error: %s", err.Error())
        }</span>

        <span class="cov0" title="0">return &amp;operationV1.GetReaderLastCardReply{
                Card:         resp.Card,
                CardNumber:   resp.CardNumber,
                FacilityCode: resp.FacilityCode,
        }, nil</span>
}
</pre>

		<pre class="file" id="file12" style="display: none">package service

import (
        "context"

        "git.synology.inc/sast/3rd-party/goupnp.git"
        pb "git.synology.inc/sast/access-system/server/agent/api/upnp/v1"
        "git.synology.inc/sast/access-system/server/agent/internal/biz"
        "git.synology.inc/sast/access-system/server/agent/internal/conf"
        "git.synology.inc/sast/access-system/server/agent/internal/doorhandler"
        "github.com/go-kratos/kratos/v2/log"
)

type UpnpService struct {
        pb.UnimplementedUpnpServer

        upnpUseCase *biz.UpnpUseCase
        c           *conf.Upnp
        log         *log.Helper
}

func NewUpnpService(c *conf.Upnp, upnpUseCase *biz.UpnpUseCase, logger log.Logger) *UpnpService <span class="cov0" title="0">{
        return &amp;UpnpService{
                upnpUseCase: upnpUseCase,
                c:           c,
                log:         log.NewHelper(logger),
        }
}</span>

func (s *UpnpService) Search(_ *pb.UpnpSearchRequest, conn pb.Upnp_SearchServer) error <span class="cov0" title="0">{
        streamCtx := conn.Context()

        deviceChan := make(chan goupnp.MaybeRootDevice)
        defer close(deviceChan)

        ctx, cancel := context.WithTimeout(context.Background(), s.c.GetTimeout().AsDuration())
        defer cancel()

        go s.upnpUseCase.Search(ctx, deviceChan)

        for </span><span class="cov0" title="0">{
                select </span>{
                case dev, ok := &lt;-deviceChan:<span class="cov0" title="0">
                        if !ok </span><span class="cov0" title="0">{
                                return nil
                        }</span>

                        <span class="cov0" title="0">if dev.Err != nil </span><span class="cov0" title="0">{
                                s.log.Errorf("Error discovering devices: %v", dev.Err.Error())
                                continue</span>
                        }

                        <span class="cov0" title="0">if dev.Root == nil </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        <span class="cov0" title="0">vendor, model := doorhandler.ParseModelName(dev.Root.Device.ModelName)
                        _ = conn.Send(&amp;pb.UpnpSearchReply{
                                Vendor: vendor,
                                Model:  model,
                                Ip:     dev.Root.IP,
                        })</span>
                case &lt;-streamCtx.Done():<span class="cov0" title="0">
                        return nil</span>
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return nil</span>
                }
        }
}
</pre>

		<pre class="file" id="file13" style="display: none">package helper

import (
        "encoding/json"
)

func Convert[Source any, Target any](s *Source, t *Target) error <span class="cov8" title="1">{
        // JSON marshal
        byteString, err := json.Marshal(s)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // JSON unmarshal
        <span class="cov8" title="1">err = json.Unmarshal(byteString, t)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>

		<pre class="file" id="file14" style="display: none">package service

import (
        "context"

        agentV1 "git.synology.inc/sast/access-system/server/gateway/api/agent/v1"
        "git.synology.inc/sast/access-system/server/gateway/internal/biz"
        "git.synology.inc/sast/access-system/server/gateway/internal/conf"
)

type AgentService struct {
        agentV1.UnsafeAgentServer

        c                   *conf.Server
        agentUseCase        biz.AgentUseCaseInterface
        forwardAgentUseCase biz.ForwardAgentUseCaseInterface
}

func NewAgentService(c *conf.Server, agentUseCase biz.AgentUseCaseInterface,
        forwardAgentUseCase biz.ForwardAgentUseCaseInterface) *AgentService <span class="cov8" title="1">{

        return &amp;AgentService{
                c:                   c,
                agentUseCase:        agentUseCase,
                forwardAgentUseCase: forwardAgentUseCase,
        }
}</span>

func (s *AgentService) PingAgent(ctx context.Context, req *agentV1.PingAgentRequest) (*agentV1.PingAgentReply, error) <span class="cov8" title="1">{
        ctx, cancel := context.WithTimeout(ctx, s.c.GetGrpcForward().GetTimeout().AsDuration())
        defer cancel()

        // TODO - pinkeyu - get agent for validation or do something
        // _, err := s.agentUseCase.GetAgent(ctx, getAgent)
        // if err != nil {
        //        return nil, err

        r := &amp;biz.PingAgentRequest{
                AgentID: req.GetAgentId(),
        }

        res, err := s.forwardAgentUseCase.PingAgent(ctx, req.GetAgentId(), r)
        if err != nil </span><span class="cov0" title="0">{
                return nil, handleForwardError(err)
        }</span>

        <span class="cov8" title="1">return &amp;agentV1.PingAgentReply{
                Agent: res.Agent.ToPbAgent(),
        }, nil</span>
}
</pre>

		<pre class="file" id="file15" style="display: none">package service

import (
        "context"

        controllerV1 "git.synology.inc/sast/access-system/server/gateway/api/controller/v1"
        "git.synology.inc/sast/access-system/server/gateway/helper"
        "git.synology.inc/sast/access-system/server/gateway/internal/biz"
        "git.synology.inc/sast/access-system/server/gateway/internal/conf"
        "google.golang.org/protobuf/types/known/emptypb"
)

type ControllerService struct {
        controllerV1.UnsafeControllerServer

        c                        *conf.Server
        forwardControllerUseCase biz.ForwardControllerUseCaseInterface
}

func NewControllerService(c *conf.Server, forwardControllerUseCase biz.ForwardControllerUseCaseInterface) *ControllerService <span class="cov8" title="1">{
        return &amp;ControllerService{
                c:                        c,
                forwardControllerUseCase: forwardControllerUseCase,
        }
}</span>

func (s *ControllerService) AddController(ctx context.Context, req *controllerV1.AddControllerRequest) (
        *controllerV1.AddControllerReply, error) <span class="cov8" title="1">{

        ctx, cancel := context.WithTimeout(ctx, s.c.GetGrpcForward().GetTimeout().AsDuration())
        defer cancel()

        // Arrange
        r := &amp;biz.AddControllerRequest{}
        err := helper.Convert(req, r)
        if err != nil </span><span class="cov0" title="0">{
                return nil, ErrorConvertRequest("%s", err.Error())
        }</span>

        // Act
        <span class="cov8" title="1">res, errFromForward := s.forwardControllerUseCase.AddController(ctx, req.GetAgentId(), r)
        if errFromForward != nil </span><span class="cov0" title="0">{
                return nil, handleForwardError(errFromForward)
        }</span>

        <span class="cov8" title="1">return &amp;controllerV1.AddControllerReply{
                Id: res.ID,
        }, nil</span>
}

func (s *ControllerService) UpdateController(ctx context.Context, req *controllerV1.UpdateControllerRequest) (
        *emptypb.Empty, error) <span class="cov8" title="1">{

        ctx, cancel := context.WithTimeout(ctx, s.c.GetGrpcForward().GetTimeout().AsDuration())
        defer cancel()

        // Arrange
        r := &amp;biz.UpdateControllerRequest{}
        err := helper.Convert(req, r)
        if err != nil </span><span class="cov0" title="0">{
                return nil, ErrorConvertRequest("%s", err.Error())
        }</span>

        // Act
        <span class="cov8" title="1">_, errFromForward := s.forwardControllerUseCase.UpdateController(ctx, req.GetAgentId(), r)
        if errFromForward != nil </span><span class="cov0" title="0">{
                return nil, handleForwardError(errFromForward)
        }</span>

        <span class="cov8" title="1">return &amp;emptypb.Empty{}, nil</span>
}

func (s *ControllerService) DeleteController(ctx context.Context, req *controllerV1.DeleteControllerRequest) (
        *emptypb.Empty, error) <span class="cov8" title="1">{

        ctx, cancel := context.WithTimeout(ctx, s.c.GetGrpcForward().GetTimeout().AsDuration())
        defer cancel()

        // Arrange
        r := &amp;biz.DeleteControllerRequest{}
        err := helper.Convert(req, r)
        if err != nil </span><span class="cov0" title="0">{
                return nil, ErrorConvertRequest("%s", err.Error())
        }</span>

        // Act
        <span class="cov8" title="1">_, errFromForward := s.forwardControllerUseCase.DeleteController(ctx, req.GetAgentId(), r)
        if errFromForward != nil </span><span class="cov0" title="0">{
                return nil, handleForwardError(errFromForward)
        }</span>

        <span class="cov8" title="1">return &amp;emptypb.Empty{}, nil</span>
}

func (s *ControllerService) ListController(ctx context.Context, req *controllerV1.ListControllerRequest,
) (*controllerV1.ListControllerReply, error) <span class="cov8" title="1">{

        ctx, cancel := context.WithTimeout(ctx, s.c.GetGrpcForward().GetTimeout().AsDuration())
        defer cancel()

        // Arrange
        r := &amp;biz.ListControllerRequest{}
        err := helper.Convert(req, r)
        if err != nil </span><span class="cov0" title="0">{
                return nil, ErrorConvertRequest("%s", err.Error())
        }</span>

        // Act
        <span class="cov8" title="1">res, errFromForward := s.forwardControllerUseCase.ListController(ctx, req.GetAgentId(), r)
        if errFromForward != nil </span><span class="cov0" title="0">{
                return nil, handleForwardError(errFromForward)
        }</span>

        // Convert
        <span class="cov8" title="1">reply := &amp;controllerV1.ListControllerReply{}
        err = helper.Convert(res, reply)
        if err != nil </span><span class="cov0" title="0">{
                return nil, ErrorConvertResponse("%s", err.Error())
        }</span>

        <span class="cov8" title="1">return reply, nil</span>
}

func (s *ControllerService) GetController(ctx context.Context, req *controllerV1.GetControllerRequest,
) (*controllerV1.GetControllerReply, error) <span class="cov8" title="1">{

        ctx, cancel := context.WithTimeout(ctx, s.c.GetGrpcForward().GetTimeout().AsDuration())
        defer cancel()

        // Arrange
        r := &amp;biz.GetControllerRequest{}
        err := helper.Convert(req, r)
        if err != nil </span><span class="cov0" title="0">{
                return nil, ErrorConvertRequest("%s", err.Error())
        }</span>

        // Act
        <span class="cov8" title="1">res, errFromForward := s.forwardControllerUseCase.GetController(ctx, req.GetAgentId(), r)
        if errFromForward != nil </span><span class="cov0" title="0">{
                return nil, handleForwardError(errFromForward)
        }</span>

        // Convert
        <span class="cov8" title="1">reply := &amp;controllerV1.GetControllerReply{}
        err = helper.Convert(res, reply)
        if err != nil </span><span class="cov0" title="0">{
                return nil, ErrorConvertResponse("%s", err.Error())
        }</span>

        <span class="cov8" title="1">return reply, nil</span>
}
</pre>

		<pre class="file" id="file16" style="display: none">package service

import (
        grpcServerSideRequest "git.synology.inc/sast/access-system/grpc-server-side-request.git"
        forwardAgentV1 "git.synology.inc/sast/access-system/server/gateway/api/forward_agent/v1"
)

type ForwardAgentService struct {
        forwardAgentV1.UnimplementedForwardAgentServer

        mappingService *grpcServerSideRequest.MappingService
}

func NewForwardAgentService(mappingService *grpcServerSideRequest.MappingService) *ForwardAgentService <span class="cov0" title="0">{
        return &amp;ForwardAgentService{
                mappingService: mappingService,
        }
}</span>

func (s *ForwardAgentService) PingAgent(stream forwardAgentV1.ForwardAgent_PingAgentServer) error <span class="cov0" title="0">{
        // Arrange
        err := grpcServerSideRequest.NewServer[
                forwardAgentV1.PingAgentRequest,
                forwardAgentV1.PingAgentReply,
        ](s.mappingService, stream)
        if err != nil </span><span class="cov0" title="0">{
                return ErrorInternalError("NewServer: %s", err.Error())
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>

		<pre class="file" id="file17" style="display: none">package service

import (
        grpcServerSideRequest "git.synology.inc/sast/access-system/grpc-server-side-request.git"
        forwardControllerV1 "git.synology.inc/sast/access-system/server/gateway/api/forward_controller/v1"
)

type ForwardControllerService struct {
        forwardControllerV1.UnimplementedForwardControllerServer

        mappingService *grpcServerSideRequest.MappingService
}

func NewForwardControllerService(mappingService *grpcServerSideRequest.MappingService) *ForwardControllerService <span class="cov0" title="0">{
        return &amp;ForwardControllerService{
                mappingService: mappingService,
        }
}</span>

func (s *ForwardControllerService) AddController(stream forwardControllerV1.ForwardController_AddControllerServer) error <span class="cov0" title="0">{
        // Arrange
        err := grpcServerSideRequest.NewServer[
                forwardControllerV1.AddControllerRequest,
                forwardControllerV1.AddControllerReply,
        ](s.mappingService, stream)
        if err != nil </span><span class="cov0" title="0">{
                return ErrorInternalError("NewServer: %s", err.Error())
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (s *ForwardControllerService) UpdateController(stream forwardControllerV1.ForwardController_UpdateControllerServer) error <span class="cov0" title="0">{
        // Arrange
        err := grpcServerSideRequest.NewServer[
                forwardControllerV1.UpdateControllerRequest,
                forwardControllerV1.UpdateControllerReply,
        ](s.mappingService, stream)
        if err != nil </span><span class="cov0" title="0">{
                return ErrorInternalError("NewServer: %s", err.Error())
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (s *ForwardControllerService) DeleteController(stream forwardControllerV1.ForwardController_DeleteControllerServer) error <span class="cov0" title="0">{
        // Arrange
        err := grpcServerSideRequest.NewServer[
                forwardControllerV1.DeleteControllerRequest,
                forwardControllerV1.DeleteControllerReply,
        ](s.mappingService, stream)
        if err != nil </span><span class="cov0" title="0">{
                return ErrorInternalError("NewServer: %s", err.Error())
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (s *ForwardControllerService) ListController(stream forwardControllerV1.ForwardController_ListControllerServer) error <span class="cov0" title="0">{
        // Arrange
        err := grpcServerSideRequest.NewServer[
                forwardControllerV1.ListControllerRequest,
                forwardControllerV1.ListControllerReply,
        ](s.mappingService, stream)
        if err != nil </span><span class="cov0" title="0">{
                return ErrorInternalError("NewServer: %s", err.Error())
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (s *ForwardControllerService) GetController(stream forwardControllerV1.ForwardController_GetControllerServer) error <span class="cov0" title="0">{
        // Arrange
        err := grpcServerSideRequest.NewServer[
                forwardControllerV1.GetControllerRequest,
                forwardControllerV1.GetControllerReply,
        ](s.mappingService, stream)
        if err != nil </span><span class="cov0" title="0">{
                return ErrorInternalError("NewServer: %s", err.Error())
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>

		<pre class="file" id="file18" style="display: none">package service

import (
        grpcServerSideRequest "git.synology.inc/sast/access-system/grpc-server-side-request.git"
        forwardOperationV1 "git.synology.inc/sast/access-system/server/gateway/api/forward_operation/v1"
)

type ForwardOperationService struct {
        forwardOperationV1.UnimplementedForwardOperationServer

        mappingService *grpcServerSideRequest.MappingService
}

func NewForwardOperationService(mappingService *grpcServerSideRequest.MappingService) *ForwardOperationService <span class="cov0" title="0">{
        return &amp;ForwardOperationService{
                mappingService: mappingService,
        }
}</span>

func (s *ForwardOperationService) TestConnection(stream forwardOperationV1.ForwardOperation_TestConnectionServer) error <span class="cov0" title="0">{
        // Arrange
        err := grpcServerSideRequest.NewServer[
                forwardOperationV1.TestConnectionRequest,
                forwardOperationV1.TestConnectionReply,
        ](s.mappingService, stream)
        if err != nil </span><span class="cov0" title="0">{
                return ErrorInternalError("NewServer: %s", err.Error())
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (s *ForwardOperationService) AccessDoor(stream forwardOperationV1.ForwardOperation_AccessDoorServer) error <span class="cov0" title="0">{
        // Arrange
        err := grpcServerSideRequest.NewServer[
                forwardOperationV1.AccessDoorRequest,
                forwardOperationV1.AccessDoorReply,
        ](s.mappingService, stream)
        if err != nil </span><span class="cov0" title="0">{
                return ErrorInternalError("NewServer: %s", err.Error())
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (s *ForwardOperationService) UnlockDoor(stream forwardOperationV1.ForwardOperation_UnlockDoorServer) error <span class="cov0" title="0">{
        // Arrange
        err := grpcServerSideRequest.NewServer[
                forwardOperationV1.UnlockDoorRequest,
                forwardOperationV1.UnlockDoorReply,
        ](s.mappingService, stream)
        if err != nil </span><span class="cov0" title="0">{
                return ErrorInternalError("NewServer: %s", err.Error())
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (s *ForwardOperationService) LockDoor(stream forwardOperationV1.ForwardOperation_LockDoorServer) error <span class="cov0" title="0">{
        // Arrange
        err := grpcServerSideRequest.NewServer[
                forwardOperationV1.LockDoorRequest,
                forwardOperationV1.LockDoorReply,
        ](s.mappingService, stream)
        if err != nil </span><span class="cov0" title="0">{
                return ErrorInternalError("NewServer: %s", err.Error())
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (s *ForwardOperationService) ListAccessPoints(stream forwardOperationV1.ForwardOperation_ListAccessPointsServer) error <span class="cov0" title="0">{
        // Arrange
        err := grpcServerSideRequest.NewServer[
                forwardOperationV1.ListAccessPointsRequest,
                forwardOperationV1.ListAccessPointsReply,
        ](s.mappingService, stream)
        if err != nil </span><span class="cov0" title="0">{
                return ErrorInternalError("NewServer: %s", err.Error())
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (s *ForwardOperationService) GetReaderLastCard(stream forwardOperationV1.ForwardOperation_GetReaderLastCardServer) error <span class="cov0" title="0">{
        // Arrange
        err := grpcServerSideRequest.NewServer[
                forwardOperationV1.GetReaderLastCardRequest,
                forwardOperationV1.GetReaderLastCardReply,
        ](s.mappingService, stream)
        if err != nil </span><span class="cov0" title="0">{
                return ErrorInternalError("NewServer: %s", err.Error())
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>

		<pre class="file" id="file19" style="display: none">package service

import (
        grpcServerSideRequest "git.synology.inc/sast/access-system/grpc-server-side-request.git"
        forwardSyncV1 "git.synology.inc/sast/access-system/server/gateway/api/forward_sync/v1"
)

type ForwardSyncService struct {
        forwardSyncV1.UnimplementedForwardSyncServer

        mappingService *grpcServerSideRequest.MappingService
}

func NewForwardSyncService(mappingService *grpcServerSideRequest.MappingService) *ForwardSyncService <span class="cov0" title="0">{
        return &amp;ForwardSyncService{
                mappingService: mappingService,
        }
}</span>

func (s *ForwardSyncService) SyncAddAsyncTask(stream forwardSyncV1.ForwardSync_SyncAddAsyncTaskServer) error <span class="cov0" title="0">{
        // Arrange
        err := grpcServerSideRequest.NewServer[
                forwardSyncV1.SyncAddAsyncTaskRequest,
                forwardSyncV1.SyncAddAsyncTaskReply,
        ](s.mappingService, stream)
        if err != nil </span><span class="cov0" title="0">{
                return ErrorInternalError("NewServer: %s", err.Error())
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>

		<pre class="file" id="file20" style="display: none">package service

import (
        grpcServerSideRequest "git.synology.inc/sast/access-system/grpc-server-side-request.git"
        forwardUpnpV1 "git.synology.inc/sast/access-system/server/gateway/api/forward_upnp/v1"
)

type ForwardUpnpService struct {
        forwardUpnpV1.UnimplementedForwardUpnpServer

        mappingService *grpcServerSideRequest.MappingService
}

func NewForwardUpnpService(mappingService *grpcServerSideRequest.MappingService) *ForwardUpnpService <span class="cov0" title="0">{
        return &amp;ForwardUpnpService{
                mappingService: mappingService,
        }
}</span>

func (s *ForwardUpnpService) Search(stream forwardUpnpV1.ForwardUpnp_SearchServer) error <span class="cov0" title="0">{
        // Arrange
        err := grpcServerSideRequest.NewServer[
                forwardUpnpV1.UpnpSearchRequest,
                forwardUpnpV1.UpnpSearchReply,
        ](s.mappingService, stream)
        if err != nil </span><span class="cov0" title="0">{
                return ErrorInternalError("NewServer: %s", err.Error())
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>

		<pre class="file" id="file21" style="display: none">package service

import (
        "context"
        fmt "fmt"
        "io"

        fromAgentV1 "git.synology.inc/sast/access-system/server/gateway/api/from_agent/v1"
        "git.synology.inc/sast/access-system/server/gateway/internal/biz"
        "git.synology.inc/sast/access-system/server/gateway/internal/conf"
        "github.com/go-kratos/kratos/v2/log"
)

type FromAgentDynamicService struct {
        fromAgentV1.UnimplementedFromAgentServer

        discoveryUseCase *biz.DiscoveryUseCase
        externalConfig   *conf.External
        responseChan     chan *fromAgentV1.KeepaliveReply
        logger           *log.Helper
}

func NewFromAgentDynamicService(discoveryUseCase *biz.DiscoveryUseCase, ce *conf.External, logger log.Logger) *FromAgentDynamicService <span class="cov0" title="0">{
        return &amp;FromAgentDynamicService{
                discoveryUseCase: discoveryUseCase,
                externalConfig:   ce,
                responseChan:     make(chan *fromAgentV1.KeepaliveReply),
                logger:           log.NewHelper(logger),
        }
}</span>

func (s *FromAgentDynamicService) Keepalive(stream fromAgentV1.FromAgent_KeepaliveServer) error <span class="cov0" title="0">{
        ctx, ctxCancel := context.WithCancel(stream.Context())
        defer ctxCancel()

        // Send terminate to agent
        go func() </span><span class="cov0" title="0">{
                for </span><span class="cov0" title="0">{
                        select </span>{
                        case &lt;-ctx.Done():<span class="cov0" title="0">
                                s.logger.Infof("status channel closed")
                                response := &amp;fromAgentV1.KeepaliveReply{
                                        Status:       fromAgentV1.KeepaliveStatus_Closed,
                                        ErrorMessage: "keepalive service is closed",
                                }
                                if err := stream.Send(response); err != nil </span><span class="cov0" title="0">{
                                        s.logger.Infof("keepalive - failed to send request: %s", err.Error())
                                        return
                                }</span>
                        case res, ok := &lt;-s.responseChan:<span class="cov0" title="0">
                                s.logger.Infof("status channel received")
                                if !ok </span><span class="cov0" title="0">{
                                        s.logger.Infof("status channel closed")
                                        ctxCancel()
                                        return
                                }</span>
                                <span class="cov0" title="0">if err := stream.Send(res); err != nil </span><span class="cov0" title="0">{
                                        s.logger.Infof("keepalive - failed to send request: %s", err.Error())
                                        return
                                }</span>
                        }
                }
        }()

        <span class="cov0" title="0">agentID, agentVersion, err := retrieveAgentInfo(stream.Context(), s.logger)
        if err != nil </span><span class="cov0" title="0">{
                errMessage := fmt.Sprintf("keepalive - failed to get agent info: %s", err.Error())
                s.responseChan &lt;- &amp;fromAgentV1.KeepaliveReply{
                        Status:       fromAgentV1.KeepaliveStatus_Closed,
                        ErrorMessage: errMessage,
                }
                s.logger.Errorf(errMessage)
                return err
        }</span>

        <span class="cov0" title="0">s.logger.Infof("keepalive stream opened for agent %s version %s", agentID, agentVersion)

        err = s.discoveryUseCase.Set(agentID, agentVersion)
        if err != nil </span><span class="cov0" title="0">{
                errMessage := fmt.Sprintf("failed to set agent info: %s", err.Error())
                s.responseChan &lt;- &amp;fromAgentV1.KeepaliveReply{
                        Status:       fromAgentV1.KeepaliveStatus_Closed,
                        ErrorMessage: errMessage,
                }
                s.logger.Errorf(errMessage)
                return ErrorCanNotSetDiscoveryRecord("%s", errMessage)
        }</span>

        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                err := s.discoveryUseCase.Remove(agentID, agentVersion)
                if err != nil </span><span class="cov0" title="0">{
                        s.logger.Errorf("failed to remove agent info: %s", err.Error())
                }</span>
        }()

        // Send connected
        <span class="cov0" title="0">s.logger.Debugf("send status to keep alive status chane: %s", agentID)
        s.responseChan &lt;- &amp;fromAgentV1.KeepaliveReply{
                Status: fromAgentV1.KeepaliveStatus_Connected,
        }

        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return nil</span>
                default:<span class="cov0" title="0">
                        _, err := stream.Recv()
                        if err == io.EOF </span><span class="cov0" title="0">{
                                s.logger.Infof("keepalive stream closed due to EOF for agent %s version %s", agentID, agentVersion)
                                return nil
                        }</span>

                        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                                errMessage := fmt.Sprintf("failed to receive keepalive request: %s for agent %s version %s", err.Error(), agentID, agentVersion)
                                s.responseChan &lt;- &amp;fromAgentV1.KeepaliveReply{
                                        Status:       fromAgentV1.KeepaliveStatus_Closed,
                                        ErrorMessage: errMessage,
                                }
                                s.logger.Errorf(errMessage)
                                return err
                        }</span>

                        <span class="cov0" title="0">err = s.discoveryUseCase.Keepalive(agentID, agentVersion)
                        if err != nil </span><span class="cov0" title="0">{
                                s.logger.Errorf("failed to keepalive: %s for agent %s version %s", err.Error(), agentID, agentVersion)
                        }</span>
                }
        }
}
</pre>

		<pre class="file" id="file22" style="display: none">package service

import (
        "context"
        "fmt"
        "io"

        fromAgentV1 "git.synology.inc/sast/access-system/server/gateway/api/from_agent/v1"
        "git.synology.inc/sast/access-system/server/gateway/internal/biz"
        "git.synology.inc/sast/access-system/server/gateway/internal/conf"
        grpcConn "git.synology.inc/sast/access-system/server/internal/grpc"
        internalAgentV1 "git.synology.inc/sast/access-system/server/web/api/internal_agent/v1"
        "github.com/go-kratos/kratos/v2/log"
        "google.golang.org/grpc/metadata"
)

type FromAgentStaticService struct {
        fromAgentV1.UnimplementedFromAgentServer

        internalAgentClient internalAgentV1.InternalAgentClient
        responseChan        chan *fromAgentV1.KeepaliveReply
        logger              *log.Helper
}

func NewFromAgentStaticService(_ *biz.DiscoveryUseCase, _ *conf.External, logger log.Logger) *FromAgentStaticService <span class="cov0" title="0">{
        return &amp;FromAgentStaticService{
                responseChan: make(chan *fromAgentV1.KeepaliveReply),
                logger:       log.NewHelper(logger),
        }
}</span>

func (s *FromAgentStaticService) SetClient(client internalAgentV1.InternalAgentClient) <span class="cov0" title="0">{
        s.internalAgentClient = client
}</span>

func (s *FromAgentStaticService) Keepalive(stream fromAgentV1.FromAgent_KeepaliveServer) error <span class="cov0" title="0">{
        ctx, ctxCancel := context.WithCancel(stream.Context())
        defer ctxCancel()

        // Send terminate to agent
        go func() </span><span class="cov0" title="0">{
                for </span><span class="cov0" title="0">{
                        select </span>{
                        case &lt;-ctx.Done():<span class="cov0" title="0">
                                s.logger.Infof("status channel closed")
                                response := &amp;fromAgentV1.KeepaliveReply{
                                        Status:       fromAgentV1.KeepaliveStatus_Closed,
                                        ErrorMessage: "keepalive service is closed",
                                }
                                if err := stream.Send(response); err != nil </span><span class="cov0" title="0">{
                                        s.logger.Infof("keepalive - failed to send request: %s", err.Error())
                                        return
                                }</span>
                        case res, ok := &lt;-s.responseChan:<span class="cov0" title="0">
                                s.logger.Infof("status channel received")
                                if !ok </span><span class="cov0" title="0">{
                                        s.logger.Infof("status channel closed")
                                        ctxCancel()
                                        return
                                }</span>
                                <span class="cov0" title="0">if err := stream.Send(res); err != nil </span><span class="cov0" title="0">{
                                        s.logger.Infof("keepalive - failed to send request: %s", err.Error())
                                        return
                                }</span>
                        }
                }
        }()

        // Retrieve agent info
        <span class="cov0" title="0">agentID, agentVersion, err := retrieveAgentInfo(stream.Context(), s.logger)
        if err != nil </span><span class="cov0" title="0">{
                errMessage := fmt.Sprintf("keepalive - failed to get agent info: %s", err.Error())
                s.responseChan &lt;- &amp;fromAgentV1.KeepaliveReply{
                        Status:       fromAgentV1.KeepaliveStatus_Closed,
                        ErrorMessage: errMessage,
                }
                s.logger.Errorf(errMessage)
                return err
        }</span>

        // Register agent to web
        <span class="cov0" title="0">req := &amp;internalAgentV1.AddAgentRequest{
                Id:      agentID,
                Version: agentVersion,
        }

        res, err := s.internalAgentClient.AddAgent(context.Background(), req)
        if err != nil </span><span class="cov0" title="0">{
                errMessage := fmt.Sprintf("keepalive - failed to add agent %s: %s", agentID, err.Error())
                s.responseChan &lt;- &amp;fromAgentV1.KeepaliveReply{
                        Status:       fromAgentV1.KeepaliveStatus_Closed,
                        ErrorMessage: errMessage,
                }
                s.logger.Errorf(errMessage)
                return ErrorCanNotAddAgent("%s", errMessage)
        }</span>
        <span class="cov0" title="0">s.logger.Infof("keepalive - register agent, ID: %s, uniqueID: %s, version: %s", res.GetId(), agentID, agentVersion)

        // Send connected
        s.logger.Debugf("send status to keep alive status chane: %s", agentID)
        s.responseChan &lt;- &amp;fromAgentV1.KeepaliveReply{
                Status: fromAgentV1.KeepaliveStatus_Connected,
        }

        // Keep alive
        s.logger.Infof("keepalive - stream opened for agent %s version %s", agentID, agentVersion)
        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return nil</span>
                default:<span class="cov0" title="0">
                        _, err = stream.Recv()
                        s.logger.Debugf("keepalive - receive keepalive response")
                        if err == io.EOF </span><span class="cov0" title="0">{
                                s.logger.Infof("keepalive - stream closed due to EOF for agent %s version %s", agentID, agentVersion)
                                return nil
                        }</span>
                        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                                errMessage := fmt.Sprintf("keepalive - failed to receive request: %s for agent %s version %s", err.Error(), agentID, agentVersion)
                                s.responseChan &lt;- &amp;fromAgentV1.KeepaliveReply{
                                        Status:       fromAgentV1.KeepaliveStatus_Closed,
                                        ErrorMessage: errMessage,
                                }
                                s.logger.Errorf(errMessage)
                                return err
                        }</span>
                }
        }
}

func retrieveAgentInfo(ctx context.Context, logger *log.Helper) (agentID string, agentVersion string, err error) <span class="cov0" title="0">{
        if md, ok := metadata.FromIncomingContext(ctx); ok </span><span class="cov0" title="0">{
                if len(md.Get(grpcConn.MetaDataAgentID)) == 0 ||
                        len(md.Get(grpcConn.MetaDataAgentVersion)) == 0 </span><span class="cov0" title="0">{

                        logger.Error("lack of agent metadata from context agent: %+v, version: %+v",
                                md.Get(grpcConn.MetaDataAgentID), md.Get(grpcConn.MetaDataAgentVersion))
                        return "", "", ErrorNoAgentMeta("failed to get agent metadata from context")
                }</span>

                <span class="cov0" title="0">agentID = md.Get(grpcConn.MetaDataAgentID)[0]
                agentVersion = md.Get(grpcConn.MetaDataAgentVersion)[0]</span>
        } else<span class="cov0" title="0"> {
                logger.Error("failed to get metadata from context")

                return "", "", ErrorNoAgentMeta("failed to get metadata from server context")
        }</span>

        <span class="cov0" title="0">return agentID, agentVersion, nil</span>
}
</pre>

		<pre class="file" id="file23" style="display: none">package service

import (
        "context"

        operationV1 "git.synology.inc/sast/access-system/server/gateway/api/operation/v1"
        "git.synology.inc/sast/access-system/server/gateway/helper"
        "git.synology.inc/sast/access-system/server/gateway/internal/biz"
        "git.synology.inc/sast/access-system/server/gateway/internal/conf"
        "google.golang.org/protobuf/types/known/emptypb"
)

type OperationService struct {
        operationV1.UnsafeOperationServer

        c                       *conf.Server
        forwardOperationUseCase biz.ForwardOperationUseCaseInterface
}

func NewOperationService(c *conf.Server, forwardOperationUseCase biz.ForwardOperationUseCaseInterface) *OperationService <span class="cov8" title="1">{
        return &amp;OperationService{
                c:                       c,
                forwardOperationUseCase: forwardOperationUseCase,
        }
}</span>

func (s *OperationService) TestConnection(ctx context.Context, req *operationV1.TestConnectionRequest,
) (*emptypb.Empty, error) <span class="cov8" title="1">{

        ctx, cancel := context.WithTimeout(ctx, s.c.GetGrpcForward().GetTimeout().AsDuration())
        defer cancel()

        // Arrange
        r := &amp;biz.TestConnectionRequest{}
        err := helper.Convert(req, r)
        if err != nil </span><span class="cov0" title="0">{
                return nil, ErrorConvertRequest("%s", err.Error())
        }</span>

        // Act
        <span class="cov8" title="1">_, errFromForward := s.forwardOperationUseCase.TestConnection(ctx, req.GetAgentId(), r)
        if errFromForward != nil </span><span class="cov0" title="0">{
                return nil, handleForwardError(errFromForward)
        }</span>

        <span class="cov8" title="1">return &amp;emptypb.Empty{}, nil</span>
}

// The door will only open briefly and will automatically lock when closed
func (s *OperationService) AccessDoor(ctx context.Context, req *operationV1.AccessDoorRequest) (*emptypb.Empty, error) <span class="cov8" title="1">{
        ctx, cancel := context.WithTimeout(ctx, s.c.GetGrpcForward().GetTimeout().AsDuration())
        defer cancel()

        // Arrange
        r := &amp;biz.AccessDoorRequest{}
        err := helper.Convert(req, r)
        if err != nil </span><span class="cov0" title="0">{
                return nil, ErrorConvertRequest("%s", err.Error())
        }</span>

        // Act
        <span class="cov8" title="1">_, errFromForward := s.forwardOperationUseCase.AccessDoor(ctx, req.GetAgentId(), r)
        if errFromForward != nil </span><span class="cov0" title="0">{
                return nil, handleForwardError(errFromForward)
        }</span>

        <span class="cov8" title="1">return &amp;emptypb.Empty{}, nil</span>
}

// The door will remain open continuously
func (s *OperationService) UnlockDoor(ctx context.Context, req *operationV1.UnlockDoorRequest) (*emptypb.Empty, error) <span class="cov8" title="1">{
        ctx, cancel := context.WithTimeout(ctx, s.c.GetGrpcForward().GetTimeout().AsDuration())
        defer cancel()

        // Arrange
        r := &amp;biz.UnlockDoorRequest{}
        err := helper.Convert(req, r)
        if err != nil </span><span class="cov0" title="0">{
                return nil, ErrorConvertRequest("%s", err.Error())
        }</span>

        // Act
        <span class="cov8" title="1">_, errFromForward := s.forwardOperationUseCase.UnlockDoor(ctx, req.GetAgentId(), r)
        if errFromForward != nil </span><span class="cov0" title="0">{
                return nil, handleForwardError(errFromForward)
        }</span>

        <span class="cov8" title="1">return &amp;emptypb.Empty{}, nil</span>
}

// Lock the door
func (s *OperationService) LockDoor(ctx context.Context, req *operationV1.LockDoorRequest) (*emptypb.Empty, error) <span class="cov8" title="1">{
        ctx, cancel := context.WithTimeout(ctx, s.c.GetGrpcForward().GetTimeout().AsDuration())
        defer cancel()

        // Arrange
        r := &amp;biz.LockDoorRequest{}
        err := helper.Convert(req, r)
        if err != nil </span><span class="cov0" title="0">{
                return nil, ErrorConvertRequest("%s", err.Error())
        }</span>

        // Act
        <span class="cov8" title="1">_, errFromForward := s.forwardOperationUseCase.LockDoor(ctx, req.GetAgentId(), r)
        if errFromForward != nil </span><span class="cov0" title="0">{
                return nil, handleForwardError(errFromForward)
        }</span>

        <span class="cov8" title="1">return &amp;emptypb.Empty{}, nil</span>
}

func (s *OperationService) ListAccessPoints(ctx context.Context, req *operationV1.ListAccessPointsRequest,
) (*operationV1.ListAccessPointsReply, error) <span class="cov8" title="1">{

        ctx, cancel := context.WithTimeout(ctx, s.c.GetGrpcForward().GetTimeout().AsDuration())
        defer cancel()

        // Arrange
        r := &amp;biz.ListAccessPointsRequest{}
        err := helper.Convert(req, r)
        if err != nil </span><span class="cov0" title="0">{
                return nil, ErrorConvertRequest("%s", err.Error())
        }</span>

        // Act
        <span class="cov8" title="1">res, errFromForward := s.forwardOperationUseCase.ListAccessPoints(ctx, req.GetAgentId(), r)
        if errFromForward != nil </span><span class="cov0" title="0">{
                return nil, handleForwardError(errFromForward)
        }</span>

        // Convert
        <span class="cov8" title="1">reply := &amp;operationV1.ListAccessPointsReply{}
        err = helper.Convert(res, reply)
        if err != nil </span><span class="cov0" title="0">{
                return nil, ErrorConvertResponse("%s", err.Error())
        }</span>

        <span class="cov8" title="1">return reply, nil</span>
}

func (s *OperationService) GetReaderLastCard(ctx context.Context, req *operationV1.GetReaderLastCardRequest,
) (*operationV1.GetReaderLastCardReply, error) <span class="cov0" title="0">{

        ctx, cancel := context.WithTimeout(ctx, s.c.GetGrpcForward().GetTimeout().AsDuration())
        defer cancel()

        // Arrange
        r := &amp;biz.GetReaderLastCardRequest{}
        err := helper.Convert(req, r)
        if err != nil </span><span class="cov0" title="0">{
                return nil, ErrorConvertRequest("%s", err.Error())
        }</span>

        // Act
        <span class="cov0" title="0">res, errFromForward := s.forwardOperationUseCase.GetReaderLastCard(ctx, req.GetAgentId(), r)
        if errFromForward != nil </span><span class="cov0" title="0">{
                return nil, handleForwardError(errFromForward)
        }</span>

        // Convert
        <span class="cov0" title="0">reply := &amp;operationV1.GetReaderLastCardReply{}
        err = helper.Convert(res, reply)
        if err != nil </span><span class="cov0" title="0">{
                return nil, ErrorConvertResponse("%s", err.Error())
        }</span>

        <span class="cov0" title="0">return reply, nil</span>
}
</pre>

		<pre class="file" id="file24" style="display: none">package service

import (
        grpcServerSideRequest "git.synology.inc/sast/access-system/grpc-server-side-request.git"
        "github.com/google/wire"
)

// ProviderSet is service providers.
var ProviderSet = wire.NewSet(
        NewAgentService,
        NewOperationService,
        NewFromAgentDynamicService,
        NewFromAgentStaticService,
        NewUpnpService,
        NewControllerService,
        NewSyncService,
        NewForwardAgentService,
        NewForwardOperationService,
        NewForwardUpnpService,
        NewForwardControllerService,
        NewForwardSyncService,
)

func handleForwardError(err *grpcServerSideRequest.Error) error <span class="cov0" title="0">{
        switch err.Code </span>{
        case grpcServerSideRequest.ErrorCodeUnknownError:<span class="cov0" title="0">
                return ErrorInternalError("%s", err.Error())</span>
        case grpcServerSideRequest.ErrorCodeSendRequest:<span class="cov0" title="0">
                return ErrorSendRequest("%s", err.Error())</span>
        case grpcServerSideRequest.ErrorCodeSendResponse:<span class="cov0" title="0">
                return ErrorSendResponse("%s", err.Error())</span>
        case grpcServerSideRequest.ErrorCodeSetField:<span class="cov0" title="0">
                return ErrorSetField("%s", err.Error())</span>
        case grpcServerSideRequest.ErrorCodeRequestChanNotFound:<span class="cov0" title="0">
                return ErrorRequestChannelNotFound("%s", err.Error())</span>
        case grpcServerSideRequest.ErrorCodeRequestMarshal:<span class="cov0" title="0">
                return ErrorRequestMarshal("%s", err.Error())</span>
        case grpcServerSideRequest.ErrorCodeConvertStruct:<span class="cov0" title="0">
                return ErrorConvertStruct("%s", err.Error())</span>
        case grpcServerSideRequest.ErrorCodeRetrieveError:<span class="cov0" title="0">
                return ErrorRetrieveError("%s", err.Error())</span>
        case grpcServerSideRequest.ErrorCodeReplyMarshal:<span class="cov0" title="0">
                return ErrorReplyMarshal("%s", err.Error())</span>
        case grpcServerSideRequest.ErrorCodeContextDone:<span class="cov0" title="0">
                return ErrorReplyMarshal("%s", err.Error())</span>
        case grpcServerSideRequest.ErrorCodeBadRequest:<span class="cov0" title="0">
                return ErrorBadRequest("%s", err.Error())</span>
        case grpcServerSideRequest.ErrorCodeClientTimeout:<span class="cov0" title="0">
                return ErrorClientTimeout("%s", err.Error())</span>
        case grpcServerSideRequest.ErrorCodeServerTimeout:<span class="cov0" title="0">
                return ErrorServerTimeout("%s", err.Error())</span>
        case grpcServerSideRequest.ErrorCodeUnauthorized:<span class="cov0" title="0">
                return ErrorUnauthorized("%s", err.Error())</span>
        case grpcServerSideRequest.ErrorCodeForbidden:<span class="cov0" title="0">
                return ErrorForbidden("%s", err.Error())</span>
        case grpcServerSideRequest.ErrorCodeNotFound:<span class="cov0" title="0">
                return ErrorNotFound("%s", err.Error())</span>
        }
        <span class="cov0" title="0">return ErrorInternalError("%s", err.Error())</span>
}
</pre>

		<pre class="file" id="file25" style="display: none">package service

import (
        "context"

        syncV1 "git.synology.inc/sast/access-system/server/gateway/api/sync/v1"
        "git.synology.inc/sast/access-system/server/gateway/helper"
        "git.synology.inc/sast/access-system/server/gateway/internal/biz"
        "git.synology.inc/sast/access-system/server/gateway/internal/conf"
)

type SyncService struct {
        syncV1.UnsafeSyncServer

        c                  *conf.Server
        forwardSyncUseCase biz.ForwardSyncUseCaseInterface
}

func NewSyncService(c *conf.Server, forwardSyncUseCase biz.ForwardSyncUseCaseInterface) *SyncService <span class="cov0" title="0">{
        return &amp;SyncService{
                c:                  c,
                forwardSyncUseCase: forwardSyncUseCase,
        }
}</span>

func (s *SyncService) SyncAddAsyncTask(ctx context.Context, req *syncV1.SyncAddAsyncTaskRequest) (
        *syncV1.SyncAddAsyncTaskReply, error) <span class="cov0" title="0">{

        ctx, cancel := context.WithTimeout(ctx, s.c.GetGrpcForward().GetTimeout().AsDuration())
        defer cancel()

        // Arrange
        r := &amp;biz.SyncAddAsyncTaskRequest{}
        err := helper.Convert(req, r)
        if err != nil </span><span class="cov0" title="0">{
                return nil, ErrorConvertRequest("%s", err.Error())
        }</span>

        // Act
        <span class="cov0" title="0">_, errFromForward := s.forwardSyncUseCase.SyncAddAsyncTask(ctx, req.GetAgentId(), r)
        if errFromForward != nil </span><span class="cov0" title="0">{
                return nil, handleForwardError(errFromForward)
        }</span>

        <span class="cov0" title="0">return &amp;syncV1.SyncAddAsyncTaskReply{}, nil</span>
}
</pre>

		<pre class="file" id="file26" style="display: none">package service

import (
        "context"
        "log"

        grpcServerSideRequest "git.synology.inc/sast/access-system/grpc-server-side-request.git"
        upnpV1 "git.synology.inc/sast/access-system/server/gateway/api/upnp/v1"
        "git.synology.inc/sast/access-system/server/gateway/helper"
        "git.synology.inc/sast/access-system/server/gateway/internal/biz"
        "git.synology.inc/sast/access-system/server/gateway/internal/conf"
)

type UpnpService struct {
        upnpV1.UnsafeUpnpServer

        c                  *conf.Server
        forwardUpnpUseCase *biz.ForwardUpnpUseCase
}

func NewUpnpService(c *conf.Server, forwardUpnpUseCase *biz.ForwardUpnpUseCase) *UpnpService <span class="cov0" title="0">{
        return &amp;UpnpService{
                c:                  c,
                forwardUpnpUseCase: forwardUpnpUseCase,
        }
}</span>

func (s *UpnpService) Search(req *upnpV1.UpnpSearchRequest, stream upnpV1.Upnp_SearchServer) error <span class="cov0" title="0">{
        // Arrange context
        ctx, cancel := context.WithTimeout(stream.Context(), s.c.GetGrpcForward().GetTimeout().AsDuration())
        defer cancel()

        // Init req
        reqTo := &amp;biz.UpnpSearchRequest{}

        // Init response chan
        responseChan := make(chan *biz.UpnpSearchReply)
        defer close(responseChan)

        errChan := make(chan *grpcServerSideRequest.Error)
        defer close(errChan)

        // Handle response
        go func() </span><span class="cov0" title="0">{
                for </span><span class="cov0" title="0">{
                        select </span>{
                        case response, ok := &lt;-responseChan:<span class="cov0" title="0">
                                if !ok </span><span class="cov0" title="0">{
                                        return
                                }</span>

                                <span class="cov0" title="0">var res upnpV1.UpnpSearchReply
                                err := helper.Convert(response, &amp;res)
                                if err != nil </span><span class="cov0" title="0">{
                                        log.Printf("convert response error: %s", err.Error())
                                        errChan &lt;- grpcServerSideRequest.NewError(grpcServerSideRequest.ErrorCodeConvertStruct, err.Error())
                                        return
                                }</span>

                                <span class="cov0" title="0">err = stream.Send(&amp;res)
                                if err != nil </span><span class="cov0" title="0">{
                                        log.Printf("send response error: %s", err.Error())
                                        errChan &lt;- grpcServerSideRequest.NewError(grpcServerSideRequest.ErrorCodeSendResponse, err.Error())
                                        return
                                }</span>
                        case &lt;-ctx.Done():<span class="cov0" title="0">
                                log.Println("context done - grpc - act func")
                                return</span>
                        }
                }
        }()

        // Act
        <span class="cov0" title="0">go s.forwardUpnpUseCase.Search(ctx, req.GetAgentId(), reqTo, responseChan, errChan)

        // Wait for response
        select </span>{
        case err := &lt;-errChan:<span class="cov0" title="0">
                log.Printf("receive response error: %s", err.Error())
                return handleForwardError(err)</span>
        case &lt;-ctx.Done():<span class="cov0" title="0">
                log.Println("context done - grpc")
                return nil</span>
        }
}
</pre>

		<pre class="file" id="file27" style="display: none">package biz

import (
        "context"

        "git.synology.inc/sast/access-system/server/web/internal/data"
        "git.synology.inc/sast/access-system/server/web/internal/datastore/dto"
        "github.com/go-kratos/kratos/v2/log"
)

type AccessRuleUseCaseInterface interface {
        AddAccessRule(ctx context.Context, accessRule *dto.AccessRule,
                userIDs []string, groupIDs []string, doorIDs []string, zoneIDs []string) (string, error)
        GetAccessRule(ctx context.Context, accessRuleID string) (*dto.AccessRule, error)
        UpdateAccessRule(ctx context.Context, ar *dto.AccessRule,
                addUserIDs []string, deleteUserIDs []string,
                addGroupIDs []string, deleteGroupIDs []string,
                addDoorIDs []string, deleteDoorIDs []string,
                addZoneIDs []string, deleteZoneIDs []string) error
        DeleteAccessRule(ctx context.Context, accessRuleID string) error
        ListAccessRule(ctx context.Context, offset, limit uint32) ([]*dto.AccessRule, uint32, error)

        /* User */
        AccessRuleAddUser(ctx context.Context, accessRule *dto.AccessRule, userIDs []string) error
        AccessRuleDeleteUser(ctx context.Context, accessRule *dto.AccessRule, users []*dto.User) error
        AccessRuleListUser(ctx context.Context, accessRuleID string, offset uint32, limit uint32) ([]*dto.User, uint32, error)

        /* Group */
        AccessRuleAddGroup(ctx context.Context, accessRule *dto.AccessRule, groupIDs []string) error
        AccessRuleDeleteGroup(ctx context.Context, accessRule *dto.AccessRule, groups []*dto.Group) error
        AccessRuleListGroup(ctx context.Context, accessRuleID string, offset uint32, limit uint32) ([]*dto.Group, uint32, error)

        /* Door */
        AccessRuleAddDoor(ctx context.Context, accessRule *dto.AccessRule, doorIDs []string) error
        AccessRuleDeleteDoor(ctx context.Context, accessRule *dto.AccessRule, doors []*dto.Door) error
        AccessRuleListDoor(ctx context.Context, accessRuleID string, offset uint32, limit uint32) ([]*dto.Door, uint32, error)

        /* Zone */
        AccessRuleAddZone(ctx context.Context, accessRule *dto.AccessRule, zoneIDs []string) error
        AccessRuleDeleteZone(ctx context.Context, accessRule *dto.AccessRule, zones []*dto.Zone) error
        AccessRuleListZone(ctx context.Context, accessRuleID string, offset uint32, limit uint32) ([]*dto.Zone, uint32, error)
}

type AccessRuleUseCase struct {
        log  *log.Helper
        data data.DataInterface
}

func NewAccessRuleUseCase(logger log.Logger, d data.DataInterface) AccessRuleUseCaseInterface <span class="cov0" title="0">{
        return &amp;AccessRuleUseCase{
                log:  log.NewHelper(logger),
                data: d,
        }
}</span>

func (uc *AccessRuleUseCase) AddAccessRule(ctx context.Context, accessRule *dto.AccessRule,
        userIDs []string, groupIDs []string, doorIDs []string, zoneIDs []string) (string, error) <span class="cov0" title="0">{

        uc.log.Debugf("AddAccessRule: %+v, userIDs: %+v, groupIDs: %+v, doorIDs: %+v, zoneIDs: %+v",
                accessRule, userIDs, groupIDs, doorIDs, zoneIDs)

        arid, err := uc.data.AddAccessRule(ctx, accessRule, userIDs, groupIDs, doorIDs, zoneIDs)
        if err != nil </span><span class="cov0" title="0">{
                uc.log.Errorf("data add access rule error: %s", err.Error())
                return "", ErrorAddAccessRuleError("data add access rule error, err: %s", err.Error())
        }</span>

        <span class="cov0" title="0">return arid, nil</span>
}

func (uc *AccessRuleUseCase) GetAccessRule(ctx context.Context, accessRuleID string) (*dto.AccessRule, error) <span class="cov0" title="0">{
        uc.log.Debugf("GetAccessRule: %+v", accessRuleID)

        ar, err := uc.data.GetAccessRule(ctx, accessRuleID)
        if err != nil </span><span class="cov0" title="0">{
                uc.log.Errorf("get access rule error: %s", err.Error())
                return nil, ErrorGetAccessRuleError("failed to get access rule, error: %s", err.Error())
        }</span>

        <span class="cov0" title="0">return ar, nil</span>
}

func (uc *AccessRuleUseCase) UpdateAccessRule(ctx context.Context, ar *dto.AccessRule,
        addUserIDs []string, deleteUserIDs []string,
        addGroupIDs []string, deleteGroupIDs []string,
        addDoorIDs []string, deleteDoorIDs []string,
        addZoneIDs []string, deleteZoneIDs []string) error <span class="cov0" title="0">{

        uc.log.Debug(
                "UpdateAccessRule: %+v\n"+
                        "  addUserIDs: %+v, deleteUserIDs: %+v\n"+
                        "  addGroupIDs: %+v, deleteGroupIDs: %+v\n"+
                        "  addDoorIDs: %+v, deleteDoorIDs: %+v\n"+
                        "  addZoneIDs: %+v, deleteZoneIDs: %+v",
                ar,
                addUserIDs, deleteUserIDs,
                addGroupIDs, deleteGroupIDs,
                addDoorIDs, deleteDoorIDs,
                addZoneIDs, deleteZoneIDs,
        )

        deleteUsers := make([]*dto.User, 0, len(deleteUserIDs))
        for _, userID := range deleteUserIDs </span><span class="cov0" title="0">{
                deleteUsers = append(deleteUsers, &amp;dto.User{
                        ID: userID,
                })
        }</span>

        <span class="cov0" title="0">deleteGroups := make([]*dto.Group, 0, len(deleteGroupIDs))
        for _, groupID := range deleteGroupIDs </span><span class="cov0" title="0">{
                deleteGroups = append(deleteGroups, &amp;dto.Group{
                        ID: groupID,
                })
        }</span>

        <span class="cov0" title="0">deleteDoors := make([]*dto.Door, 0, len(deleteDoorIDs))
        for _, doorID := range deleteDoorIDs </span><span class="cov0" title="0">{
                deleteDoors = append(deleteDoors, &amp;dto.Door{
                        ID: doorID,
                })
        }</span>

        <span class="cov0" title="0">deleteZones := make([]*dto.Zone, 0, len(deleteZoneIDs))
        for _, zoneID := range deleteZoneIDs </span><span class="cov0" title="0">{
                deleteZones = append(deleteZones, &amp;dto.Zone{
                        ID: zoneID,
                })
        }</span>

        <span class="cov0" title="0">err := uc.data.UpdateAccessRule(ctx, ar,
                addUserIDs, deleteUsers,
                addGroupIDs, deleteGroups,
                addDoorIDs, deleteDoors,
                addZoneIDs, deleteZones)

        if err != nil </span><span class="cov0" title="0">{
                uc.log.Errorf("update access rule error: %s", err.Error())
                return ErrorUpdateAccessRuleError("failed to update access rule, error: %s", err.Error())
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (uc *AccessRuleUseCase) DeleteAccessRule(ctx context.Context, accessRuleID string) error <span class="cov0" title="0">{
        uc.log.Debugf("DeleteAccessRule: %+v", accessRuleID)

        err := uc.data.DeleteAccessRule(ctx, accessRuleID)
        if err != nil </span><span class="cov0" title="0">{
                uc.log.Errorf("delete access rule error: %s", err.Error())
                return ErrorDeleteAccessRuleError("failed to delete access rule, error: %s", err.Error())
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (uc *AccessRuleUseCase) ListAccessRule(ctx context.Context, offset, limit uint32) ([]*dto.AccessRule, uint32, error) <span class="cov0" title="0">{
        uc.log.Debugf("ListAccessRules: offset=%d, limit=%d", offset, limit)

        ars, total, err := uc.data.ListAccessRule(ctx, offset, limit)
        if err != nil </span><span class="cov0" title="0">{
                uc.log.Errorf("list access rules error: %s", err.Error())
                return nil, 0, ErrorListAccessRuleError("failed to list access rules, error: %s", err.Error())
        }</span>

        <span class="cov0" title="0">return ars, total, nil</span>
}

/* User */
func (uc *AccessRuleUseCase) AccessRuleAddUser(ctx context.Context, accessRule *dto.AccessRule, userIDs []string) error <span class="cov0" title="0">{
        uc.log.Debugf("AccessRuleAddUser, access rule: %+v, user ids: %+v", accessRule, userIDs)

        err := uc.data.AccessRuleAddUser(ctx, accessRule, userIDs)
        if err != nil </span><span class="cov0" title="0">{
                uc.log.Errorf("data access rule add user error: %s", err.Error())
                return ErrorAccessRuleAddUserError("data access rule add user error, err: %s", err.Error())
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (uc *AccessRuleUseCase) AccessRuleDeleteUser(ctx context.Context, accessRule *dto.AccessRule, users []*dto.User) error <span class="cov0" title="0">{
        uc.log.Debugf("AccessRuleDeleteUser, AccessRule: %+v, user: %+v", accessRule, users)

        err := uc.data.AccessRuleDeleteUser(ctx, accessRule, users)
        if err != nil </span><span class="cov0" title="0">{
                uc.log.Errorf("data access rule delete user error: %s", err.Error())
                return ErrorAccessRuleDeleteUserError("data access rule delete user error, err: %s", err.Error())
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (uc *AccessRuleUseCase) AccessRuleListUser(ctx context.Context, accessRuleID string,
        offset uint32, limit uint32) ([]*dto.User, uint32, error) <span class="cov0" title="0">{

        uc.log.Debugf("AccessRuleListUser, AccessRuleID: %+v, offset: %d, limit: %d", accessRuleID, offset, limit)

        users, userCount, err := uc.data.AccessRuleListUser(ctx, accessRuleID, offset, limit)
        if err != nil </span><span class="cov0" title="0">{
                uc.log.Errorf("data access rule list user error: %s", err.Error())
                return nil, 0, ErrorAccessRuleListUserError("data access rule list user error, err: %s", err.Error())
        }</span>

        <span class="cov0" title="0">return users, userCount, nil</span>
}

/* Group */
func (uc *AccessRuleUseCase) AccessRuleAddGroup(ctx context.Context, accessRule *dto.AccessRule, groupIDs []string) error <span class="cov0" title="0">{
        uc.log.Debugf("AccessRuleAddGroup, access rule: %+v, group ids: %+v", accessRule, groupIDs)

        err := uc.data.AccessRuleAddGroup(ctx, accessRule, groupIDs)
        if err != nil </span><span class="cov0" title="0">{
                uc.log.Errorf("data access rule add group error: %s", err.Error())
                return ErrorAccessRuleAddGroupError("data access rule add group error, err: %s", err.Error())
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (uc *AccessRuleUseCase) AccessRuleDeleteGroup(ctx context.Context, accessRule *dto.AccessRule, groups []*dto.Group) error <span class="cov0" title="0">{
        uc.log.Debugf("AccessRuleDeleteGroup, AccessRule: %+v, group: %+v", accessRule, groups)

        err := uc.data.AccessRuleDeleteGroup(ctx, accessRule, groups)
        if err != nil </span><span class="cov0" title="0">{
                uc.log.Errorf("data access rule delete group error: %s", err.Error())
                return ErrorAccessRuleDeleteGroupError("data access rule delete group error, err: %s", err.Error())
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (uc *AccessRuleUseCase) AccessRuleListGroup(ctx context.Context, accessRuleID string,
        offset uint32, limit uint32) ([]*dto.Group, uint32, error) <span class="cov0" title="0">{

        uc.log.Debugf("AccessRuleListGroup, AccessRuleID: %+v, offset: %d, limit: %d", accessRuleID, offset, limit)

        groups, groupCount, err := uc.data.AccessRuleListGroup(ctx, accessRuleID, offset, limit)
        if err != nil </span><span class="cov0" title="0">{
                uc.log.Errorf("data access rule list group error: %s", err.Error())
                return nil, 0, ErrorAccessRuleListGroupError("data access rule list group error, err: %s", err.Error())
        }</span>

        <span class="cov0" title="0">return groups, groupCount, nil</span>
}

// Door
func (uc *AccessRuleUseCase) AccessRuleAddDoor(ctx context.Context, accessRule *dto.AccessRule, doorIDs []string) error <span class="cov0" title="0">{
        uc.log.Debugf("AccessRuleAddDoor, access rule: %+v, door ids: %+v", accessRule, doorIDs)

        err := uc.data.AccessRuleAddDoor(ctx, accessRule, doorIDs)
        if err != nil </span><span class="cov0" title="0">{
                uc.log.Errorf("data access rule add door error: %s", err.Error())
                return ErrorAccessRuleAddDoorError("data access rule add door error, err: %s", err.Error())
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (uc *AccessRuleUseCase) AccessRuleDeleteDoor(ctx context.Context, accessRule *dto.AccessRule, doors []*dto.Door) error <span class="cov0" title="0">{
        uc.log.Debugf("AccessRuleDeleteDoor, AccessRule: %+v, door: %+v", accessRule, doors)

        err := uc.data.AccessRuleDeleteDoor(ctx, accessRule, doors)
        if err != nil </span><span class="cov0" title="0">{
                uc.log.Errorf("data access rule delete door error: %s", err.Error())
                return ErrorAccessRuleDeleteDoorError("data access rule delete door error, err: %s", err.Error())
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (uc *AccessRuleUseCase) AccessRuleListDoor(ctx context.Context, accessRuleID string,
        offset uint32, limit uint32) ([]*dto.Door, uint32, error) <span class="cov0" title="0">{

        uc.log.Debugf("AccessRuleListDoor, AccessRuleID: %+v, offset: %d, limit: %d", accessRuleID, offset, limit)

        doors, doorCount, err := uc.data.AccessRuleListDoor(ctx, accessRuleID, offset, limit)
        if err != nil </span><span class="cov0" title="0">{
                uc.log.Errorf("data access rule list door error: %s", err.Error())
                return nil, 0, ErrorAccessRuleListDoorError("data access rule list door error, err: %s", err.Error())
        }</span>

        <span class="cov0" title="0">return doors, doorCount, nil</span>
}

// Zone
func (uc *AccessRuleUseCase) AccessRuleAddZone(ctx context.Context, accessRule *dto.AccessRule, zoneIDs []string) error <span class="cov0" title="0">{
        uc.log.Debugf("AccessRuleAddZone, access rule: %+v, zone ids: %+v", accessRule, zoneIDs)

        err := uc.data.AccessRuleAddZone(ctx, accessRule, zoneIDs)
        if err != nil </span><span class="cov0" title="0">{
                uc.log.Errorf("data access rule add zone error: %s", err.Error())
                return ErrorAccessRuleAddZoneError("data access rule add zone error, err: %s", err.Error())
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (uc *AccessRuleUseCase) AccessRuleDeleteZone(ctx context.Context, accessRule *dto.AccessRule, zones []*dto.Zone) error <span class="cov0" title="0">{
        uc.log.Debugf("AccessRuleDeleteZone, AccessRule: %+v, zone: %+v", accessRule, zones)

        err := uc.data.AccessRuleDeleteZone(ctx, accessRule, zones)
        if err != nil </span><span class="cov0" title="0">{
                uc.log.Errorf("data access rule delete zone error: %s", err.Error())
                return ErrorAccessRuleDeleteZoneError("data access rule delete zone error, err: %s", err.Error())
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (uc *AccessRuleUseCase) AccessRuleListZone(ctx context.Context, accessRuleID string,
        offset uint32, limit uint32) ([]*dto.Zone, uint32, error) <span class="cov0" title="0">{

        uc.log.Debugf("AccessRuleListZone, AccessRuleID: %+v, offset: %d, limit: %d", accessRuleID, offset, limit)

        zones, zoneCount, err := uc.data.AccessRuleListZone(ctx, accessRuleID, offset, limit)
        if err != nil </span><span class="cov0" title="0">{
                uc.log.Errorf("data access rule list zone error: %s", err.Error())
                return nil, 0, ErrorAccessRuleListZoneError("data access rule list zone error, err: %s", err.Error())
        }</span>

        <span class="cov0" title="0">return zones, zoneCount, nil</span>
}
</pre>

		<pre class="file" id="file28" style="display: none">package biz

import (
        "context"
        "time"

        "git.synology.inc/sast/access-system/server/web/internal/data"
        "git.synology.inc/sast/access-system/server/web/internal/datastore"
        "git.synology.inc/sast/access-system/server/web/internal/datastore/dto"
        "github.com/go-kratos/kratos/v2/log"
)

//go:generate bash ../../../mock.sh

type AgentUseCaseInterface interface {
        AddAgent(ctx context.Context, agent *dto.Agent) (string, error)
        GetAgent(ctx context.Context, agentID string) (*dto.Agent, error)
        DeleteAgent(ctx context.Context, agentID string) error
        ListAgent(ctx context.Context, offset uint32, limit uint32) ([]*dto.Agent, uint32, error)
}

type AgentUseCase struct {
        log  *log.Helper
        data data.DataInterface
}

func NewAgentUseCase(logger log.Logger, d data.DataInterface) AgentUseCaseInterface <span class="cov8" title="1">{
        return &amp;AgentUseCase{
                log:  log.NewHelper(logger),
                data: d,
        }
}</span>

func (uc *AgentUseCase) AddAgent(ctx context.Context, agent *dto.Agent) (string, error) <span class="cov8" title="1">{
        uc.log.Infof("AddAgent: %+v", agent)

        // Check exist agent
        existAgent, err := uc.data.GetAgentByUniqueID(ctx, agent.UniqueID)
        if err != nil &amp;&amp; !datastore.IsAgentNotFound(err) </span><span class="cov0" title="0">{
                uc.log.Errorf("data add agent error: %s", err.Error())
                return "", ErrorAddAgentError("data add agent error, err: %s", err.Error())
        }</span>
        <span class="cov8" title="1">if existAgent != nil </span><span class="cov0" title="0">{
                // Update agent version and last register time
                existAgent.Version = agent.Version
                existAgent.LastRegisterTime = time.Now().Unix()

                err = uc.data.UpdateAgent(ctx, existAgent)
                if err != nil </span><span class="cov0" title="0">{
                        uc.log.Errorf("data update agent version error: %s", err.Error())
                        return "", ErrorAddAgentError("data update agent version error: %s", err.Error())
                }</span>

                <span class="cov0" title="0">return existAgent.ID, nil</span>
        }

        // Create agent with register time
        <span class="cov8" title="1">agent.LastRegisterTime = time.Now().Unix()

        aid, err := uc.data.AddAgent(ctx, agent)
        if err != nil </span><span class="cov0" title="0">{
                uc.log.Errorf("data add agent error: %s", err.Error())
                return "", ErrorAddAgentError("data add agent error, err: %s", err.Error())
        }</span>

        <span class="cov8" title="1">return aid, nil</span>
}

func (uc *AgentUseCase) GetAgent(ctx context.Context, agentID string) (*dto.Agent, error) <span class="cov8" title="1">{
        uc.log.Infof("GetAgent: %+v", agentID)

        a, err := uc.data.GetAgent(ctx, agentID)
        if err != nil </span><span class="cov0" title="0">{
                uc.log.Errorf("data get agent error: %s", err.Error())
                return nil, ErrorGetAgentError("data get agent error, err: %s", err.Error())
        }</span>

        <span class="cov8" title="1">return a, nil</span>
}

func (uc *AgentUseCase) DeleteAgent(ctx context.Context, agentID string) error <span class="cov8" title="1">{
        uc.log.Infof("DeleteAgent: %+v", agentID)

        err := uc.data.DeleteAgent(ctx, agentID)
        if err != nil </span><span class="cov0" title="0">{
                uc.log.Errorf("data delete agent error: %s", err.Error())
                return ErrorDeleteAgentError("data delete agent error, err: %s", err.Error())
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (uc *AgentUseCase) ListAgent(ctx context.Context, offset uint32, limit uint32) ([]*dto.Agent, uint32, error) <span class="cov8" title="1">{
        uc.log.Debugf("ListAgent")

        agents, total, err := uc.data.ListAgent(ctx, offset, limit)
        if err != nil </span><span class="cov0" title="0">{
                uc.log.Errorf("data list agent error: %s", err.Error())
                return nil, 0, ErrorListAgentError("data list agent error, err: %s", err.Error())
        }</span>

        <span class="cov8" title="1">return agents, total, nil</span>
}
</pre>

		<pre class="file" id="file29" style="display: none">package biz

import (
        "context"

        "git.synology.inc/sast/access-system/server/web/internal/data"
        "git.synology.inc/sast/access-system/server/web/internal/datastore/dto"
        "github.com/go-kratos/kratos/v2/log"
)

//go:generate bash ../../../mock.sh

type ControllerUseCaseInterface interface {
        AddController(ctx context.Context, c *dto.Controller) (string, error)
        UpdateController(ctx context.Context, c *dto.Controller) error
        DeleteController(ctx context.Context, c *dto.Controller) error
        GetController(ctx context.Context, controllerID string) (*dto.Controller, error)
        ListControllerByAgentID(ctx context.Context, agentID string, offset uint32,
                limit uint32, door, idPoint bool) ([]*dto.Controller, uint32, error)
        ListAllController(ctx context.Context) ([]*dto.Controller, uint32, error)
        ListDoorByController(ctx context.Context, controllerID string) ([]*dto.Door, uint32, error)
        ListIDPointByController(ctx context.Context, controllerID string) ([]*dto.IDPoint, uint32, error)
}

type ControllerUseCase struct {
        data data.DataInterface
        log  *log.Helper
}

func NewControllerUseCase(d data.DataInterface, logger log.Logger) ControllerUseCaseInterface <span class="cov8" title="1">{
        return &amp;ControllerUseCase{data: d, log: log.NewHelper(logger)}
}</span>

func (uc *ControllerUseCase) AddController(ctx context.Context, c *dto.Controller) (string, error) <span class="cov8" title="1">{
        uc.log.Infof("AddController: %+v", c)

        cid, err := uc.data.AddController(ctx, c)
        if err != nil </span><span class="cov8" title="1">{
                uc.log.Errorf("add controller error: %s", err.Error())
                return "", ErrorAddControllerError("failed to add controller, error: %s", err.Error())
        }</span>

        <span class="cov8" title="1">return cid, nil</span>
}

func (uc *ControllerUseCase) UpdateController(ctx context.Context, c *dto.Controller) error <span class="cov8" title="1">{
        uc.log.Infof("UpdateController: %+v", c)

        err := uc.data.UpdateController(ctx, c)
        if err != nil </span><span class="cov8" title="1">{
                uc.log.Errorf("update controller error: %s", err.Error())
                return ErrorUpdateControllerError("failed to update controller, error: %s", err.Error())
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (uc *ControllerUseCase) DeleteController(ctx context.Context, c *dto.Controller) error <span class="cov8" title="1">{
        uc.log.Infof("DeleteController: %+v", c)

        err := uc.data.DeleteController(ctx, c)
        if err != nil </span><span class="cov8" title="1">{
                uc.log.Errorf("delete controller error: %s", err.Error())
                return ErrorDeleteControllerError("failed to delete controller, error: %s", err.Error())
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (uc *ControllerUseCase) GetController(ctx context.Context, controllerID string) (*dto.Controller, error) <span class="cov8" title="1">{
        uc.log.Infof("GetController: %+v", controllerID)

        c, err := uc.data.GetController(ctx, controllerID)
        if err != nil </span><span class="cov8" title="1">{
                uc.log.Errorf("get controller error: %s", err.Error())
                return nil, ErrorGetControllerError("failed to get controller, error: %s", err.Error())
        }</span>

        <span class="cov8" title="1">return c, nil</span>
}

func (uc *ControllerUseCase) ListControllerByAgentID(ctx context.Context, agentID string, offset uint32,
        limit uint32, door, idPoint bool) ([]*dto.Controller, uint32, error) <span class="cov8" title="1">{

        uc.log.Debugf("ListController, agentID: %s, offset: %d, limit: %d", agentID, offset, limit)

        cs, total, err := uc.data.ListControllerByAgentID(ctx, agentID, offset, limit, door, idPoint)
        if err != nil </span><span class="cov8" title="1">{
                uc.log.Errorf("list controllers error: %s", err.Error())
                return nil, 0, ErrorListControllerError("failed to list controllers, error: %s", err.Error())
        }</span>

        <span class="cov8" title="1">return cs, total, nil</span>
}

func (uc *ControllerUseCase) ListAllController(ctx context.Context) ([]*dto.Controller, uint32, error) <span class="cov8" title="1">{
        uc.log.Infof("ListAllController")

        cs, total, err := uc.data.ListAllController(ctx)
        if err != nil </span><span class="cov8" title="1">{
                uc.log.Errorf("list all controllers error: %s", err.Error())
                return nil, 0, ErrorListControllerError("failed to list all controllers, error: %s", err.Error())
        }</span>

        <span class="cov8" title="1">return cs, total, nil</span>
}

func (uc *ControllerUseCase) ListDoorByController(ctx context.Context, controllerID string) ([]*dto.Door, uint32, error) <span class="cov8" title="1">{
        uc.log.Infof("ListDoorByController")

        ds, total, err := uc.data.ListDoorByController(ctx, controllerID)
        if err != nil </span><span class="cov8" title="1">{
                uc.log.Errorf("list doors error: %s", err.Error())
                return nil, 0, ErrorListDoorByControllerError("failed to list doors, error: %s", err.Error())
        }</span>

        <span class="cov8" title="1">return ds, total, nil</span>
}

func (uc *ControllerUseCase) ListIDPointByController(ctx context.Context, controllerID string) ([]*dto.IDPoint, uint32, error) <span class="cov8" title="1">{
        uc.log.Debugf("ListIDPointByController")

        ds, total, err := uc.data.ListIDPointByController(ctx, controllerID)
        if err != nil </span><span class="cov8" title="1">{
                uc.log.Errorf("list id points error: %s", err.Error())
                return nil, 0, ErrorListIdPointByControllerError("failed to list id points, error: %s", err.Error())
        }</span>

        <span class="cov8" title="1">return ds, total, nil</span>
}
</pre>

		<pre class="file" id="file30" style="display: none">package biz

import (
        "context"

        "git.synology.inc/sast/access-system/server/web/internal/data"
        "git.synology.inc/sast/access-system/server/web/internal/datastore/dto"
        "github.com/go-kratos/kratos/v2/log"
)

//go:generate bash ../../../mock.sh

type DoorUseCaseInterface interface {
        UpdateDoor(ctx context.Context, d *dto.Door) error
        GetDoor(ctx context.Context, doorID string) (*dto.Door, error)
        ListDoor(ctx context.Context, offset uint32, limit uint32) ([]*dto.Door, uint32, error)
}

type DoorUseCase struct {
        data data.DataInterface
        log  *log.Helper
}

func NewDoorUseCase(d data.DataInterface, logger log.Logger) DoorUseCaseInterface <span class="cov8" title="1">{
        return &amp;DoorUseCase{data: d, log: log.NewHelper(logger)}
}</span>

func (uc *DoorUseCase) UpdateDoor(ctx context.Context, d *dto.Door) error <span class="cov8" title="1">{
        uc.log.Infof("UpdateDoor: %+v", d)

        err := uc.data.UpdateDoor(ctx, d)
        if err != nil </span><span class="cov8" title="1">{
                uc.log.Errorf("update door error: %s", err.Error())
                return ErrorUpdateDoorError("failed to update door, error: %s", err.Error())
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (uc *DoorUseCase) GetDoor(ctx context.Context, doorID string) (*dto.Door, error) <span class="cov8" title="1">{
        uc.log.Infof("GetDoor: %+v", doorID)

        d, err := uc.data.GetDoor(ctx, doorID)
        if err != nil </span><span class="cov8" title="1">{
                uc.log.Errorf("get door error: %s", err.Error())
                return nil, ErrorGetDoorError("failed to get door, error: %s", err.Error())
        }</span>

        <span class="cov8" title="1">return d, nil</span>
}

func (uc *DoorUseCase) ListDoor(ctx context.Context, offset uint32, limit uint32) ([]*dto.Door, uint32, error) <span class="cov8" title="1">{
        uc.log.Infof("ListDoor, offset: %d, limit: %d", offset, limit)

        doors, doorCount, err := uc.data.ListDoor(ctx, offset, limit)
        if err != nil </span><span class="cov8" title="1">{
                uc.log.Errorf("data list door error: %s", err.Error())
                return nil, 0, ErrorListDoorError("data list door error, err: %s", err.Error())
        }</span>

        <span class="cov8" title="1">return doors, doorCount, nil</span>
}
</pre>

		<pre class="file" id="file31" style="display: none">package biz

import (
        "context"
        "fmt"
        "math"
        "strconv"
        "time"

        dsmGroupV1 "git.synology.inc/sast/access-system/server/dsm/api/group/v1"
        dsmUserV1 "git.synology.inc/sast/access-system/server/dsm/api/user/v1"
        "git.synology.inc/sast/access-system/server/web/internal/data"
        "git.synology.inc/sast/access-system/server/web/internal/datastore/dto"
        "github.com/go-kratos/kratos/v2/log"
        "github.com/segmentio/ksuid"
)

type SynoUserExpiredState string

const (
        SynoUserExpiredStateNormal  SynoUserExpiredState = "normal"
        SynoUserExpiredStateExpired SynoUserExpiredState = "expired"
        SynoUserExpiredStateNow     SynoUserExpiredState = "now"
)

func (s SynoUserExpiredState) String() string <span class="cov0" title="0">{
        return string(s)
}</span>

type DsmUseCase struct {
        log            *log.Helper
        data           data.DataInterface
        total          uint32
        synced         uint32
        dsmUserClient  dsmUserV1.UserClient
        dsmGroupClient dsmGroupV1.GroupClient
}

func NewDsmUseCase(logger log.Logger, d data.DataInterface) *DsmUseCase <span class="cov0" title="0">{
        return &amp;DsmUseCase{
                log:    log.NewHelper(logger),
                data:   d,
                total:  0,
                synced: 0,
        }
}</span>

func (uc *DsmUseCase) SetClient(userClient dsmUserV1.UserClient, groupClient dsmGroupV1.GroupClient) <span class="cov0" title="0">{
        uc.dsmUserClient = userClient
        uc.dsmGroupClient = groupClient
}</span>

func (uc *DsmUseCase) GetSynoUserTotal(ctx context.Context, sourceType string) (uint32, error) <span class="cov0" title="0">{
        uc.log.Infof("GetSynoUserTotal")

        reply, err := uc.dsmUserClient.GetUserTotal(ctx, &amp;dsmUserV1.GetUserTotalRequest{
                Type: sourceType,
        })
        if err != nil </span><span class="cov0" title="0">{
                uc.log.Errorf("GetUserTotal failed: %s", err.Error())
                return 0, ErrorDsmGetUserTotalError("GetUserTotal failed: %s", err.Error())
        }</span>

        <span class="cov0" title="0">return reply.Total, nil</span>
}

func (uc *DsmUseCase) GetSynoGroupTotal(ctx context.Context, sourceType string) (uint32, error) <span class="cov0" title="0">{
        uc.log.Infof("GetSynoGroupTotal")

        reply, err := uc.dsmGroupClient.GetGroupTotal(ctx, &amp;dsmGroupV1.GetGroupTotalRequest{
                Type: sourceType,
        })
        if err != nil </span><span class="cov0" title="0">{
                uc.log.Errorf("GetGroupTotal failed: %s", err.Error())
                return 0, ErrorDsmGetGroupTotalError("GetGroupTotal failed: %s", err.Error())
        }</span>

        <span class="cov0" title="0">return reply.Total, nil</span>
}

func (uc *DsmUseCase) DeleteUserBySyncUID(ctx context.Context, syncUID string) error <span class="cov0" title="0">{
        uc.log.Infof("DeleteUserBySyncUID: %s", syncUID)

        err := uc.data.DeleteUserBySyncUID(ctx, syncUID)
        if err != nil </span><span class="cov0" title="0">{
                uc.log.Errorf("data delete user error: %s", err.Error())
                return ErrorDeleteUserError("data delete user error, err: %s", err.Error())
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (uc *DsmUseCase) DeleteUserBySyncTimeID(ctx context.Context, syncTimeID string) error <span class="cov0" title="0">{
        uc.log.Infof("DeleteUserBySyncTimeID: %s", syncTimeID)

        if err := uc.data.DeleteUserBySyncTimeID(ctx, syncTimeID); err != nil </span><span class="cov0" title="0">{
                uc.log.Errorf("data delete unsynced users error: %s", err.Error())
                return ErrorDeleteUserError("data delete unsynced users error, err: %s", err.Error())
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (uc *DsmUseCase) SyncUser(batchSize uint32, timeout time.Duration, syncTimeID string) error <span class="cov0" title="0">{
        uc.log.Infof("SyncUser start with syncTimeID: %s", syncTimeID)

        ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second) // 設定 10 秒超時
        defer cancel()

        uc.synced = 0
        total, err := uc.getUserTotal(ctx)
        if err != nil </span><span class="cov0" title="0">{
                uc.log.Errorf("get user total error: %s", err.Error())
                return err
        }</span>
        <span class="cov0" title="0">uc.total = total

        offset := uint32(0)
        for </span><span class="cov0" title="0">{
                synced, err := uc.syncUserBatch(ctx, batchSize, syncTimeID, offset)
                if err != nil </span><span class="cov0" title="0">{
                        uc.log.Errorf("sync user batch error: %s, synced: %d, total: %d", err.Error(), uc.synced, uc.total)
                        uc.synced = 0
                        return err
                }</span>
                <span class="cov0" title="0">uc.synced += synced
                uc.log.Infof("sync user batch synced: %d, synced: %d", synced, uc.synced)

                if synced == 0 </span><span class="cov0" title="0">{
                        uc.total = uc.synced
                        uc.log.Debugf("sync user batch done, synced: %d, total: %d", uc.synced, uc.total)
                        break</span>
                }
                <span class="cov0" title="0">offset += batchSize</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func (uc *DsmUseCase) GetSyncProgress() (float64, error) <span class="cov0" title="0">{
        progress := float64(0.0)
        if uc.total != 0 </span><span class="cov0" title="0">{
                progress = float64(uc.synced) / float64(uc.total) * 100
        }</span>
        <span class="cov0" title="0">formattedProgress, err := strconv.ParseFloat(fmt.Sprintf("%.2f", progress), 64)
        if err != nil </span><span class="cov0" title="0">{
                return 0, ErrorDsmGetProgressError("failed to format progress: %s", err.Error())
        }</span>
        <span class="cov0" title="0">return formattedProgress, nil</span>
}

func (uc *DsmUseCase) SyncUserFromDSMHook(ctx context.Context, dsmUIDList string) error <span class="cov0" title="0">{
        uc.log.Infof("SyncUserFromDSMHook: %s", dsmUIDList)

        userReply, err := uc.dsmUserClient.GetUser(ctx, &amp;dsmUserV1.GetUserRequest{
                UidList: dsmUIDList,
        })
        if err != nil </span><span class="cov0" title="0">{
                uc.log.Errorf("GetUser failed: %s", err.Error())
                return ErrorDsmSyncUserError("GetUser failed: %s", err.Error())
        }</span>

        <span class="cov0" title="0">_, err = uc.data.SyncUser(ctx, uc.convertSynoUsersToUsers(userReply.Users, ksuid.New().String()))
        if err != nil </span><span class="cov0" title="0">{
                uc.log.Errorf("data sync user error: %s", err.Error())
                return ErrorDsmSyncUserError("data sync user error, err: %s", err.Error())
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (uc *DsmUseCase) DeleteGroupBySyncGID(ctx context.Context, syncGID string) error <span class="cov0" title="0">{
        uc.log.Infof("DeleteGroupBySyncGID: %s", syncGID)

        err := uc.data.DeleteGroupBySyncGID(ctx, syncGID)
        if err != nil </span><span class="cov0" title="0">{
                uc.log.Errorf("data delete group error: %s", err.Error())
                return ErrorDeleteGroupError("data delete group error, err: %s", err.Error())
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (uc *DsmUseCase) DeleteGroupBySyncTimeID(ctx context.Context, syncTimeID string) error <span class="cov0" title="0">{
        uc.log.Infof("DeleteGroupBySyncTimeID: %s", syncTimeID)

        if err := uc.data.DeleteGroupBySyncTimeID(ctx, syncTimeID); err != nil </span><span class="cov0" title="0">{
                uc.log.Errorf("data delete unsynced groups error: %s", err.Error())
                return ErrorDeleteGroupError("data delete unsynced groups error, err: %s", err.Error())
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (uc *DsmUseCase) SyncGroup(batchSize uint32, timeout time.Duration, syncTimeID string) error <span class="cov0" title="0">{
        uc.log.Infof("SyncGroup start with syncTimeID: %s", syncTimeID)

        ctx, cancel := context.WithTimeout(context.Background(), timeout)
        defer cancel()

        uc.synced = 0
        total, err := uc.getGroupTotal(ctx)
        if err != nil </span><span class="cov0" title="0">{
                uc.log.Errorf("get group total error: %s", err.Error())
                return err
        }</span>
        <span class="cov0" title="0">uc.total = total

        groups, err := uc.dsmGroupClient.ListGroup(ctx, &amp;dsmGroupV1.ListGroupRequest{})
        if err != nil </span><span class="cov0" title="0">{
                uc.log.Errorf("ListGroup failed: %s", err.Error())
                return ErrorDsmSyncGroupError("ListGroup failed: %s", err.Error())
        }</span>

        <span class="cov0" title="0">if len(groups.Groups) == 0 </span><span class="cov0" title="0">{
                uc.log.Infof("no group to sync")
                return nil
        }</span>

        <span class="cov0" title="0">synced, err := uc.data.SyncGroup(ctx, uc.convertSynoGroupsToGroups(groups.Groups, syncTimeID))
        if err != nil </span><span class="cov0" title="0">{
                uc.log.Errorf("data sync group error: %s", err.Error())
                return ErrorDsmSyncGroupError("data sync group error: %s", err.Error())
        }</span>
        <span class="cov0" title="0">uc.synced += synced

        return nil</span>
}

func (uc *DsmUseCase) SetGroupFromDSMHook(ctx context.Context, originName string, newName string) error <span class="cov0" title="0">{
        uc.log.Infof("SetGroupFromDSMHook: %s, %s", originName, newName)
        isAddGroup := (originName == "")

        if newName == "" </span><span class="cov0" title="0">{
                uc.log.Errorf("new group name is empty")
                return ErrorDsmSetGroupError("new group name is empty")
        }</span>

        <span class="cov0" title="0">if isAddGroup </span><span class="cov0" title="0">{
                groupReply, err := uc.dsmGroupClient.GetGroup(ctx, &amp;dsmGroupV1.GetGroupRequest{
                        Name: newName,
                })
                if err != nil </span><span class="cov0" title="0">{
                        uc.log.Errorf("GetGroup failed: %s", err.Error())
                        return ErrorDsmSetGroupError("GetGroup failed: %s", err.Error())
                }</span>

                <span class="cov0" title="0">_, err = uc.data.SyncGroup(ctx,
                        uc.convertSynoGroupsToGroups([]*dsmGroupV1.SynoGroup{groupReply.Group}, ksuid.New().String()))
                if err != nil </span><span class="cov0" title="0">{
                        uc.log.Errorf("data sync group error: %s", err.Error())
                        return ErrorDsmSetGroupError("data sync group error: %s", err.Error())
                }</span>
        } else<span class="cov0" title="0"> {
                targetGroup, err := uc.data.GetGroupByName(ctx, originName, dto.GroupSourceDSM)
                if err != nil </span><span class="cov0" title="0">{
                        uc.log.Errorf("failed to get group by name: %s", err.Error())
                        return ErrorDsmSetGroupError("failed to get group by name: %s", err.Error())
                }</span>
                <span class="cov0" title="0">targetGroup.UniqueID = newName
                targetGroup.Name = newName
                if err := uc.data.UpdateGroup(ctx, targetGroup); err != nil </span><span class="cov0" title="0">{
                        uc.log.Errorf("failed to update group: %s", err.Error())
                        return ErrorDsmSetGroupError("failed to update group: %s", err.Error())
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func (uc *DsmUseCase) SyncUserGroupFromDSMHook(ctx context.Context, dsmUID string, dsmGIDList []string) error <span class="cov0" title="0">{
        uc.log.Infof("SyncUserGroupFromDSMHook: %s, %v", dsmUID, dsmGIDList)

        targetUser, err := uc.data.GetUserIDsBySyncUIDs(ctx, []string{dsmUID})
        if err != nil </span><span class="cov0" title="0">{
                uc.log.Errorf("failed to get user by sync uid: %s", err.Error())
                return ErrorDsmSyncUserGroupError("failed to get user by sync uid: %s", err.Error())
        }</span>

        <span class="cov0" title="0">targetGroupIDs, err := uc.data.GetGroupIDsBySyncGIDs(ctx, dsmGIDList)
        if err != nil </span><span class="cov0" title="0">{
                uc.log.Errorf("failed to get groups by sync gids: %s", err.Error())
                return ErrorDsmSyncUserGroupError("failed to get groups by sync gids: %s", err.Error())
        }</span>

        <span class="cov0" title="0">uc.log.Debugf("targetUser: %v, targetGroupIDs: %v", targetUser[0], targetGroupIDs)

        if err := uc.data.UpdateUserGroups(ctx, targetUser[0], targetGroupIDs); err != nil </span><span class="cov0" title="0">{
                uc.log.Errorf("failed to sync user group: %s", err.Error())
                return ErrorDsmSyncUserGroupError("failed to sync user group: %s", err.Error())
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (uc *DsmUseCase) GetStatistics(ctx context.Context) (*dto.DSMStatistics, error) <span class="cov0" title="0">{
        uc.log.Debug("GetStatistics")

        statistics, err := uc.data.GetDSMStatistics(ctx)
        if err != nil </span><span class="cov0" title="0">{
                uc.log.Errorf("get dsm statistics error: %s", err.Error())
                return nil, ErrorDsmGetStatisticsError("failed to get dsm statistics, error: %s", err.Error())
        }</span>

        <span class="cov0" title="0">return statistics, nil</span>
}

func (uc *DsmUseCase) EnableSync(ctx context.Context, enable bool) error <span class="cov0" title="0">{
        uc.log.Debug("EnableSync")

        err := uc.data.EnableSync(ctx, enable)
        if err != nil </span><span class="cov0" title="0">{
                uc.log.Errorf("enable dsm sync error: %s", err.Error())
                return ErrorDsmEnableSyncError("failed to enable dsm sync, error: %s", err.Error())
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (uc *DsmUseCase) UpdateSyncTime(lastSyncTime string) error <span class="cov0" title="0">{
        uc.log.Debugf("UpdateSyncTime: %s", lastSyncTime)

        err := uc.data.UpdateSyncTime(lastSyncTime)
        if err != nil </span><span class="cov0" title="0">{
                uc.log.Errorf("update sync time error: %s", err.Error())
                return ErrorDsmUpdateSyncTimeError("failed to update sync time, error: %s", err.Error())
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (uc *DsmUseCase) LinkUserGroup(ctx context.Context, batchSize uint32, syncTimeID string) error <span class="cov0" title="0">{
        uc.log.Infof("LinkUserGroup start with syncTimeID: %s", syncTimeID)

        groupLimit := batchSize
        for groupOffset := uint32(0); ; groupOffset += groupLimit </span><span class="cov0" title="0">{
                groups, groupCount, err := uc.data.ListGroupBySource(ctx, groupOffset, groupLimit, dto.GroupSourceDSM)
                if err != nil </span><span class="cov0" title="0">{
                        uc.log.Errorf("data list group error: %s", err.Error())
                        return ErrorDsmLinkUserGroupError("data list group error: %s", err.Error())
                }</span>

                <span class="cov0" title="0">uc.log.Infof("len(groups): %d groupOffset: %d groupCount %d", len(groups), groupOffset, groupCount)
                if len(groups) == 0 </span><span class="cov0" title="0">{
                        break</span>
                }

                <span class="cov0" title="0">for _, group := range groups </span><span class="cov0" title="0">{
                        groupMember, err := uc.dsmGroupClient.GroupListMember(ctx, &amp;dsmGroupV1.GroupListMemberRequest{
                                Name: group.Name,
                        })
                        if err != nil </span><span class="cov0" title="0">{
                                uc.log.Errorf("GroupListMember failed: %s", err.Error())
                                return ErrorDsmLinkUserGroupError("GroupListMember failed: %s", err.Error())
                        }</span>

                        <span class="cov0" title="0">if len(groupMember.Uids) == 0 </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        <span class="cov0" title="0">targetGroup := &amp;dto.Group{
                                ID: group.ID,
                        }
                        syncUIDs := make([]string, 0, len(groupMember.Uids))
                        syncUIDs = append(syncUIDs, groupMember.Uids...)

                        users, err := uc.data.GetUserIDsBySyncUIDs(ctx, syncUIDs)
                        if err != nil </span><span class="cov0" title="0">{
                                uc.log.Errorf("data get users by sync uid error: %s", err.Error())
                                return ErrorDsmLinkUserGroupError("data get users by sync uid error: %s", err.Error())
                        }</span>

                        <span class="cov0" title="0">err = uc.data.UpdateGroupMembers(ctx, targetGroup, users, 0, math.MaxUint32)
                        if err != nil </span><span class="cov0" title="0">{
                                uc.log.Errorf("data group add user error: %s", err.Error())
                                return ErrorDsmLinkUserGroupError("data group add user error: %s", err.Error())
                        }</span>
                }
        }

        <span class="cov0" title="0">return nil</span>
}

func (uc *DsmUseCase) syncUserBatch(ctx context.Context, batchSize uint32, syncTimeID string,
        offset uint32) (uint32, error) <span class="cov0" title="0">{

        uc.log.Infof("SyncUser, offset: %d ", offset)

        select </span>{
        case &lt;-ctx.Done():<span class="cov0" title="0">
                uc.log.Errorf("context canceled: %s", ctx.Err())
                return 0, ErrorDsmSyncUserError("context canceled")</span>
        default:<span class="cov0" title="0"></span>
                // Do nothing
        }

        <span class="cov0" title="0">userReply, err := uc.dsmUserClient.ListUser(ctx, &amp;dsmUserV1.ListUserRequest{
                Offset: offset,
                Limit:  batchSize,
        })
        if err != nil </span><span class="cov0" title="0">{
                uc.log.Errorf("ListUser failed: %s", err.Error())
                return 0, ErrorDsmSyncUserError("ListUser failed: %s", err.Error())
        }</span>
        <span class="cov0" title="0">if userReply.Total == 0 </span><span class="cov0" title="0">{
                return 0, nil
        }</span>

        <span class="cov0" title="0">synced, err := uc.data.SyncUser(ctx, uc.convertSynoUsersToUsers(userReply.Users, syncTimeID))
        if err != nil </span><span class="cov0" title="0">{
                uc.log.Errorf("data sync user error: %s", err.Error())
                return 0, ErrorDsmSyncUserError("data sync user error, err: %s", err.Error())
        }</span>
        <span class="cov0" title="0">return synced, nil</span>
}

func (uc *DsmUseCase) convertSynoUsersToUsers(synoUsers []*dsmUserV1.SynoUser,
        syncTimeID string) []*dto.User <span class="cov0" title="0">{

        users := make([]*dto.User, 0, len(synoUsers))
        for _, synoUser := range synoUsers </span><span class="cov0" title="0">{
                validFromUnix := int64(-1)
                validUntilUnix := int64(-1)
                state := dto.UserStateActivated
                lastName := synoUser.Name

                switch synoUser.Expired </span>{
                case SynoUserExpiredStateNormal.String():<span class="cov0" title="0"></span>
                        // Do nothing
                case SynoUserExpiredStateExpired.String(), SynoUserExpiredStateNow.String():<span class="cov0" title="0">
                        state = dto.UserStateDeactivated</span>
                default:<span class="cov0" title="0">
                        // For the case where the user is not yet expired and has a expiration date
                        if t, err := time.Parse("2006/01/02", synoUser.Expired); err == nil </span><span class="cov0" title="0">{
                                validUntilUnix = t.Unix()
                        }</span> else<span class="cov0" title="0"> {
                                state = dto.UserStateDeactivated
                                uc.log.Errorf("failed to parse expired time: %s", synoUser.Expired)
                        }</span>
                }

                <span class="cov0" title="0">user := &amp;dto.User{
                        ID:             ksuid.New().String(),
                        UniqueID:       lastName,
                        SyncUID:        synoUser.Uid,
                        SyncTimeID:     syncTimeID,
                        State:          state,
                        Source:         dto.UserSourceDSM,
                        SynoUserType:   dto.SynoUserType(synoUser.SourceType),
                        LastName:       lastName,
                        EMail:          synoUser.Email,
                        Description:    synoUser.Description,
                        ValidFrom:      validFromUnix,
                        ValidUntil:     validUntilUnix,
                        LongAccessTime: false,
                }
                // print SynoUserType
                uc.log.Infof("LastName %s SynoUserType: %s", lastName, dto.SynoUserType(synoUser.SourceType))
                users = append(users, user)</span>
        }
        <span class="cov0" title="0">return users</span>
}

func (uc *DsmUseCase) convertSynoGroupsToGroups(synoGroups []*dsmGroupV1.SynoGroup,
        syncTimeID string) []*dto.Group <span class="cov0" title="0">{

        groups := make([]*dto.Group, 0, len(synoGroups))
        for _, synoGroup := range synoGroups </span><span class="cov0" title="0">{
                group := &amp;dto.Group{
                        ID:            ksuid.New().String(),
                        UniqueID:      synoGroup.Name,
                        SyncTimeID:    syncTimeID,
                        SyncGID:       synoGroup.Gid,
                        Name:          synoGroup.Name,
                        Description:   synoGroup.Description,
                        Source:        dto.GroupSourceDSM,
                        SynoGroupType: dto.SynoGroupType(synoGroup.SourceType),
                }
                groups = append(groups, group)
        }</span>
        <span class="cov0" title="0">return groups</span>
}

func (uc *DsmUseCase) getUserTotal(ctx context.Context) (uint32, error) <span class="cov0" title="0">{
        uc.log.Infof("getUserTotal")

        reply, err := uc.dsmUserClient.GetUserTotal(ctx, &amp;dsmUserV1.GetUserTotalRequest{
                Type: "all",
        })
        if err != nil </span><span class="cov0" title="0">{
                uc.log.Errorf("GetUserTotal failed: %s", err.Error())
                return 0, ErrorDsmGetUserTotalError("GetUserTotal failed: %s", err.Error())
        }</span>

        <span class="cov0" title="0">return reply.Total, nil</span>
}

func (uc *DsmUseCase) getGroupTotal(ctx context.Context) (uint32, error) <span class="cov0" title="0">{
        uc.log.Infof("getGroupTotal")

        reply, err := uc.dsmGroupClient.GetGroupTotal(ctx, &amp;dsmGroupV1.GetGroupTotalRequest{
                Type: "all",
        })
        if err != nil </span><span class="cov0" title="0">{
                uc.log.Errorf("GetGroupTotal failed: %s", err.Error())
                return 0, ErrorDsmGetGroupTotalError("GetGroupTotal failed: %s", err.Error())
        }</span>

        <span class="cov0" title="0">return reply.Total, nil</span>
}
</pre>

		<pre class="file" id="file32" style="display: none">package biz

import (
        "github.com/go-kratos/kratos/v2/log"
)

type GeneralUseCase struct {
        log *log.Helper
}

func NewGeneralUseCase(logger log.Logger) *GeneralUseCase <span class="cov0" title="0">{
        return &amp;GeneralUseCase{
                log: log.NewHelper(logger),
        }
}</span>

func (uc *GeneralUseCase) Healthz() string <span class="cov0" title="0">{
        return "ok"
}</span>
</pre>

		<pre class="file" id="file33" style="display: none">package biz

import (
        "context"

        groupV1 "git.synology.inc/sast/access-system/server/web/api/group/v1"
        "git.synology.inc/sast/access-system/server/web/internal/data"
        "git.synology.inc/sast/access-system/server/web/internal/datastore"
        "git.synology.inc/sast/access-system/server/web/internal/datastore/dto"
        "github.com/go-kratos/kratos/v2/log"
)

type GroupUseCaseInterface interface {
        AddGroup(ctx context.Context, group *dto.Group, userIDs []string, groupIDs []string) (string, error)
        GetGroup(ctx context.Context, group *dto.Group) (*dto.Group, error)
        GetGroupByName(ctx context.Context, name string, source dto.GroupSource) (*dto.Group, error)
        UpdateGroup(ctx context.Context, group *dto.Group) error
        DeleteGroup(ctx context.Context, group *dto.Group) error
        ListGroup(ctx context.Context, offset uint32, limit uint32) ([]*dto.Group, uint32, error)
        ListGroupByUserID(ctx context.Context, userID string, offset uint32, limit uint32) ([]*dto.Group, uint32, error)
        GroupAddUser(ctx context.Context, group *dto.Group, users []*dto.User) error
        GroupDeleteUser(ctx context.Context, group *dto.Group, users []*dto.User) error
        GroupListUser(ctx context.Context, group *dto.Group, mode groupV1.RelationListMode, offset uint32, limit uint32,
        ) ([]*dto.User, uint32, error)
        GroupAddGroup(ctx context.Context, group *dto.Group, subgroups []*dto.Group) error
        GroupDeleteGroup(ctx context.Context, group *dto.Group, subgroups []*dto.Group) error
        GroupListGroup(ctx context.Context, group *dto.Group, mode groupV1.RelationListMode, offset uint32, limit uint32,
        ) ([]*dto.Group, uint32, error)
}

type GroupUseCase struct {
        log  *log.Helper
        data data.DataInterface
}

func NewGroupUseCase(logger log.Logger, d data.DataInterface) GroupUseCaseInterface <span class="cov0" title="0">{
        return &amp;GroupUseCase{
                log:  log.NewHelper(logger),
                data: d,
        }
}</span>

func (uc *GroupUseCase) AddGroup(ctx context.Context, group *dto.Group, userIDs []string, groupIDs []string) (string, error) <span class="cov0" title="0">{
        uc.log.Debugf("AddGroup: %+v userIDs: %+v groupIDs: %+v", group, userIDs, groupIDs)

        gid, err := uc.data.AddGroup(ctx, group, userIDs, groupIDs)
        if err != nil </span><span class="cov0" title="0">{
                uc.log.Errorf("data add group error: %s", err.Error())
                return "", ErrorAddGroupError("data add group error, err: %s", err.Error())
        }</span>

        <span class="cov0" title="0">return gid, nil</span>
}

func (uc *GroupUseCase) GetGroup(ctx context.Context, group *dto.Group) (*dto.Group, error) <span class="cov0" title="0">{
        uc.log.Debugf("GetGroup: %+v", group)

        g, err := uc.data.GetGroup(ctx, group)
        if err != nil </span><span class="cov0" title="0">{
                uc.log.Errorf("data get group error: %s", err.Error())
                return nil, ErrorGetGroupError("data get group error, err: %s", err.Error())
        }</span>

        <span class="cov0" title="0">return g, nil</span>
}

func (uc *GroupUseCase) GetGroupByName(ctx context.Context, name string, source dto.GroupSource) (*dto.Group, error) <span class="cov0" title="0">{
        uc.log.Debugf("GetGroupByName: %+v", source)

        g, err := uc.data.GetGroupByName(ctx, name, source)
        if err != nil </span><span class="cov0" title="0">{
                if datastore.IsGroupNotFound(err) </span><span class="cov0" title="0">{
                        return nil, nil
                }</span> else<span class="cov0" title="0"> {
                        uc.log.Errorf("data get group error: %s", err.Error())
                        return nil, ErrorGetGroupError("data get group error, err: %s", err.Error())
                }</span>
        }

        <span class="cov0" title="0">return g, nil</span>
}

func (uc *GroupUseCase) UpdateGroup(ctx context.Context, group *dto.Group) error <span class="cov0" title="0">{
        uc.log.Debugf("UpdateGroup: %+v", group)

        err := uc.data.UpdateGroup(ctx, group)
        if err != nil </span><span class="cov0" title="0">{
                uc.log.Errorf("data get group error: %s", err.Error())
                return ErrorUpdateGroupError("data get group error, err: %s", err.Error())
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (uc *GroupUseCase) DeleteGroup(ctx context.Context, group *dto.Group) error <span class="cov0" title="0">{
        uc.log.Debugf("DeleteGroup: %+v", group)

        g, err := uc.data.GetGroup(ctx, group)
        if err != nil </span><span class="cov0" title="0">{
                uc.log.Errorf("data get group error: %s", err.Error())
                return ErrorDeleteGroupError("get group before delete error, err: %s", err.Error())
        }</span>

        <span class="cov0" title="0">if g.Source == dto.GroupSourceDSM </span><span class="cov0" title="0">{
                uc.log.Errorf("delete group error: DSM group can not be deleted")
                return ErrorDeleteGroupError("DSM group can not be deleted")
        }</span>

        <span class="cov0" title="0">err = uc.data.DeleteGroup(ctx, group)
        if err != nil </span><span class="cov0" title="0">{
                uc.log.Errorf("data delete group error: %s", err.Error())
                return ErrorDeleteGroupError("data delete group error, err: %s", err.Error())
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (uc *GroupUseCase) ListGroup(ctx context.Context, offset uint32, limit uint32) ([]*dto.Group, uint32, error) <span class="cov0" title="0">{
        uc.log.Debugf("ListGroup: offset = %d, limit = %d", offset, limit)

        groups, groupCount, err := uc.data.ListGroup(ctx, offset, limit)
        if err != nil </span><span class="cov0" title="0">{
                uc.log.Errorf("data list group error: %s", err.Error())
                return nil, 0, ErrorListGroupError("data list group error, err: %s", err.Error())
        }</span>

        <span class="cov0" title="0">return groups, groupCount, nil</span>
}

func (uc *GroupUseCase) ListGroupByUserID(ctx context.Context, userID string, offset uint32, limit uint32) ([]*dto.Group, uint32, error) <span class="cov0" title="0">{
        uc.log.Debugf("ListGroupByUserID: offset = %d, limit = %d", offset, limit)

        groups, groupCount, err := uc.data.ListGroupByUserID(ctx, userID, offset, limit)
        if err != nil </span><span class="cov0" title="0">{
                uc.log.Errorf("data list group error: %s", err.Error())
                return nil, 0, ErrorListGroupError("data list group error, err: %s", err.Error())
        }</span>

        <span class="cov0" title="0">return groups, groupCount, nil</span>
}

func (uc *GroupUseCase) GroupAddUser(ctx context.Context, group *dto.Group, users []*dto.User) error <span class="cov0" title="0">{
        uc.log.Debugf("GroupAddUser, group: %+v, user: %+v", group, users)

        err := uc.data.GroupAddUser(ctx, group, users)
        if err != nil </span><span class="cov0" title="0">{
                uc.log.Errorf("data group add user error: %s", err.Error())
                return ErrorGroupAddUserError("data group add user error, err: %s", err.Error())
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (uc *GroupUseCase) GroupDeleteUser(ctx context.Context, group *dto.Group, users []*dto.User) error <span class="cov0" title="0">{
        uc.log.Debugf("GroupDeleteUser, group: %+v, user: %+v", group, users)

        err := uc.data.GroupDeleteUser(ctx, group, users)
        if err != nil </span><span class="cov0" title="0">{
                uc.log.Errorf("data group delete user error: %s", err.Error())
                return ErrorGroupDeleteUserError("data group delete user error, err: %s", err.Error())
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (uc *GroupUseCase) GroupListUser(ctx context.Context, group *dto.Group, mode groupV1.RelationListMode,
        offset uint32, limit uint32) (
        []*dto.User, uint32, error) <span class="cov0" title="0">{

        uc.log.Debugf("GroupListUser, group: %+v, mode: %s, offset: %d, limit: %d", group, mode, offset, limit)

        users, userCount, err := uc.data.GroupListUser(ctx, group, mode, offset, limit)
        if err != nil </span><span class="cov0" title="0">{
                uc.log.Errorf("data group list user error: %s", err.Error())
                return nil, 0, ErrorGroupListUserError("data group list user error, err: %s", err.Error())
        }</span>

        <span class="cov0" title="0">return users, userCount, nil</span>
}

func (uc *GroupUseCase) GroupAddGroup(ctx context.Context, group *dto.Group, subgroups []*dto.Group) error <span class="cov0" title="0">{
        uc.log.Debugf("GroupAddGroup, group: %+v, subgroups: %+v", group, subgroups)

        err := uc.data.GroupAddGroup(ctx, group, subgroups)
        if err != nil </span><span class="cov0" title="0">{
                uc.log.Errorf("data group add group error: %s", err.Error())
                return ErrorGroupAddGroupError("data group add group error, err: %s", err.Error())
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (uc *GroupUseCase) GroupDeleteGroup(ctx context.Context, group *dto.Group, subgroups []*dto.Group) error <span class="cov0" title="0">{
        uc.log.Debugf("GroupDeleteGroup, group: %+v, subgroups: %+v", group, subgroups)

        err := uc.data.GroupDeleteGroup(ctx, group, subgroups)
        if err != nil </span><span class="cov0" title="0">{
                uc.log.Errorf("data group delete group error: %s", err.Error())
                return ErrorGroupDeleteGroupError("data group delete group error, err: %s", err.Error())
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (uc *GroupUseCase) GroupListGroup(ctx context.Context, group *dto.Group, mode groupV1.RelationListMode,
        offset uint32, limit uint32) (
        []*dto.Group, uint32, error) <span class="cov0" title="0">{

        uc.log.Debugf("GroupListGroup, group: %+v, mode: %s, offset: %d, limit: %d", group, mode, offset, limit)

        groups, groupCount, err := uc.data.GroupListGroup(ctx, group, mode, offset, limit)
        if err != nil </span><span class="cov0" title="0">{
                uc.log.Errorf("data group list group error: %s", err.Error())
                return nil, 0, ErrorGroupListGroupError("data group list group error, err: %s", err.Error())
        }</span>

        <span class="cov0" title="0">return groups, groupCount, nil</span>
}
</pre>

		<pre class="file" id="file34" style="display: none">package biz

import (
        "context"

        "git.synology.inc/sast/access-system/server/web/internal/data"
        "git.synology.inc/sast/access-system/server/web/internal/datastore/dto"
        "github.com/go-kratos/kratos/v2/log"
)

//go:generate bash ../../../mock.sh

type IDPointUseCaseInterface interface {
        GetIDPoint(ctx context.Context, idPointID string) (*dto.IDPoint, error)
}

type IDPointUseCase struct {
        data data.DataInterface
        log  *log.Helper
}

func NewIDPointUseCase(d data.DataInterface, logger log.Logger) IDPointUseCaseInterface <span class="cov8" title="1">{
        return &amp;IDPointUseCase{data: d, log: log.NewHelper(logger)}
}</span>

func (uc *IDPointUseCase) GetIDPoint(ctx context.Context, idPointID string) (*dto.IDPoint, error) <span class="cov8" title="1">{
        uc.log.Debugf("GetIDPoint: %+v", idPointID)

        d, err := uc.data.GetIDPoint(ctx, idPointID)
        if err != nil </span><span class="cov8" title="1">{
                uc.log.Errorf("get id point error: %s", err.Error())
                return nil, ErrorGetIdPointError("failed to get id point, error: %s", err.Error())
        }</span>

        <span class="cov8" title="1">return d, nil</span>
}
</pre>

		<pre class="file" id="file35" style="display: none">package biz

import (
        "context"

        "git.synology.inc/sast/access-system/server/web/internal/data"
        "git.synology.inc/sast/access-system/server/web/internal/datastore/dto"
        "github.com/go-kratos/kratos/v2/log"
        "github.com/segmentio/ksuid"
)

//go:generate bash ../../../mock.sh

const (
        defaultLimit uint32 = 100
)

type ImportUseCaseInterface interface {
        ImportUser(ctx context.Context, action dto.ImportAction, userInfo *dto.ImportUserInfo) (string, dto.ImportResult,
                *dto.ImportErrorUserInfo, error)
}

type ImportUseCase struct {
        log                   *log.Helper
        data                  data.DataInterface
        userUseCase           UserUseCaseInterface
        userCredentialUseCase UserCredentialUseCaseInterface
        groupUseCase          GroupUseCaseInterface
}

func NewImportUseCase(logger log.Logger, d data.DataInterface, userUseCase UserUseCaseInterface,
        userCredentialUseCase UserCredentialUseCaseInterface, groupUseCase GroupUseCaseInterface) ImportUseCaseInterface <span class="cov0" title="0">{

        return &amp;ImportUseCase{
                log:                   log.NewHelper(logger),
                data:                  d,
                userUseCase:           userUseCase,
                userCredentialUseCase: userCredentialUseCase,
                groupUseCase:          groupUseCase,
        }
}</span>

func (uc *ImportUseCase) ImportUser(ctx context.Context, action dto.ImportAction, userInfo *dto.ImportUserInfo) (string,
        dto.ImportResult, *dto.ImportErrorUserInfo, error) <span class="cov0" title="0">{

        errorUserInfo := &amp;dto.ImportErrorUserInfo{
                TempID: userInfo.TempID,
        }

        // create or update user
        userID, importResult, err := uc.handleUser(ctx, action, userInfo, errorUserInfo)
        if err != nil </span><span class="cov0" title="0">{
                uc.log.Errorf("create user error: %s", err.Error())
                return "", dto.ImportResultError, errorUserInfo, err
        }</span>

        // created user credential
        <span class="cov0" title="0">err = uc.handleUserCredentialPin(ctx, importResult, userID, userInfo, errorUserInfo)
        if err != nil </span><span class="cov0" title="0">{
                uc.log.Errorf("create user credential pin error: %s", err.Error())
                return userID, dto.ImportResultError, errorUserInfo, err
        }</span>

        <span class="cov0" title="0">err = uc.handleUserCredentialCard(ctx, userID, userInfo, errorUserInfo)
        if err != nil </span><span class="cov0" title="0">{
                uc.log.Errorf("create user credential card error: %s", err.Error())
                return userID, dto.ImportResultError, errorUserInfo, err
        }</span>

        // create group
        <span class="cov0" title="0">err = uc.handleGroup(ctx, importResult, userID, userInfo, errorUserInfo)
        if err != nil </span><span class="cov0" title="0">{
                uc.log.Errorf("create group error: %s", err.Error())
                return userID, dto.ImportResultError, errorUserInfo, err
        }</span>

        <span class="cov0" title="0">return userID, importResult, nil, nil</span>
}

func (uc *ImportUseCase) handleUser(ctx context.Context, action dto.ImportAction, userInfo *dto.ImportUserInfo,
        errorUserInfo *dto.ImportErrorUserInfo) (string, dto.ImportResult, error) <span class="cov0" title="0">{

        // 1.       check user is existed
        // 1.a      if user is not existed, create new user
        // 1.b      if user is existed, check local user or dsm user
        // 1.b.1    if dsm user, can't update any user data
        // 1.b.2    if local user
        // 1.b.2.a  if action is skip, do nothing
        // 1.b.2.b  if action is overwrite, do create or update, can change all info except unique id

        // validation valid time, get user state
        validFromUnix, validUntilUnix, err := dto.MapUserValidDurations(dto.ImportTimeFormat,
                userInfo.ValidFrom, userInfo.ValidUntil)

        if err != nil </span><span class="cov0" title="0">{
                uc.log.Errorf("convert user valid durations error with valid from: %+v, valid until: %+v, error: %s",
                        userInfo.ValidFrom, userInfo.ValidUntil, err.Error())

                errorUserInfo.ValidFrom = dto.ImportErrorInternal
                errorUserInfo.ValidUntil = dto.ImportErrorInternal
                return "", dto.ImportResultError, ErrorImportFindUserError("add user failed to map valid durations: %v, %v, error: %s",
                        userInfo.ValidFrom, userInfo.ValidUntil, err.Error())
        }</span>

        <span class="cov0" title="0">userState := dto.GetUserStateFromValidTime(validFromUnix, validUntilUnix, dto.UserStateActivated)

        user, err := uc.userUseCase.GetUserByUniqueID(ctx, userInfo.UniqueID)
        if err != nil </span><span class="cov0" title="0">{
                errorUserInfo.UniqueID = dto.ImportErrorInternal
                return "", dto.ImportResultError, ErrorImportFindUserError("find user by unique id error: %s", err.Error())
        }</span>

        // create new user
        <span class="cov0" title="0">if user == nil </span><span class="cov0" title="0">{
                addUserReq := &amp;dto.User{
                        ID:             ksuid.New().String(),
                        UniqueID:       userInfo.UniqueID,
                        State:          userState,
                        Source:         dto.UserSourceLocal,
                        FirstName:      userInfo.FirstName,
                        LastName:       userInfo.LastName,
                        EMail:          userInfo.Email,
                        Description:    userInfo.Description,
                        ValidFrom:      validFromUnix,
                        ValidUntil:     validUntilUnix,
                        LongAccessTime: userInfo.LongAccessTime == Yes.String(),
                }

                userID, err := uc.userUseCase.AddUser(ctx, addUserReq)
                if err != nil </span><span class="cov0" title="0">{
                        uc.log.Errorf("data add user error: %s", err.Error())
                        errorUserInfo.UniqueID = dto.ImportErrorInternal
                        errorUserInfo.FirstName = dto.ImportErrorInternal
                        errorUserInfo.LastName = dto.ImportErrorInternal
                        errorUserInfo.Email = dto.ImportErrorInternal
                        errorUserInfo.Description = dto.ImportErrorInternal
                        errorUserInfo.ValidFrom = dto.ImportErrorInternal
                        errorUserInfo.ValidUntil = dto.ImportErrorInternal
                        errorUserInfo.LongAccessTime = dto.ImportErrorInternal
                        return "", dto.ImportResultError, ErrorImportAddUserError("data add user error, err: %s", err.Error())
                }</span>
                <span class="cov0" title="0">uc.log.Debugf("add user successfully, uid: %s", userInfo.UniqueID)

                return userID, dto.ImportResultCreate, nil</span>
        } else<span class="cov0" title="0"> {
                // update existed user, can only update local user
                if user.Source == dto.UserSourceLocal &amp;&amp; action == dto.ImportActionOverwrite </span><span class="cov0" title="0">{
                        longAccessTime := user.LongAccessTime
                        if userInfo.LongAccessTime != "" </span><span class="cov0" title="0">{
                                longAccessTime = userInfo.LongAccessTime == Yes.String()
                        }</span>

                        // update user
                        <span class="cov0" title="0">user.FirstName = userInfo.FirstName
                        user.LastName = userInfo.LastName
                        user.EMail = userInfo.Email
                        user.Description = userInfo.Description
                        user.State = userState
                        user.ValidFrom = validFromUnix
                        user.ValidUntil = validUntilUnix
                        user.LongAccessTime = longAccessTime

                        err = uc.userUseCase.UpdateUser(ctx, user)
                        if err != nil </span><span class="cov0" title="0">{
                                uc.log.Errorf("data update user error: %s", err.Error())
                                errorUserInfo.UniqueID = dto.ImportErrorInternal
                                errorUserInfo.FirstName = dto.ImportErrorInternal
                                errorUserInfo.LastName = dto.ImportErrorInternal
                                errorUserInfo.Email = dto.ImportErrorInternal
                                errorUserInfo.Description = dto.ImportErrorInternal
                                errorUserInfo.ValidFrom = dto.ImportErrorInternal
                                errorUserInfo.ValidUntil = dto.ImportErrorInternal
                                errorUserInfo.LongAccessTime = dto.ImportErrorInternal
                                return "", dto.ImportResultError, ErrorImportEditUserError("update user error, err: %s", err.Error())
                        }</span>
                        <span class="cov0" title="0">uc.log.Debugf("update user successfully, uid: %s", userInfo.UniqueID)

                        return user.ID, dto.ImportResultOverwrite, nil</span>
                } else<span class="cov0" title="0"> {
                        return user.ID, dto.ImportResultSkip, nil
                }</span>
        }
}

func (uc *ImportUseCase) handleUserCredentialPin(ctx context.Context, action dto.ImportResult, userID string,
        userInfo *dto.ImportUserInfo, errorUserInfo *dto.ImportErrorUserInfo) error <span class="cov0" title="0">{

        // 2.     depends on user import result
        // 2.a    if import result = skip, user exist and import action = skip
        // 2.b    if import result = overwrite, user exist and need to create or update credential
        // 2.c    if import result = create, user not exist, need to create credential

        // pin credential handling
        if action == dto.ImportResultSkip </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">if userInfo.PinCode != "" </span><span class="cov0" title="0">{
                // create or update user credential
                dataString, err := dto.UserCredentialDataEncodePin(userInfo.PinCode)
                if err != nil </span><span class="cov0" title="0">{
                        errorUserInfo.PinCode = dto.ImportErrorInternal
                        return ErrorImportEncodeUserCredentialDataError("encode pin error: %s", err.Error())
                }</span>

                <span class="cov0" title="0">pinCredential := &amp;dto.UserCredential{
                        ID:       ksuid.New().String(),
                        UniqueID: ksuid.New().String(),
                        UserID:   userID,
                        Type:     dto.UserCredentialTypePin,
                        Data:     dataString,
                }

                _, err = uc.userCredentialUseCase.AddUserCredential(ctx, pinCredential)
                if err != nil </span><span class="cov0" title="0">{
                        uc.log.Errorf("data add user credential error: %s", err.Error())
                        errorUserInfo.PinCode = dto.ImportErrorInternal
                        return ErrorImportAddUserCredentialError("add user credential error, err: %s", err.Error())
                }</span>

                <span class="cov0" title="0">uc.log.Debugf("user pin credential: %+v", pinCredential)</span>
        } else<span class="cov0" title="0"> {
                // delete existed credential
                credential, err := uc.userCredentialUseCase.GetUserCredentialPin(ctx, userID)
                if err != nil </span><span class="cov0" title="0">{
                        uc.log.Errorf("get user credential error: %s", err.Error())
                        errorUserInfo.PinCode = dto.ImportErrorInternal
                        return ErrorImportGetUserCredentialError("get user credential error, err: %s", err.Error())
                }</span>
                <span class="cov0" title="0">if credential != nil </span><span class="cov0" title="0">{
                        err = uc.userCredentialUseCase.DeleteUserCredential(ctx, credential.ID)
                        if err != nil </span><span class="cov0" title="0">{
                                uc.log.Errorf("delete user credential error: %s", err.Error())
                                errorUserInfo.PinCode = dto.ImportErrorInternal
                                return ErrorImportDeleteUserCredentialError("delete user credential error, err: %s", err.Error())
                        }</span>
                }
        }

        <span class="cov0" title="0">return nil</span>
}

func (uc *ImportUseCase) handleUserCredentialCard(ctx context.Context, userID string, userInfo *dto.ImportUserInfo,
        errorUserInfo *dto.ImportErrorUserInfo) error <span class="cov0" title="0">{

        // 3.a    check card credential by card number and facility code,
        //        if credential exist and userID != user.ID, not belongs to user himself
        // 3.b    already check card duplicate in import validation, just create card credential

        // card credential handling
        if userInfo.CardNumber != "" </span><span class="cov0" title="0">{
                dataString, err := dto.UserCredentialDataEncodeCard(userInfo.CardNumber, userInfo.FacilityCode)
                if err != nil </span><span class="cov0" title="0">{
                        errorUserInfo.CardNumber = dto.ImportErrorInternal
                        errorUserInfo.FacilityCode = dto.ImportErrorInternal
                        return ErrorImportEncodeUserCredentialDataError("encode card error: %s", err.Error())
                }</span>

                // check card duplicate
                <span class="cov0" title="0">existCredential, err := uc.userCredentialUseCase.GetUserCredentialCardByData(ctx, dataString)
                if err != nil </span><span class="cov0" title="0">{
                        uc.log.Errorf("get user card error: %s", err.Error())
                        return ErrorImportGetUserCredentialError("get user credential error, err: %s", err.Error())
                }</span>
                <span class="cov0" title="0">if existCredential != nil &amp;&amp; userID != existCredential.UserID </span><span class="cov0" title="0">{
                        uc.log.Errorf("card duplicated")
                        return ErrorImportDuplicateUserCredentialError("card duplicated")
                }</span>

                <span class="cov0" title="0">cardCredential := &amp;dto.UserCredential{
                        ID:       ksuid.New().String(),
                        UniqueID: ksuid.New().String(),
                        UserID:   userID,
                        Type:     dto.UserCredentialTypeCard,
                        Data:     dataString,
                }

                // add card credential
                _, err = uc.userCredentialUseCase.AddUserCredential(ctx, cardCredential)
                if err != nil </span><span class="cov0" title="0">{
                        uc.log.Errorf("data add user credential error: %s", err.Error())
                        errorUserInfo.CardNumber = dto.ImportErrorInternal
                        errorUserInfo.FacilityCode = dto.ImportErrorInternal
                        return ErrorImportAddUserCredentialError("add user credential error, err: %s", err.Error())
                }</span>

                <span class="cov0" title="0">uc.log.Debugf("user card credential: %+v", cardCredential)</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func (uc *ImportUseCase) handleGroup(ctx context.Context, action dto.ImportResult, userID string, userInfo *dto.ImportUserInfo,
        errorUserInfo *dto.ImportErrorUserInfo) error <span class="cov0" title="0">{

        // 3.     check local group is existed
        // 3.a    if existed, create user-group relation
        // 3.b    if not existed, create group and user-group relation
        // 3.c    remove group if not existed in group field

        uc.log.Infof("group handling action: %s", action)

        // if skip
        if action == dto.ImportResultSkip </span><span class="cov0" title="0">{
                return nil
        }</span>

        // arrange
        <span class="cov0" title="0">groupMap := make(map[string]string)
        current := uint32(0)
        offset := uint32(0)

        // get total
        _, total, err := uc.groupUseCase.ListGroupByUserID(ctx, userID, offset, defaultLimit)
        if err != nil </span><span class="cov0" title="0">{
                uc.log.Errorf("list group error: %s", err.Error())
                errorUserInfo.Groups = dto.ImportErrorInternal
                return ErrorImportListGroupError("list group error: %s", err.Error())
        }</span>

        // get user current groups
        <span class="cov0" title="0">for current &lt; total </span><span class="cov0" title="0">{
                groups, _, err := uc.groupUseCase.ListGroupByUserID(ctx, userID, offset, defaultLimit)
                if err != nil </span><span class="cov0" title="0">{
                        uc.log.Errorf("list group error: %s", err.Error())
                        errorUserInfo.Groups = dto.ImportErrorInternal
                        return ErrorImportListGroupError("list group error: %s", err.Error())
                }</span>

                <span class="cov0" title="0">for _, group := range groups </span><span class="cov0" title="0">{
                        groupMap[group.Name] = group.ID
                }</span>
                <span class="cov0" title="0">offset += defaultLimit
                current += uint32(len(groups))</span>
        }

        // flag delete group
        <span class="cov0" title="0">for _, groupName := range userInfo.Groups </span><span class="cov0" title="0">{
                groupID, ok := groupMap[groupName]
                uc.log.Debugf("group id: %s, group name: %s", groupID, groupName)
                if ok </span><span class="cov0" title="0">{
                        delete(groupMap, groupName)
                }</span> else<span class="cov0" title="0"> {
                        g, err := uc.groupUseCase.GetGroupByName(ctx, groupName, dto.GroupSourceLocal)
                        if err != nil </span><span class="cov0" title="0">{
                                uc.log.Errorf("get group error: %s", err.Error())
                                errorUserInfo.Groups = dto.ImportErrorInternal
                                return ErrorImportGetGroupError("get group error, err: %s", err.Error())
                        }</span>
                        <span class="cov0" title="0">if g == nil </span><span class="cov0" title="0">{
                                addGroupReq := &amp;dto.Group{
                                        ID:          ksuid.New().String(),
                                        UniqueID:    ksuid.New().String(),
                                        Source:      dto.GroupSourceLocal,
                                        Name:        groupName,
                                        Description: "",
                                }

                                groupID, err = uc.data.AddGroup(ctx, addGroupReq, []string{}, []string{})
                                if err != nil </span><span class="cov0" title="0">{
                                        uc.log.Errorf("data add group error: %s", err.Error())
                                        errorUserInfo.Groups = dto.ImportErrorInternal
                                        return ErrorImportAddGroupError("add group error, err: %s", err.Error())
                                }</span>
                        } else<span class="cov0" title="0"> {
                                groupID = g.ID
                        }</span>
                }

                // add group user relation
                <span class="cov0" title="0">err = uc.data.GroupAddUser(ctx, &amp;dto.Group{
                        ID: groupID,
                }, []*dto.User{
                        {
                                ID: userID,
                        },
                })

                if err != nil </span><span class="cov0" title="0">{
                        uc.log.Errorf("data add group error: %s", err.Error())
                        errorUserInfo.Groups = dto.ImportErrorInternal
                        return ErrorImportGroupAddUserError("group add user error, err: %s", err.Error())
                }</span>
        }

        // delete user group relation
        <span class="cov0" title="0">for groupName, groupID := range groupMap </span><span class="cov0" title="0">{
                uc.log.Debugf("delete group id: %s, group name: %s", groupID, groupName)
                err = uc.groupUseCase.GroupDeleteUser(ctx, &amp;dto.Group{ID: groupID}, []*dto.User{{ID: userID}})
                if err != nil </span><span class="cov0" title="0">{
                        uc.log.Errorf("delete user group error: %s", err.Error())
                        errorUserInfo.Groups = dto.ImportErrorInternal
                        return ErrorImportGroupDeleteUserError("delete user group error, err: %s", err.Error())
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}
</pre>

		<pre class="file" id="file36" style="display: none">package biz

import (
        "context"
        "net/mail"
        "regexp"
        "time"

        "git.synology.inc/sast/access-system/server/web/internal/datastore/dto"
)

//go:generate bash ../../../mock.sh

type TrueFalseQuestion string

func (f TrueFalseQuestion) String() string <span class="cov0" title="0">{
        return string(f)
}</span>

const (
        Yes TrueFalseQuestion = "yes"
        No  TrueFalseQuestion = "no"

        MaxCharacters = 64
        MinPinNumber  = 4
        MaxPinNumber  = 32
)

type ImportUserValidatorInterface interface {
        Validate(ctx context.Context, importAction dto.ImportAction, users []*dto.ImportUserInfo,
                photoFiles []string) ([]*dto.ImportErrorUserInfo, error)
}

type ImportUserValidator struct {
        userUseCase           UserUseCaseInterface
        userCredentialUseCase UserCredentialUseCaseInterface
}

func NewImportUserValidator(userUseCase UserUseCaseInterface, userCredentialUseCase UserCredentialUseCaseInterface,
) ImportUserValidatorInterface <span class="cov0" title="0">{

        return &amp;ImportUserValidator{
                userUseCase:           userUseCase,
                userCredentialUseCase: userCredentialUseCase,
        }
}</span>

func (s *ImportUserValidator) Validate(ctx context.Context, importAction dto.ImportAction, users []*dto.ImportUserInfo,
        photoFiles []string) ([]*dto.ImportErrorUserInfo, error) <span class="cov0" title="0">{

        errorUsers := make([]*dto.ImportErrorUserInfo, 0)

        // create photo file map
        photoFileMap := map[string]bool{}
        for _, file := range photoFiles </span><span class="cov0" title="0">{
                photoFileMap[file] = true
        }</span>

        <span class="cov0" title="0">userMap := map[string]bool{}
        cardDataMap := map[string]bool{}
        for _, user := range users </span><span class="cov0" title="0">{
                validationRes, err := s.validate(ctx, importAction, user, userMap, cardDataMap, photoFileMap)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">if validationRes != nil </span><span class="cov0" title="0">{
                        validationRes.TempID = user.TempID
                        errorUsers = append(errorUsers, validationRes)
                }</span>
        }

        <span class="cov0" title="0">return errorUsers, nil</span>
}

func (s *ImportUserValidator) validate(ctx context.Context, importAction dto.ImportAction, userInfo *dto.ImportUserInfo,
        userMap map[string]bool, cardDataMap map[string]bool, photoFileMap map[string]bool) (*dto.ImportErrorUserInfo, error) <span class="cov0" title="0">{

        hasError := false
        res := &amp;dto.ImportErrorUserInfo{}

        // validate unique id
        hasError, res.UniqueID = s.validateUniqueID(userInfo.UniqueID, userMap, hasError)

        user, err := s.userUseCase.GetUserByUniqueID(ctx, userInfo.UniqueID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, ErrorImportValidateGetUserByUniqueIdError("get user by unique id error: %s", err.Error())
        }</span>

        // only new user or overwrite action need to validate user data
        // user existed or skip action no need to validate
        <span class="cov0" title="0">if user == nil || importAction == dto.ImportActionOverwrite </span><span class="cov0" title="0">{
                // validate first name
                hasError, res.FirstName = s.validateRequiredString(userInfo.FirstName, hasError)

                // validate last name
                hasError, res.LastName = s.validateOptionalString(userInfo.LastName, hasError)

                // validate description
                hasError, res.Description = s.validateOptionalString(userInfo.Description, hasError)

                // validate email
                hasError, res.Email = s.validateEmail(userInfo.Email, hasError)

                // validate group
                hasError, res.Groups = s.validateGroup(userInfo.Groups, hasError)

                // validate expiration date, need to check start before than end
                hasError, res.ValidFrom = s.validateDate(userInfo.ValidFrom, hasError)
                hasError, res.ValidUntil = s.validateDate(userInfo.ValidUntil, hasError)

                // validate long access time
                hasError, res.LongAccessTime = s.validateYesNo(userInfo.LongAccessTime, hasError)

                // validate pin
                hasError, res.PinCode = s.validatePinCode(userInfo.PinCode, hasError)

                // validate photo file
                hasError, res.PhotoFileName = s.validatePhotoFile(userInfo.PhotoFileName, photoFileMap, hasError)
        }</span>

        // validate card number
        <span class="cov0" title="0">hasError, res.CardNumber = s.validateOptionalString(userInfo.CardNumber, hasError)

        // validate facility code
        hasError, res.FacilityCode = s.validateOptionalString(userInfo.FacilityCode, hasError)

        hasError, res, err = s.validateCard(ctx, user, userInfo, cardDataMap, hasError, res)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if hasError </span><span class="cov0" title="0">{
                return res, nil
        }</span> else<span class="cov0" title="0"> {
                return nil, nil
        }</span>
}

func (s *ImportUserValidator) validateUniqueID(input string, inputMap map[string]bool, hasError bool) (bool, dto.ImportError) <span class="cov0" title="0">{
        if input == "" </span><span class="cov0" title="0">{
                return true, dto.ImportErrorEmpty
        }</span>
        <span class="cov0" title="0">if len(input) &gt; MaxCharacters </span><span class="cov0" title="0">{
                return true, dto.ImportErrorMaxLength
        }</span>
        <span class="cov0" title="0">if _, ok := inputMap[input]; ok </span><span class="cov0" title="0">{
                return true, dto.ImportErrorDuplicate
        }</span>

        <span class="cov0" title="0">inputMap[input] = true

        return hasError, dto.ImportErrorOK</span>
}

func (s *ImportUserValidator) validateRequiredString(input string, hasError bool) (bool, dto.ImportError) <span class="cov0" title="0">{
        if input == "" </span><span class="cov0" title="0">{
                return true, dto.ImportErrorEmpty
        }</span>
        <span class="cov0" title="0">if len(input) &gt; MaxCharacters </span><span class="cov0" title="0">{
                return true, dto.ImportErrorMaxLength
        }</span>

        <span class="cov0" title="0">return hasError, dto.ImportErrorOK</span>
}

func (s *ImportUserValidator) validateOptionalString(input string, hasError bool) (bool, dto.ImportError) <span class="cov0" title="0">{
        if input == "" </span><span class="cov0" title="0">{
                return hasError, dto.ImportErrorOK
        }</span>
        <span class="cov0" title="0">if len(input) &gt; MaxCharacters </span><span class="cov0" title="0">{
                return true, dto.ImportErrorMaxLength
        }</span>

        <span class="cov0" title="0">return hasError, dto.ImportErrorOK</span>
}

func (s *ImportUserValidator) validateEmail(input string, hasError bool) (bool, dto.ImportError) <span class="cov0" title="0">{
        if input == "" </span><span class="cov0" title="0">{
                return hasError, dto.ImportErrorOK
        }</span>
        <span class="cov0" title="0">if _, err := mail.ParseAddress(input); err != nil </span><span class="cov0" title="0">{
                return true, dto.ImportErrorInvalidFormat
        }</span>

        <span class="cov0" title="0">return hasError, dto.ImportErrorOK</span>
}

func (s *ImportUserValidator) validateDate(input string, hasError bool) (bool, dto.ImportError) <span class="cov0" title="0">{
        if input == "" </span><span class="cov0" title="0">{
                return hasError, dto.ImportErrorOK
        }</span>

        <span class="cov0" title="0">_, err := time.Parse(dto.ImportTimeFormat, input)
        if err != nil </span><span class="cov0" title="0">{
                return true, dto.ImportErrorInvalidFormat
        }</span>

        <span class="cov0" title="0">return hasError, dto.ImportErrorOK</span>
}

func (s *ImportUserValidator) validateYesNo(input string, hasError bool) (bool, dto.ImportError) <span class="cov0" title="0">{
        if input == "" </span><span class="cov0" title="0">{
                return hasError, dto.ImportErrorOK
        }</span>
        <span class="cov0" title="0">if input != Yes.String() &amp;&amp; input != No.String() </span><span class="cov0" title="0">{
                return true, dto.ImportErrorInvalidFormat
        }</span>

        <span class="cov0" title="0">return hasError, dto.ImportErrorOK</span>
}

func (s *ImportUserValidator) validatePinCode(input string, hasError bool) (bool, dto.ImportError) <span class="cov0" title="0">{
        if input == "" </span><span class="cov0" title="0">{
                return hasError, dto.ImportErrorOK
        }</span>
        <span class="cov0" title="0">if len(input) &gt; MaxPinNumber </span><span class="cov0" title="0">{
                return true, dto.ImportErrorMaxLength
        }</span>
        <span class="cov0" title="0">if len(input) &lt; MinPinNumber </span><span class="cov0" title="0">{
                return true, dto.ImportErrorMinLength
        }</span>

        <span class="cov0" title="0">var re = regexp.MustCompile(`^\d+$`)
        if !re.MatchString(input) </span><span class="cov0" title="0">{
                return true, dto.ImportErrorInvalidFormat
        }</span>

        <span class="cov0" title="0">return hasError, dto.ImportErrorOK</span>
}

func (s *ImportUserValidator) validateCard(ctx context.Context, user *dto.User, userInfo *dto.ImportUserInfo, cardDataMap map[string]bool,
        hasError bool, res *dto.ImportErrorUserInfo) (bool, *dto.ImportErrorUserInfo, error) <span class="cov0" title="0">{

        // need to check card exist or not
        if userInfo.CardNumber != "" &amp;&amp; res.CardNumber == dto.ImportErrorOK &amp;&amp; res.FacilityCode == dto.ImportErrorOK </span><span class="cov0" title="0">{
                dataString, err := dto.UserCredentialDataEncodeCard(userInfo.CardNumber, userInfo.FacilityCode)
                if err != nil </span><span class="cov0" title="0">{
                        return true, nil, ErrorImportValidateUserCredentialTransferError("encode card data error: %s", err.Error())
                }</span>

                <span class="cov0" title="0">if _, ok := cardDataMap[dataString]; ok </span><span class="cov0" title="0">{
                        res.CardNumber = dto.ImportErrorDuplicate
                        res.FacilityCode = dto.ImportErrorDuplicate
                        return true, res, nil
                }</span>

                <span class="cov0" title="0">existCredential, err := s.userCredentialUseCase.GetUserCredentialCardByData(ctx, dataString)
                if err != nil </span><span class="cov0" title="0">{
                        return true, nil, ErrorImportValidateUserCredentialFindByDataError("get user card by data error: %s", err.Error())
                }</span>
                <span class="cov0" title="0">if existCredential != nil &amp;&amp; (user == nil || user.ID != existCredential.UserID) </span><span class="cov0" title="0">{
                        res.CardNumber = dto.ImportErrorDuplicate
                        res.FacilityCode = dto.ImportErrorDuplicate
                        return true, res, nil
                }</span>

                <span class="cov0" title="0">cardDataMap[dataString] = true</span>
        }

        <span class="cov0" title="0">return hasError, res, nil</span>
}

func (s *ImportUserValidator) validateGroup(groups []string, hasError bool) (bool, dto.ImportError) <span class="cov0" title="0">{
        if len(groups) == 0 </span><span class="cov0" title="0">{
                return hasError, dto.ImportErrorOK
        }</span>

        // arrange
        <span class="cov0" title="0">groupMap := make(map[string]bool)

        // validate group
        for _, group := range groups </span><span class="cov0" title="0">{
                if group == "" </span><span class="cov0" title="0">{
                        return true, dto.ImportErrorEmpty
                }</span> else<span class="cov0" title="0"> if _, ok := groupMap[group]; ok </span><span class="cov0" title="0">{
                        return true, dto.ImportErrorDuplicate
                }</span> else<span class="cov0" title="0"> {
                        groupMap[group] = true
                }</span>
        }

        // return group validation result
        <span class="cov0" title="0">return hasError, dto.ImportErrorOK</span>
}

func (s *ImportUserValidator) validatePhotoFile(input string, inputMap map[string]bool, hasError bool) (bool, dto.ImportError) <span class="cov0" title="0">{
        if input == "" </span><span class="cov0" title="0">{
                return hasError, dto.ImportErrorOK
        }</span>
        <span class="cov0" title="0">if _, ok := inputMap[input]; !ok </span><span class="cov0" title="0">{
                return true, dto.ImportErrorFileNotFound
        }</span>

        <span class="cov0" title="0">return hasError, dto.ImportErrorOK</span>
}
</pre>

		<pre class="file" id="file37" style="display: none">package biz

import (
        "context"

        "git.synology.inc/sast/access-system/server/web/internal/data"
        "git.synology.inc/sast/access-system/server/web/internal/datastore/dto"
        "github.com/go-kratos/kratos/v2/log"
)

//go:generate bash ../../../mock.sh

type ScheduleUseCaseInterface interface {
        AddSchedule(ctx context.Context, s *dto.Schedule) (string, error)
        UpdateSchedule(ctx context.Context, s *dto.Schedule) error
        DeleteSchedule(ctx context.Context, s *dto.Schedule) error
        GetSchedule(ctx context.Context, scheduleID string) (*dto.Schedule, error)
        ListSchedule(ctx context.Context, offset uint32, limit uint32) ([]*dto.ScheduleWithException, uint32, error)
        AddException(ctx context.Context, e *dto.Exception) (string, error)
        UpdateException(ctx context.Context, e *dto.Exception) error
        DeleteException(ctx context.Context, e *dto.Exception) error
        GetException(ctx context.Context, exceptionID string) (*dto.Exception, error)
        ListException(ctx context.Context, offset uint32, limit uint32) ([]*dto.Exception, uint32, error)
        ListExceptionBySchedule(ctx context.Context, scheduleID string, offset uint32,
                limit uint32) ([]*dto.ExceptionWithDailySchedule, uint32, error)
        ApplyException(ctx context.Context, scheduleID string, exceptionSchedules []*dto.ExceptionSchedule) error
}

type ScheduleUseCase struct {
        data data.DataInterface
        log  *log.Helper
}

func NewScheduleUseCase(d data.DataInterface, logger log.Logger) ScheduleUseCaseInterface <span class="cov8" title="1">{
        return &amp;ScheduleUseCase{data: d, log: log.NewHelper(logger)}
}</span>

func (uc *ScheduleUseCase) AddSchedule(ctx context.Context, s *dto.Schedule) (string, error) <span class="cov8" title="1">{
        uc.log.Debugf("AddSchedule: %+v", s)

        scheduleID, err := uc.data.AddSchedule(ctx, s)
        if err != nil </span><span class="cov8" title="1">{
                uc.log.Errorf("add schedule error: %s", err.Error())
                return "", ErrorAddScheduleError("failed to add schedule, error: %s", err.Error())
        }</span>

        <span class="cov8" title="1">return scheduleID, nil</span>
}

func (uc *ScheduleUseCase) UpdateSchedule(ctx context.Context, s *dto.Schedule) error <span class="cov8" title="1">{
        uc.log.Debugf("UpdateSchedule: %+v", s)

        err := uc.data.UpdateSchedule(ctx, s)
        if err != nil </span><span class="cov8" title="1">{
                uc.log.Errorf("update schedule error: %s", err.Error())
                return ErrorUpdateScheduleError("failed to update schedule, error: %s", err.Error())
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (uc *ScheduleUseCase) DeleteSchedule(ctx context.Context, s *dto.Schedule) error <span class="cov8" title="1">{
        uc.log.Debugf("DeleteSchedule: %+v", s)

        err := uc.data.DeleteSchedule(ctx, s)
        if err != nil </span><span class="cov8" title="1">{
                uc.log.Errorf("delete schedule error: %s", err.Error())
                return ErrorDeleteScheduleError("failed to delete schedule, error: %s", err.Error())
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (uc *ScheduleUseCase) GetSchedule(ctx context.Context, scheduleID string) (*dto.Schedule, error) <span class="cov8" title="1">{
        uc.log.Debugf("GetSchedule: %+v", scheduleID)

        s, err := uc.data.GetSchedule(ctx, scheduleID)
        if err != nil </span><span class="cov8" title="1">{
                uc.log.Errorf("get schedule error: %s", err.Error())
                return nil, ErrorGetScheduleError("failed to get schedule, error: %s", err.Error())
        }</span>

        <span class="cov8" title="1">return s, nil</span>
}

func (uc *ScheduleUseCase) ListSchedule(ctx context.Context, offset uint32, limit uint32) (
        []*dto.ScheduleWithException, uint32, error) <span class="cov8" title="1">{

        uc.log.Debugf("ListSchedule: offset = %+v, limit = %+v", offset, limit)

        scheduleWithException, total, err := uc.data.ListSchedule(ctx, offset, limit)
        if err != nil </span><span class="cov8" title="1">{
                uc.log.Errorf("list schedule error: %s", err.Error())
                return nil, 0, ErrorListScheduleError("failed to list schedule, error: %s", err.Error())
        }</span>

        <span class="cov8" title="1">return scheduleWithException, total, nil</span>
}

func (uc *ScheduleUseCase) AddException(ctx context.Context, e *dto.Exception) (string, error) <span class="cov8" title="1">{
        uc.log.Debugf("AddException: %+v", e)

        exceptionID, err := uc.data.AddException(ctx, e)
        if err != nil </span><span class="cov8" title="1">{
                uc.log.Errorf("add exception error: %s", err.Error())
                return "", ErrorAddExceptionError("failed to add exception, error: %s", err.Error())
        }</span>

        <span class="cov8" title="1">return exceptionID, nil</span>
}

func (uc *ScheduleUseCase) UpdateException(ctx context.Context, e *dto.Exception) error <span class="cov8" title="1">{
        uc.log.Debugf("UpdateException: %+v", e)

        err := uc.data.UpdateException(ctx, e)
        if err != nil </span><span class="cov8" title="1">{
                uc.log.Errorf("update exception error: %s", err.Error())
                return ErrorUpdateExceptionError("failed to update exception, error: %s", err.Error())
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (uc *ScheduleUseCase) DeleteException(ctx context.Context, e *dto.Exception) error <span class="cov8" title="1">{
        uc.log.Debugf("DeleteException: %+v", e)

        err := uc.data.DeleteException(ctx, e)
        if err != nil </span><span class="cov8" title="1">{
                uc.log.Errorf("delete exception error: %s", err.Error())
                return ErrorDeleteExceptionError("failed to delete exception, error: %s", err.Error())
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (uc *ScheduleUseCase) GetException(ctx context.Context, exceptionID string) (*dto.Exception, error) <span class="cov8" title="1">{
        uc.log.Debugf("GetException: %+v", exceptionID)

        e, err := uc.data.GetException(ctx, exceptionID)
        if err != nil </span><span class="cov8" title="1">{
                uc.log.Errorf("get exception error: %s", err.Error())
                return nil, ErrorGetExceptionError("failed to get exception, error: %s", err.Error())
        }</span>

        <span class="cov8" title="1">return e, nil</span>
}

func (uc *ScheduleUseCase) ListException(ctx context.Context, offset uint32, limit uint32) (
        []*dto.Exception, uint32, error) <span class="cov8" title="1">{

        uc.log.Debugf("ListException: offset = %+v, limit = %+v", offset, limit)

        exceptions, total, err := uc.data.ListException(ctx, offset, limit)
        if err != nil </span><span class="cov8" title="1">{
                uc.log.Errorf("list exception error: %s", err.Error())
                return nil, 0, ErrorListExceptionError("failed to list exception, error: %s", err.Error())
        }</span>

        <span class="cov8" title="1">return exceptions, total, nil</span>
}

func (uc *ScheduleUseCase) ListExceptionBySchedule(ctx context.Context, scheduleID string, offset uint32, limit uint32) (
        []*dto.ExceptionWithDailySchedule, uint32, error) <span class="cov8" title="1">{

        uc.log.Debugf("ListExceptionBySchedule: scheduleID = %+v, offset = %+v, limit = %+v", scheduleID, offset, limit)

        exceptions, total, err := uc.data.ListExceptionBySchedule(ctx, scheduleID, offset, limit)
        if err != nil </span><span class="cov8" title="1">{
                uc.log.Errorf("list exception by schedule error: %s", err.Error())
                return nil, 0, ErrorListExceptionByScheduleError("failed to list exception by schedule, error: %s", err.Error())
        }</span>

        <span class="cov8" title="1">return exceptions, total, nil</span>
}

func (uc *ScheduleUseCase) ApplyException(ctx context.Context, scheduleID string, exceptionSchedules []*dto.ExceptionSchedule) error <span class="cov8" title="1">{
        uc.log.Debugf("ApplyException: scheduleID = %+v, exceptionSchedules = %+v", scheduleID, exceptionSchedules)

        err := uc.data.ApplyException(ctx, scheduleID, exceptionSchedules)
        if err != nil </span><span class="cov8" title="1">{
                uc.log.Errorf("apply exception error: %s", err.Error())
                return ErrorApplyExceptionError("failed to apply exception, error: %s", err.Error())
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>

		<pre class="file" id="file38" style="display: none">package biz

import (
        "context"

        "git.synology.inc/sast/access-system/server/web/internal/data"
        "git.synology.inc/sast/access-system/server/web/internal/datastore"
        "git.synology.inc/sast/access-system/server/web/internal/datastore/dto"
        "github.com/go-kratos/kratos/v2/log"
)

//go:generate bash ../../../mock.sh

type UserUseCaseInterface interface {
        AddUser(ctx context.Context, user *dto.User) (string, error)
        UpdateUser(ctx context.Context, user *dto.User) error
        GetUser(ctx context.Context, userID string) (*dto.User, error)
        GetUserByUniqueID(ctx context.Context, uniqueID string) (*dto.User, error)
        DeleteUser(ctx context.Context, userID string) error
        ListUser(ctx context.Context, offset uint32, limit uint32) ([]*dto.User, uint32, error)
        ListAllUser(ctx context.Context) ([]*dto.User, error)
}

type UserUseCase struct {
        log  *log.Helper
        data data.DataInterface
}

func NewUserUseCase(logger log.Logger, d data.DataInterface) UserUseCaseInterface <span class="cov0" title="0">{
        return &amp;UserUseCase{
                log:  log.NewHelper(logger),
                data: d,
        }
}</span>

func (uc *UserUseCase) AddUser(ctx context.Context, user *dto.User) (string, error) <span class="cov0" title="0">{
        uc.log.Infof("AddUser: %+v", user)

        uid, err := uc.data.AddUser(ctx, user)
        if err != nil </span><span class="cov0" title="0">{
                uc.log.Errorf("data add user error: %s", err.Error())
                return "", ErrorAddUserError("data add user error, err: %s", err.Error())
        }</span>

        <span class="cov0" title="0">return uid, nil</span>
}

func (uc *UserUseCase) UpdateUser(ctx context.Context, user *dto.User) error <span class="cov0" title="0">{
        uc.log.Infof("UpdateUser: %+v", user)

        err := uc.data.UpdateUser(ctx, user)
        if err != nil </span><span class="cov0" title="0">{
                uc.log.Errorf("data update user error: %s", err.Error())
                return ErrorUpdateUserError("data update user error, err: %s", err.Error())
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (uc *UserUseCase) GetUser(ctx context.Context, userID string) (*dto.User, error) <span class="cov0" title="0">{
        uc.log.Infof("GetUser: %+v", userID)

        u, err := uc.data.GetUser(ctx, userID)
        if err != nil </span><span class="cov0" title="0">{
                uc.log.Errorf("data get user error: %s", err.Error())
                return nil, ErrorGetUserError("data get user error, err: %s", err.Error())
        }</span>

        <span class="cov0" title="0">return u, nil</span>
}

func (uc *UserUseCase) GetUserByUniqueID(ctx context.Context, uniqueID string) (*dto.User, error) <span class="cov0" title="0">{
        user, err := uc.data.GetUserByUniqueID(ctx, uniqueID)
        if err != nil </span><span class="cov0" title="0">{
                if datastore.IsUserNotFound(err) </span><span class="cov0" title="0">{
                        return nil, nil
                }</span> else<span class="cov0" title="0"> {
                        return nil, ErrorGetUserError("find user by unique id error: %s", err.Error())
                }</span>
        }

        <span class="cov0" title="0">return user, nil</span>
}

func (uc *UserUseCase) DeleteUser(ctx context.Context, userID string) error <span class="cov0" title="0">{
        uc.log.Infof("DeleteUser: %+v", userID)

        u, err := uc.data.GetUser(ctx, userID)
        if err != nil </span><span class="cov0" title="0">{
                uc.log.Errorf("data get user error: %s", err.Error())
                return ErrorGetUserError("get user before delete error, err: %s", err.Error())
        }</span>

        <span class="cov0" title="0">if u.Source == dto.UserSourceDSM </span><span class="cov0" title="0">{
                uc.log.Errorf("delete user error: DSM user can not be deleted")
                return ErrorDeleteUserError("DSM user can not be deleted")
        }</span>

        <span class="cov0" title="0">err = uc.data.DeleteUser(ctx, userID)
        if err != nil </span><span class="cov0" title="0">{
                uc.log.Errorf("data delete user error: %s", err.Error())
                return ErrorDeleteUserError("data delete user error, err: %s", err.Error())
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (uc *UserUseCase) ListUser(ctx context.Context, offset uint32, limit uint32) ([]*dto.User, uint32, error) <span class="cov0" title="0">{
        uc.log.Infof("ListUser, offset: %d, limit: %d", offset, limit)

        users, userCount, err := uc.data.ListUser(ctx, offset, limit)
        if err != nil </span><span class="cov0" title="0">{
                uc.log.Errorf("data list user error: %s", err.Error())
                return nil, 0, ErrorListUserError("data list user error, err: %s", err.Error())
        }</span>

        <span class="cov0" title="0">return users, userCount, nil</span>
}

// since offset and limit is `uint32`, passing offset / limit as -1 to query all users is not possible
// so we need to create a new method to list all users
func (uc *UserUseCase) ListAllUser(ctx context.Context) ([]*dto.User, error) <span class="cov0" title="0">{
        uc.log.Infof("ListAllUser")

        users, err := uc.data.ListAllUser(ctx)
        if err != nil </span><span class="cov0" title="0">{
                uc.log.Errorf("data list all user error: %s", err.Error())
                return nil, ErrorListUserError("data list all user error, err: %s", err.Error())
        }</span>

        <span class="cov0" title="0">return users, nil</span>
}
</pre>

		<pre class="file" id="file39" style="display: none">package biz

import (
        "context"

        "git.synology.inc/sast/access-system/server/web/internal/data"
        "git.synology.inc/sast/access-system/server/web/internal/datastore"
        "git.synology.inc/sast/access-system/server/web/internal/datastore/dto"
        "github.com/go-kratos/kratos/v2/log"
)

//go:generate bash ../../../mock.sh

type UserCredentialUseCaseInterface interface {
        AddUserCredential(ctx context.Context, userCredential *dto.UserCredential) (string, error)
        UpdateUserCredential(ctx context.Context, userCredential *dto.UserCredential) error
        GetUserCredential(ctx context.Context, userCredentialID string) (*dto.UserCredential, error)
        DeleteUserCredential(ctx context.Context, userCredentialID string) error
        ListUserCredential(ctx context.Context, userID string) ([]*dto.UserCredential, error)
        GetUserCredentialCardByData(ctx context.Context, data string) (*dto.UserCredential, error)
        GetUserCredentialPin(ctx context.Context, userID string) (*dto.UserCredential, error)
        SyncUserCredentialPin(ctx context.Context, userCredential *dto.UserCredential) (string, error)
}

type UserCredentialUseCase struct {
        log  *log.Helper
        data data.DataInterface
}

func NewUserCredentialUseCase(logger log.Logger, d data.DataInterface) UserCredentialUseCaseInterface <span class="cov8" title="1">{
        return &amp;UserCredentialUseCase{
                log:  log.NewHelper(logger),
                data: d,
        }
}</span>

func (uc *UserCredentialUseCase) AddUserCredential(ctx context.Context, userCredential *dto.UserCredential) (string, error) <span class="cov8" title="1">{
        uc.log.Debugf("AddUserCredential: %+v", userCredential)

        // check credential
        switch userCredential.Type </span>{
        case dto.UserCredentialTypeCard:<span class="cov0" title="0">
                // check credential existed
                existCredential, err := uc.GetUserCredentialCardByData(ctx, userCredential.Data)
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
                <span class="cov0" title="0">if existCredential != nil </span><span class="cov0" title="0">{
                        if existCredential.UserID == userCredential.UserID </span><span class="cov0" title="0">{
                                return existCredential.ID, nil
                        }</span> else<span class="cov0" title="0"> {
                                return "", ErrorAddUserCredentialError("add user credential error, user credential is exist")
                        }</span>
                }

                // add new credential
                <span class="cov0" title="0">uid, err := uc.data.AddUserCredential(ctx, userCredential)
                if err != nil </span><span class="cov0" title="0">{
                        uc.log.Errorf("data add user credential error: %s", err.Error())
                        return "", ErrorAddUserCredentialError("data add user credential error, err: %s", err.Error())
                }</span>

                <span class="cov0" title="0">return uid, nil</span>
        case dto.UserCredentialTypePin:<span class="cov8" title="1">
                uid, err := uc.SyncUserCredentialPin(ctx, userCredential)
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>

                <span class="cov8" title="1">return uid, nil</span>
        case dto.UserCredentialTypeUnknown:<span class="cov0" title="0">
                return "", ErrorAddUserCredentialError("unknown user credential")</span>
        }

        <span class="cov0" title="0">return "", ErrorAddUserCredentialError("unknown user credential")</span>
}

func (uc *UserCredentialUseCase) UpdateUserCredential(ctx context.Context, userCredential *dto.UserCredential) error <span class="cov8" title="1">{
        uc.log.Debugf("UpdateUserCredential: %+v", userCredential)

        // check credential
        switch userCredential.Type </span>{
        case dto.UserCredentialTypeCard:<span class="cov0" title="0">
                // check credential existed
                existCredential, err := uc.GetUserCredentialCardByData(ctx, userCredential.Data)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">if existCredential != nil </span><span class="cov0" title="0">{
                        if existCredential.UserID == userCredential.UserID </span><span class="cov0" title="0">{
                                return nil
                        }</span> else<span class="cov0" title="0"> {
                                return ErrorAddUserCredentialError("add user credential error, user credential is exist")
                        }</span>
                }

                // act
                <span class="cov0" title="0">err = uc.data.UpdateUserCredential(ctx, userCredential)
                if err != nil </span><span class="cov0" title="0">{
                        uc.log.Errorf("data update user credential error: %s", err.Error())
                        return ErrorUpdateUserCredentialError("data update user credential error, err: %s", err.Error())
                }</span>

                <span class="cov0" title="0">return nil</span>
        case dto.UserCredentialTypePin:<span class="cov8" title="1">
                _, err := uc.SyncUserCredentialPin(ctx, userCredential)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">return nil</span>
        case dto.UserCredentialTypeUnknown:<span class="cov0" title="0">
                return ErrorAddUserCredentialError("unknown user credential")</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func (uc *UserCredentialUseCase) GetUserCredential(ctx context.Context, userCredentialID string) (*dto.UserCredential, error) <span class="cov8" title="1">{
        uc.log.Debugf("GetUserCredential: %+v", userCredentialID)

        u, err := uc.data.GetUserCredential(ctx, userCredentialID)
        if err != nil </span><span class="cov0" title="0">{
                uc.log.Errorf("data get user credential error: %s", err.Error())
                return nil, ErrorGetUserCredentialError("data get user credential error, err: %s", err.Error())
        }</span>

        <span class="cov8" title="1">return u, nil</span>
}

func (uc *UserCredentialUseCase) DeleteUserCredential(ctx context.Context, userCredentialID string) error <span class="cov8" title="1">{
        uc.log.Debugf("DeleteUserCredential: %+v", userCredentialID)

        err := uc.data.DeleteUserCredential(ctx, userCredentialID)
        if err != nil </span><span class="cov0" title="0">{
                uc.log.Errorf("data delete user credential error: %s", err.Error())
                return ErrorDeleteUserCredentialError("data delete user credential error, err: %s", err.Error())
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (uc *UserCredentialUseCase) ListUserCredential(ctx context.Context, userID string) ([]*dto.UserCredential, error) <span class="cov8" title="1">{
        uc.log.Debugf("ListUserCredential")

        userCredentials, err := uc.data.ListUserCredential(ctx, userID)
        if err != nil </span><span class="cov0" title="0">{
                uc.log.Errorf("data list user credential error: %s", err.Error())
                return nil, ErrorListUserCredentialError("data list user credential error, err: %s", err.Error())
        }</span>

        <span class="cov8" title="1">return userCredentials, nil</span>
}

func (uc *UserCredentialUseCase) GetUserCredentialCardByData(ctx context.Context, d string) (*dto.UserCredential, error) <span class="cov0" title="0">{
        // need to check all user don't have this card
        existCredential, err := uc.data.GetUserCredentialCardByData(ctx, d)
        if err != nil </span><span class="cov0" title="0">{
                if datastore.IsUserCredentialNotFound(err) </span><span class="cov0" title="0">{
                        return nil, nil
                }</span> else<span class="cov0" title="0"> {
                        return nil, ErrorGetUserCredentialError("data get user credential error, err: %s", err.Error())
                }</span>
        }

        <span class="cov0" title="0">return existCredential, nil</span>
}

func (uc *UserCredentialUseCase) GetUserCredentialPin(ctx context.Context, userID string) (*dto.UserCredential, error) <span class="cov8" title="1">{
        existCredential, err := uc.data.GetUserCredentialPin(ctx, userID)
        if err != nil </span><span class="cov8" title="1">{
                if datastore.IsUserCredentialNotFound(err) </span><span class="cov8" title="1">{
                        return nil, nil
                }</span> else<span class="cov0" title="0"> {
                        return nil, ErrorGetUserCredentialError("data get user credential error, err: %s", err.Error())
                }</span>
        }
        <span class="cov8" title="1">return existCredential, nil</span>
}

func (uc *UserCredentialUseCase) SyncUserCredentialPin(ctx context.Context, userCredential *dto.UserCredential) (string, error) <span class="cov8" title="1">{
        // need to check current user don't have this pin code
        existCredential, err := uc.GetUserCredentialPin(ctx, userCredential.UserID)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov8" title="1">if existCredential == nil </span><span class="cov8" title="1">{
                // add new credential
                uid, err := uc.data.AddUserCredential(ctx, userCredential)
                if err != nil </span><span class="cov0" title="0">{
                        uc.log.Errorf("data add user credential error: %s", err.Error())
                        return "", ErrorSyncUserCredentialPinError("data add user credential error, err: %s", err.Error())
                }</span>

                <span class="cov8" title="1">return uid, nil</span>
        } else<span class="cov8" title="1"> {
                // update user credential
                existCredential.Data = userCredential.Data
                err = uc.data.UpdateUserCredential(ctx, existCredential)
                if err != nil </span><span class="cov0" title="0">{
                        uc.log.Errorf("data update user credential error: %s", err.Error())
                        return "", ErrorSyncUserCredentialPinError("data update user credential error, err: %s", err.Error())
                }</span>
                <span class="cov8" title="1">return existCredential.ID, nil</span>
        }
}
</pre>

		<pre class="file" id="file40" style="display: none">package biz

import (
        "context"

        "git.synology.inc/sast/access-system/server/web/internal/data"
        "git.synology.inc/sast/access-system/server/web/internal/datastore/dto"
        "github.com/go-kratos/kratos/v2/log"
)

//go:generate bash ../../../mock.sh

type ZoneUseCaseInterface interface {
        AddZone(ctx context.Context, z *dto.Zone) (string, error)
        UpdateZone(ctx context.Context, z *dto.Zone) error
        DeleteZone(ctx context.Context, z *dto.Zone) error
        GetZone(ctx context.Context, zoneID string) (*dto.Zone, error)
        ListZone(ctx context.Context, offset, limit uint32) ([]*dto.Zone, uint32, error)
        ZoneAddDoor(ctx context.Context, zoneID string, doorIDs []string) error
        ZoneDeleteDoor(ctx context.Context, zoneID string, doorIDs []string) error
        ZoneListDoor(ctx context.Context, zoneID string, offset, limit uint32) ([]*dto.Door, uint32, error)
}

type ZoneUseCase struct {
        data data.DataInterface
        log  *log.Helper
}

func NewZoneUseCase(d data.DataInterface, logger log.Logger) ZoneUseCaseInterface <span class="cov8" title="1">{
        return &amp;ZoneUseCase{data: d, log: log.NewHelper(logger)}
}</span>

func (uc *ZoneUseCase) AddZone(ctx context.Context, z *dto.Zone) (string, error) <span class="cov8" title="1">{
        uc.log.Debugf("AddZone: %+v", z)

        zoneID, err := uc.data.AddZone(ctx, z)
        if err != nil </span><span class="cov8" title="1">{
                uc.log.Errorf("add zone error: %s", err.Error())
                return "", ErrorAddZoneError("failed to add zone, error: %s", err.Error())
        }</span>

        <span class="cov8" title="1">return zoneID, nil</span>
}

func (uc *ZoneUseCase) UpdateZone(ctx context.Context, z *dto.Zone) error <span class="cov8" title="1">{
        uc.log.Debugf("UpdateZone: %+v", z)

        err := uc.data.UpdateZone(ctx, z)
        if err != nil </span><span class="cov8" title="1">{
                uc.log.Errorf("update zone error: %s", err.Error())
                return ErrorUpdateZoneError("failed to update zone, error: %s", err.Error())
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (uc *ZoneUseCase) DeleteZone(ctx context.Context, z *dto.Zone) error <span class="cov8" title="1">{
        uc.log.Debugf("DeleteZone: %+v", z)

        err := uc.data.DeleteZone(ctx, z)
        if err != nil </span><span class="cov8" title="1">{
                uc.log.Errorf("delete zone error: %s", err.Error())
                return ErrorDeleteZoneError("failed to delete zone, error: %s", err.Error())
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (uc *ZoneUseCase) GetZone(ctx context.Context, zoneID string) (*dto.Zone, error) <span class="cov8" title="1">{
        uc.log.Debugf("GetZone: %+v", zoneID)

        z, err := uc.data.GetZone(ctx, zoneID)
        if err != nil </span><span class="cov8" title="1">{
                uc.log.Errorf("get zone error: %s", err.Error())
                return nil, ErrorGetZoneError("failed to get zone, error: %s", err.Error())
        }</span>

        <span class="cov8" title="1">return z, nil</span>
}

func (uc *ZoneUseCase) ListZone(ctx context.Context, offset, limit uint32) ([]*dto.Zone, uint32, error) <span class="cov8" title="1">{
        uc.log.Debugf("ListZone: offset=%d, limit=%d", offset, limit)

        zones, total, err := uc.data.ListZone(ctx, offset, limit)
        if err != nil </span><span class="cov8" title="1">{
                uc.log.Errorf("list zone error: %s", err.Error())
                return nil, 0, ErrorListZoneError("failed to list zone, error: %s", err.Error())
        }</span>

        <span class="cov8" title="1">return zones, total, nil</span>
}

func (uc *ZoneUseCase) ZoneAddDoor(ctx context.Context, zoneID string, doorIDs []string) error <span class="cov8" title="1">{
        uc.log.Debugf("ZoneAddDoor: zoneID=%s, doorIDs=%v", zoneID, doorIDs)

        err := uc.data.ZoneAddDoor(ctx, zoneID, doorIDs)
        if err != nil </span><span class="cov8" title="1">{
                uc.log.Errorf("zone add door error: %s", err.Error())
                return ErrorZoneAddDoorError("failed to add door to zone, error: %s", err.Error())
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (uc *ZoneUseCase) ZoneDeleteDoor(ctx context.Context, zoneID string, doorIDs []string) error <span class="cov8" title="1">{
        uc.log.Debugf("ZoneDeleteDoor: zoneID=%s, doorIDs=%v", zoneID, doorIDs)

        err := uc.data.ZoneDeleteDoor(ctx, zoneID, doorIDs)
        if err != nil </span><span class="cov8" title="1">{
                uc.log.Errorf("zone delete door error: %s", err.Error())
                return ErrorZoneDeleteDoorError("failed to delete door from zone, error: %s", err.Error())
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (uc *ZoneUseCase) ZoneListDoor(ctx context.Context, zoneID string, offset, limit uint32) ([]*dto.Door, uint32, error) <span class="cov8" title="1">{
        uc.log.Debugf("ZoneListDoor: zoneID=%s, offset=%d, limit=%d", zoneID, offset, limit)

        doors, total, err := uc.data.ZoneListDoor(ctx, zoneID, offset, limit)
        if err != nil </span><span class="cov8" title="1">{
                uc.log.Errorf("zone list door error: %s", err.Error())
                return nil, 0, ErrorZoneListDoorError("failed to list door of zone, error: %s", err.Error())
        }</span>

        <span class="cov8" title="1">return doors, total, nil</span>
}
</pre>

		<pre class="file" id="file41" style="display: none">package service

import (
        "context"

        accessRuleV1 "git.synology.inc/sast/access-system/server/web/api/access_rule/v1"
        doorV1 "git.synology.inc/sast/access-system/server/web/api/door/v1"
        groupV1 "git.synology.inc/sast/access-system/server/web/api/group/v1"
        userV1 "git.synology.inc/sast/access-system/server/web/api/user/v1"
        zoneV1 "git.synology.inc/sast/access-system/server/web/api/zone/v1"
        "git.synology.inc/sast/access-system/server/web/internal/biz"
        "git.synology.inc/sast/access-system/server/web/internal/datastore/dto"
        "github.com/go-kratos/kratos/v2/log"
        "github.com/segmentio/ksuid"
        "google.golang.org/protobuf/types/known/emptypb"
)

type AccessRuleService struct {
        accessRuleV1.UnimplementedAccessRuleServer

        accessRuleUseCase biz.AccessRuleUseCaseInterface
        log               *log.Helper

        syncService SyncServiceInterface
}

func NewAccessRuleService(accessRuleUseCase biz.AccessRuleUseCaseInterface, logger log.Logger,
        syncService SyncServiceInterface) *AccessRuleService <span class="cov0" title="0">{

        return &amp;AccessRuleService{
                accessRuleUseCase: accessRuleUseCase,
                log:               log.NewHelper(logger),
                syncService:       syncService,
        }
}</span>

func (s *AccessRuleService) AddAccessRule(ctx context.Context, req *accessRuleV1.AddAccessRuleRequest) (
        *accessRuleV1.AddAccessRuleReply, error) <span class="cov0" title="0">{

        s.log.Debugf("AddAccessRule: %+v", req)

        accessRule := &amp;dto.AccessRule{
                ID:          ksuid.New().String(),
                Name:        req.GetBody().GetAccessRule().GetName(),
                Description: req.GetBody().GetAccessRule().GetDescription(),
                ScheduleID: func() string </span><span class="cov0" title="0">{
                        if id := req.GetBody().GetAccessRule().GetScheduleId(); id != "" </span><span class="cov0" title="0">{
                                return id
                        }</span>
                        <span class="cov0" title="0">return dto.AlwaysScheduleID</span>
                }(),
        }

        <span class="cov0" title="0">accessRuleID, err := s.accessRuleUseCase.AddAccessRule(ctx, accessRule,
                req.GetBody().GetUsers(), req.GetBody().GetGroups(), req.GetBody().GetDoors(), req.GetBody().GetZones())

        if err != nil </span><span class="cov0" title="0">{
                s.log.Errorf("add webDB access rule error: %s", err.Error())
                return nil, ErrorAddAccessRuleError("failed to add webDB access rule, error: %s", err.Error())
        }</span>

        <span class="cov0" title="0">err = s.syncService.SyncPostAddAccessRule(ctx, accessRule)
        if err != nil </span><span class="cov0" title="0">{
                s.log.Errorf("sync post add access rule error: %s", err.Error())
                return nil, ErrorAddAccessRuleError("failed to sync post add access rule, error: %s", err.Error())
        }</span>

        <span class="cov0" title="0">return &amp;accessRuleV1.AddAccessRuleReply{
                Id: accessRuleID,
        }, nil</span>
}

func (s *AccessRuleService) GetAccessRule(ctx context.Context, req *accessRuleV1.GetAccessRuleRequest) (
        *accessRuleV1.GetAccessRuleReply, error) <span class="cov0" title="0">{

        s.log.Debugf("GetAccessRule: %+v", req)

        accessRule, err := s.accessRuleUseCase.GetAccessRule(ctx, req.GetId())
        if err != nil </span><span class="cov0" title="0">{
                s.log.Errorf("get webDB access rule error: %s", err.Error())
                return nil, ErrorGetAccessRuleError("failed to get webDB access rule, error: %s", err.Error())
        }</span>

        <span class="cov0" title="0">pbAccessRule, err := accessRule.ToPbAccessRule()
        if err != nil </span><span class="cov0" title="0">{
                s.log.Errorf("get webDB access rule detail error: %s", err.Error())
                return nil, ErrorGetAccessRuleError("failed to get webDB access rule detail, error: %s", err.Error())
        }</span>

        <span class="cov0" title="0">return &amp;accessRuleV1.GetAccessRuleReply{
                AccessRule: pbAccessRule,
        }, nil</span>
}

func (s *AccessRuleService) UpdateAccessRule(ctx context.Context,
        req *accessRuleV1.UpdateAccessRuleRequest) (*emptypb.Empty, error) <span class="cov0" title="0">{

        s.log.Debugf("UpdateAccessRule: %+v", req)

        accessRule := &amp;dto.AccessRule{
                ID:          req.GetId(),
                Name:        req.GetBody().GetAccessRule().GetName(),
                Description: req.GetBody().GetAccessRule().GetDescription(),
                ScheduleID:  req.GetBody().GetAccessRule().GetScheduleId(),
        }

        err := s.accessRuleUseCase.UpdateAccessRule(ctx, accessRule,
                req.GetBody().GetUser().GetAdd(), req.GetBody().GetUser().GetDelete(),
                req.GetBody().GetGroup().GetAdd(), req.GetBody().GetGroup().GetDelete(),
                req.GetBody().GetDoor().GetAdd(), req.GetBody().GetDoor().GetDelete(),
                req.GetBody().GetZone().GetAdd(), req.GetBody().GetZone().GetDelete())

        if err != nil </span><span class="cov0" title="0">{
                s.log.Errorf("update webDB access rule error: %s", err.Error())
                return nil, ErrorUpdateAccessRuleError("failed to update webDB access rule, error: %s", err.Error())
        }</span>

        <span class="cov0" title="0">return &amp;emptypb.Empty{}, nil</span>
}

func (s *AccessRuleService) DeleteAccessRule(ctx context.Context,
        req *accessRuleV1.DeleteAccessRuleRequest) (*emptypb.Empty, error) <span class="cov0" title="0">{

        s.log.Debugf("DeleteAccessRule: %+v", req)

        accessRule, err := s.accessRuleUseCase.GetAccessRule(ctx, req.GetId())
        if err != nil </span><span class="cov0" title="0">{
                s.log.Errorf("get access rule error: %s", err.Error())
                return nil, ErrorDeleteAccessRuleError("failed to get access rule, error: %s", err.Error())
        }</span>

        <span class="cov0" title="0">err = s.accessRuleUseCase.DeleteAccessRule(ctx, req.GetId())
        if err != nil </span><span class="cov0" title="0">{
                s.log.Errorf("delete webDB access rule error: %s", err.Error())
                return nil, ErrorDeleteAccessRuleError("failed to delete webDB access rule, error: %s", err.Error())
        }</span>

        <span class="cov0" title="0">err = s.syncService.SyncPostDeleteAccessRule(ctx, accessRule)
        if err != nil </span><span class="cov0" title="0">{
                s.log.Errorf("sync post access rule add door error: %s", err.Error())
                return nil, ErrorDeleteAccessRuleError("failed to sync post delete access rule, error: %s", err.Error())
        }</span>

        <span class="cov0" title="0">return &amp;emptypb.Empty{}, nil</span>
}

func (s *AccessRuleService) ListAccessRule(ctx context.Context, req *accessRuleV1.ListAccessRuleRequest) (
        *accessRuleV1.ListAccessRuleReply, error) <span class="cov0" title="0">{

        s.log.Debugf("ListAccessRule: %+v", req)

        accessRules, total, err := s.accessRuleUseCase.ListAccessRule(ctx, req.GetOffset(), req.GetLimit())
        if err != nil </span><span class="cov0" title="0">{
                s.log.Errorf("list webDB access rule error: %s", err.Error())
                return nil, ErrorListAccessRuleError("failed to list webDB access rule, error: %s", err.Error())
        }</span>

        <span class="cov0" title="0">pbAccessRules := make([]*accessRuleV1.AccessRuleInfoDetailed, 0, len(accessRules))
        for _, accessRule := range accessRules </span><span class="cov0" title="0">{
                pbAccessRule, err := accessRule.ToPbAccessRule()
                if err != nil </span><span class="cov0" title="0">{
                        s.log.Errorf("get webDB access rule detail error: %s", err.Error())
                        return nil, ErrorGetAccessRuleError("failed to get webDB access rule detail, error: %s", err.Error())
                }</span>
                <span class="cov0" title="0">pbAccessRules = append(pbAccessRules, pbAccessRule)</span>
        }

        <span class="cov0" title="0">return &amp;accessRuleV1.ListAccessRuleReply{
                AccessRules: pbAccessRules,
                Total:       total,
        }, nil</span>
}

/* User */
func (s *AccessRuleService) AccessRuleAddUser(ctx context.Context, req *accessRuleV1.AccessRuleAddUserRequest) (*emptypb.Empty, error) <span class="cov0" title="0">{
        targetAccessRule := &amp;dto.AccessRule{
                ID: req.GetId(),
        }

        err := s.accessRuleUseCase.AccessRuleAddUser(ctx, targetAccessRule, req.GetBody().GetUsers())
        if err != nil </span><span class="cov0" title="0">{
                s.log.Errorf("access rule add user failed due to use case access rule add user error: %s", err.Error())
                return nil, ErrorAccessRuleAddUserError("access rule add user failed due to use case access rule add user error: %s", err.Error())
        }</span>

        <span class="cov0" title="0">err = s.syncService.SyncPostAccessRuleAddUser(ctx, req.GetId(), req.GetBody().GetUsers())
        if err != nil </span><span class="cov0" title="0">{
                s.log.Errorf("sync post access rule add user error: %s", err.Error())
                return nil, ErrorAccessRuleAddUserError("failed to sync post access rule add user, error: %s", err.Error())
        }</span>

        <span class="cov0" title="0">return &amp;emptypb.Empty{}, nil</span>
}

func (s *AccessRuleService) AccessRuleDeleteUser(ctx context.Context, req *accessRuleV1.AccessRuleDeleteUserRequest) (
        *emptypb.Empty, error) <span class="cov0" title="0">{

        targetAccessRule := &amp;dto.AccessRule{
                ID: req.GetId(),
        }
        users := make([]*dto.User, 0, len(req.GetUsers()))
        for _, userID := range req.GetUsers() </span><span class="cov0" title="0">{
                users = append(users, &amp;dto.User{
                        ID: userID,
                })
        }</span>

        <span class="cov0" title="0">err := s.accessRuleUseCase.AccessRuleDeleteUser(ctx, targetAccessRule, users)
        if err != nil </span><span class="cov0" title="0">{
                s.log.Errorf("access rule delete user failed due to use case access rule delete user error: %s", err.Error())
                return nil, ErrorAccessRuleDeleteUserError("access rule delete user failed due to use case access rule delete user error: %s",
                        err.Error())
        }</span>

        <span class="cov0" title="0">err = s.syncService.SyncPostAccessRuleDeleteUser(ctx, req.GetId(), req.GetUsers())
        if err != nil </span><span class="cov0" title="0">{
                s.log.Errorf("failed to sync post access rule delete user, error: %s", err.Error())
                return nil, ErrorAccessRuleDeleteUserError("failed to sync post access rule delete user, error: %s", err.Error())
        }</span>

        <span class="cov0" title="0">return &amp;emptypb.Empty{}, nil</span>
}

func (s *AccessRuleService) AccessRuleListUser(ctx context.Context, req *accessRuleV1.AccessRuleListUserRequest,
) (*accessRuleV1.AccessRuleListUserReply, error) <span class="cov0" title="0">{

        offset := req.GetOffset()
        limit := req.GetLimit()

        users, userCount, err := s.accessRuleUseCase.AccessRuleListUser(ctx, req.GetId(), offset, limit)
        if err != nil </span><span class="cov0" title="0">{
                s.log.Errorf("access rule list user failed due to use case access rule list user error: %s", err.Error())
                return nil, ErrorListAccessRuleError("access rule list user failed due to use case access rule list user error: %s", err.Error())
        }</span>

        <span class="cov0" title="0">pbUsers := &amp;accessRuleV1.AccessRuleListUserReply{
                Users: make([]*userV1.UserInfo, 0, len(users)),
                Total: userCount,
        }
        for _, user := range users </span><span class="cov0" title="0">{
                pbUser, err := user.ToPbUser()
                if err != nil </span><span class="cov0" title="0">{
                        s.log.Errorf("access rule list user convert user to pb user error: %s", err.Error())
                        return nil, ErrorListAccessRuleError("access rule list user convert user to pb user error: %s", err.Error())
                }</span>
                <span class="cov0" title="0">pbUsers.Users = append(pbUsers.Users, pbUser)</span>
        }

        <span class="cov0" title="0">return pbUsers, nil</span>
}

/* Group */
func (s *AccessRuleService) AccessRuleAddGroup(ctx context.Context, req *accessRuleV1.AccessRuleAddGroupRequest) (*emptypb.Empty, error) <span class="cov0" title="0">{
        targetAccessRule := &amp;dto.AccessRule{
                ID: req.GetId(),
        }

        err := s.accessRuleUseCase.AccessRuleAddGroup(ctx, targetAccessRule, req.GetBody().GetGroups())
        if err != nil </span><span class="cov0" title="0">{
                s.log.Errorf("access rule add group failed due to use case access rule add group error: %s", err.Error())
                return nil, ErrorAccessRuleAddGroupError("access rule add group failed due to use case access rule add group error: %s", err.Error())
        }</span>

        <span class="cov0" title="0">return &amp;emptypb.Empty{}, nil</span>
}

func (s *AccessRuleService) AccessRuleDeleteGroup(ctx context.Context, req *accessRuleV1.AccessRuleDeleteGroupRequest) (
        *emptypb.Empty, error) <span class="cov0" title="0">{

        targetAccessRule := &amp;dto.AccessRule{
                ID: req.GetId(),
        }
        groups := make([]*dto.Group, 0, len(req.GetGroups()))
        for _, groupID := range req.GetGroups() </span><span class="cov0" title="0">{
                groups = append(groups, &amp;dto.Group{
                        ID: groupID,
                })
        }</span>

        <span class="cov0" title="0">err := s.accessRuleUseCase.AccessRuleDeleteGroup(ctx, targetAccessRule, groups)
        if err != nil </span><span class="cov0" title="0">{
                s.log.Errorf("access rule delete group failed due to use case access rule delete group error: %s", err.Error())
                return nil, ErrorAccessRuleDeleteGroupError("access rule delete group failed due to use case access rule delete group error: %s",
                        err.Error())
        }</span>

        <span class="cov0" title="0">return &amp;emptypb.Empty{}, nil</span>
}

func (s *AccessRuleService) AccessRuleListGroup(ctx context.Context, req *accessRuleV1.AccessRuleListGroupRequest,
) (*accessRuleV1.AccessRuleListGroupReply, error) <span class="cov0" title="0">{

        offset := req.GetOffset()
        limit := req.GetLimit()

        groups, groupCount, err := s.accessRuleUseCase.AccessRuleListGroup(ctx, req.GetId(), offset, limit)
        if err != nil </span><span class="cov0" title="0">{
                s.log.Errorf("access rule list group failed due to use case access rule list group error: %s", err.Error())
                return nil, ErrorAccessRuleListGroupError("access rule list group failed due to use case access rule list group error: %s", err.Error())
        }</span>

        <span class="cov0" title="0">pbGroups := &amp;accessRuleV1.AccessRuleListGroupReply{
                Groups: make([]*groupV1.GroupInfo, 0, len(groups)),
                Total:  groupCount,
        }
        for _, group := range groups </span><span class="cov0" title="0">{
                pbGroup, err := group.ToPbGroup()
                if err != nil </span><span class="cov0" title="0">{
                        s.log.Errorf("access rule list group convert group to pb group error: %s", err.Error())
                        return nil, ErrorAccessRuleListGroupError("access rule list group convert group to pb group error: %s", err.Error())
                }</span>
                <span class="cov0" title="0">pbGroups.Groups = append(pbGroups.Groups, pbGroup)</span>
        }

        <span class="cov0" title="0">return pbGroups, nil</span>
}

/* Door */
func (s *AccessRuleService) AccessRuleAddDoor(ctx context.Context, req *accessRuleV1.AccessRuleAddDoorRequest) (*emptypb.Empty, error) <span class="cov0" title="0">{
        targetAccessRule := &amp;dto.AccessRule{
                ID: req.GetId(),
        }

        err := s.accessRuleUseCase.AccessRuleAddDoor(ctx, targetAccessRule, req.GetBody().GetDoors())
        if err != nil </span><span class="cov0" title="0">{
                s.log.Errorf("access rule add door failed due to use case access rule add door error: %s", err.Error())
                return nil, ErrorAccessRuleAddDoorError("access rule add door failed due to use case access rule add door error: %s", err.Error())
        }</span>

        <span class="cov0" title="0">err = s.syncService.SyncPostAccessRuleAddDoor(ctx, req.GetId(), req.GetBody().GetDoors())
        if err != nil </span><span class="cov0" title="0">{
                s.log.Errorf("sync post access rule add door error: %s", err.Error())
                return nil, ErrorAccessRuleAddDoorError("failed to sync post access rule add door, error: %s", err.Error())
        }</span>

        <span class="cov0" title="0">return &amp;emptypb.Empty{}, nil</span>
}

func (s *AccessRuleService) AccessRuleDeleteDoor(ctx context.Context, req *accessRuleV1.AccessRuleDeleteDoorRequest) (
        *emptypb.Empty, error) <span class="cov0" title="0">{

        targetAccessRule := &amp;dto.AccessRule{
                ID: req.GetId(),
        }
        doors := make([]*dto.Door, 0, len(req.GetDoors()))
        for _, doorID := range req.GetDoors() </span><span class="cov0" title="0">{
                doors = append(doors, &amp;dto.Door{
                        ID: doorID,
                })
        }</span>

        <span class="cov0" title="0">err := s.accessRuleUseCase.AccessRuleDeleteDoor(ctx, targetAccessRule, doors)
        if err != nil </span><span class="cov0" title="0">{
                s.log.Errorf("access rule delete door failed due to use case access rule delete door error: %s", err.Error())
                return nil, ErrorAccessRuleDeleteDoorError("access rule delete door failed due to use case access rule delete door error: %s",
                        err.Error())
        }</span>

        <span class="cov0" title="0">err = s.syncService.SyncPostAccessRuleDeleteDoor(ctx, req.GetId(), req.GetDoors())
        if err != nil </span><span class="cov0" title="0">{
                s.log.Errorf("failed to sync post access rule delete door, error: %s", err.Error())
                return nil, ErrorAccessRuleDeleteDoorError("failed to sync post access rule delete door, error: %s", err.Error())
        }</span>

        <span class="cov0" title="0">return &amp;emptypb.Empty{}, nil</span>
}

func (s *AccessRuleService) AccessRuleListDoor(ctx context.Context, req *accessRuleV1.AccessRuleListDoorRequest,
) (*accessRuleV1.AccessRuleListDoorReply, error) <span class="cov0" title="0">{

        offset := req.GetOffset()
        limit := req.GetLimit()

        doors, doorCount, err := s.accessRuleUseCase.AccessRuleListDoor(ctx, req.GetId(), offset, limit)
        if err != nil </span><span class="cov0" title="0">{
                s.log.Errorf("access rule list door failed due to use case access rule list door error: %s", err.Error())
                return nil, ErrorAccessRuleListDoorError("access rule list door failed due to use case access rule list door error: %s", err.Error())
        }</span>

        <span class="cov0" title="0">pbDoors := &amp;accessRuleV1.AccessRuleListDoorReply{
                Doors: make([]*doorV1.DoorInfo, 0, len(doors)),
                Total: doorCount,
        }
        for _, door := range doors </span><span class="cov0" title="0">{
                pbDoor := door.ToPbDoor()
                pbDoors.Doors = append(pbDoors.Doors, pbDoor)
        }</span>

        <span class="cov0" title="0">return pbDoors, nil</span>
}

/* Zone */
func (s *AccessRuleService) AccessRuleAddZone(ctx context.Context, req *accessRuleV1.AccessRuleAddZoneRequest) (*emptypb.Empty, error) <span class="cov0" title="0">{
        targetAccessRule := &amp;dto.AccessRule{
                ID: req.GetId(),
        }

        err := s.accessRuleUseCase.AccessRuleAddZone(ctx, targetAccessRule, req.GetBody().GetZones())
        if err != nil </span><span class="cov0" title="0">{
                s.log.Errorf("access rule add zone failed due to use case access rule add zone error: %s", err.Error())
                return nil, ErrorAccessRuleAddZoneError("access rule add zone failed due to use case access rule add zone error: %s", err.Error())
        }</span>

        <span class="cov0" title="0">return &amp;emptypb.Empty{}, nil</span>
}

func (s *AccessRuleService) AccessRuleDeleteZone(ctx context.Context, req *accessRuleV1.AccessRuleDeleteZoneRequest) (
        *emptypb.Empty, error) <span class="cov0" title="0">{

        targetAccessRule := &amp;dto.AccessRule{
                ID: req.GetId(),
        }
        zones := make([]*dto.Zone, 0, len(req.GetZones()))
        for _, zoneID := range req.GetZones() </span><span class="cov0" title="0">{
                zones = append(zones, &amp;dto.Zone{
                        ID: zoneID,
                })
        }</span>

        <span class="cov0" title="0">err := s.accessRuleUseCase.AccessRuleDeleteZone(ctx, targetAccessRule, zones)
        if err != nil </span><span class="cov0" title="0">{
                s.log.Errorf("access rule delete zone failed due to use case access rule delete zone error: %s", err.Error())
                return nil, ErrorAccessRuleDeleteZoneError("access rule delete zone failed due to use case access rule delete zone error: %s",
                        err.Error())
        }</span>

        <span class="cov0" title="0">return &amp;emptypb.Empty{}, nil</span>
}

func (s *AccessRuleService) AccessRuleListZone(ctx context.Context, req *accessRuleV1.AccessRuleListZoneRequest,
) (*accessRuleV1.AccessRuleListZoneReply, error) <span class="cov0" title="0">{

        offset := req.GetOffset()
        limit := req.GetLimit()

        zones, zoneCount, err := s.accessRuleUseCase.AccessRuleListZone(ctx, req.GetId(), offset, limit)
        if err != nil </span><span class="cov0" title="0">{
                s.log.Errorf("access rule list zone failed due to use case access rule list zone error: %s", err.Error())
                return nil, ErrorAccessRuleListZoneError("access rule list zone failed due to use case access rule list zone error: %s", err.Error())
        }</span>

        <span class="cov0" title="0">pbZones := &amp;accessRuleV1.AccessRuleListZoneReply{
                Zones: make([]*zoneV1.ZoneInfo, 0, len(zones)),
                Total: zoneCount,
        }
        for _, zone := range zones </span><span class="cov0" title="0">{
                pbZone := zone.ToPbZone()
                pbZones.Zones = append(pbZones.Zones, pbZone)
        }</span>

        <span class="cov0" title="0">return pbZones, nil</span>
}
</pre>

		<pre class="file" id="file42" style="display: none">package service

import (
        "context"

        agentV1 "git.synology.inc/sast/access-system/server/web/api/agent/v1"
        "git.synology.inc/sast/access-system/server/web/internal/biz"
        "github.com/go-kratos/kratos/v2/log"
)

//go:generate bash ../../../mock.sh

type AgentServiceInterface interface {
        GetAgent(ctx context.Context, req *agentV1.GetAgentRequest) (*agentV1.GetAgentReply, error)
        ListAgent(ctx context.Context, req *agentV1.ListAgentRequest) (*agentV1.ListAgentReply, error)
}

type AgentService struct {
        agentV1.UnimplementedAgentServer

        agentUseCase biz.AgentUseCaseInterface
        log          *log.Helper
}

func NewAgentService(agentUseCase biz.AgentUseCaseInterface, logger log.Logger) AgentServiceInterface <span class="cov8" title="1">{
        return &amp;AgentService{
                agentUseCase: agentUseCase,
                log:          log.NewHelper(logger),
        }
}</span>

func (s *AgentService) GetAgent(ctx context.Context, req *agentV1.GetAgentRequest) (*agentV1.GetAgentReply, error) <span class="cov8" title="1">{
        agent, err := s.agentUseCase.GetAgent(ctx, req.GetId())
        if err != nil </span><span class="cov8" title="1">{
                s.log.Errorf("get agent[%s] error: %s", req.GetId(), err.Error())
                return nil, ErrorGetAgentError("failed to get agent[%s], error: %s", req.GetId(), err.Error())
        }</span>

        <span class="cov8" title="1">return &amp;agentV1.GetAgentReply{
                Agent: agent.ToPbAgent(),
        }, nil</span>
}

func (s *AgentService) ListAgent(ctx context.Context, req *agentV1.ListAgentRequest) (*agentV1.ListAgentReply, error) <span class="cov8" title="1">{
        // Act
        agents, total, err := s.agentUseCase.ListAgent(ctx, req.Offset, req.Limit)
        if err != nil </span><span class="cov8" title="1">{
                s.log.Errorf("list agent error: %s", err.Error())
                return nil, ErrorListAgentError("failed to list agent, error: %s", err.Error())
        }</span>

        // Result mapping
        <span class="cov8" title="1">pbAgents := &amp;agentV1.ListAgentReply{
                Total:  total,
                Agents: make([]*agentV1.AgentInfo, 0, len(agents)),
        }
        for _, agent := range agents </span><span class="cov8" title="1">{
                pbAgents.Agents = append(pbAgents.Agents, agent.ToPbAgent())
        }</span>

        <span class="cov8" title="1">return pbAgents, nil</span>
}
</pre>

		<pre class="file" id="file43" style="display: none">package service

import (
        "context"
        "time"

        discoveryClient "git.synology.inc/sast/access-system/server/discovery/client"
        gatewayControllerV1 "git.synology.inc/sast/access-system/server/gateway/api/controller/v1"
        gatewayOperationV1 "git.synology.inc/sast/access-system/server/gateway/api/operation/v1"
        controllerV1 "git.synology.inc/sast/access-system/server/web/api/controller/v1"
        "git.synology.inc/sast/access-system/server/web/internal/biz"
        "git.synology.inc/sast/access-system/server/web/internal/conf"
        "git.synology.inc/sast/access-system/server/web/internal/datastore/dto"
        "github.com/go-kratos/kratos/v2/log"
        "github.com/segmentio/ksuid"
        "google.golang.org/protobuf/types/known/emptypb"
)

type ControllerService struct {
        controllerV1.UnimplementedControllerServer

        discoveryService  DiscoveryServiceInterface
        controllerUseCase biz.ControllerUseCaseInterface
        syncService       SyncServiceInterface
        agentUseCase      biz.AgentUseCaseInterface
        log               *log.Helper
        c                 *conf.Controller
}

func NewControllerService(c *conf.Controller, controllerUseCase biz.ControllerUseCaseInterface,
        agentUseCase biz.AgentUseCaseInterface, syncService SyncServiceInterface,
        discoveryService DiscoveryServiceInterface, logger log.Logger) *ControllerService <span class="cov8" title="1">{

        return &amp;ControllerService{
                discoveryService:  discoveryService,
                controllerUseCase: controllerUseCase,
                syncService:       syncService,
                agentUseCase:      agentUseCase,
                log:               log.NewHelper(logger),
                c:                 c,
        }
}</span>

func (s *ControllerService) waitForNextRetry(ctx context.Context) error <span class="cov0" title="0">{
        timer := time.NewTimer(s.c.GetPullAccesspointInterval().AsDuration())
        defer timer.Stop()

        select </span>{
        case &lt;-ctx.Done():<span class="cov0" title="0">
                s.log.Info("operation canceled")
                return ctx.Err()</span>
        case &lt;-timer.C:<span class="cov0" title="0">
                return nil</span>
        }
}

func (s *ControllerService) patchAccessPoints(conn *discoveryClient.GatewayConnection, agentUniqueID string,
        controllerUniqueID string) *gatewayOperationV1.ListAccessPointsReply <span class="cov8" title="1">{

        listAccessPointsCtx, cancel := context.WithTimeout(context.Background(),
                s.c.GetPullAccesspointTimeout().AsDuration())
        defer cancel()

        accessPointsReply, err := conn.Operation.ListAccessPoints(listAccessPointsCtx,
                &amp;gatewayOperationV1.ListAccessPointsRequest{
                        AgentId:      agentUniqueID,
                        ControllerId: controllerUniqueID,
                })

        if err != nil </span><span class="cov0" title="0">{
                s.log.Errorf("list access points from agent error: %s", err.Error())
                return nil
        }</span>

        // controller without door not allowed
        <span class="cov8" title="1">if len(accessPointsReply.GetDoors()) &gt; 0 </span><span class="cov8" title="1">{
                return accessPointsReply
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (s *ControllerService) getAccessPoints(conn *discoveryClient.GatewayConnection,
        agent *dto.Agent, controllerUniqueID string) (*gatewayOperationV1.ListAccessPointsReply, error) <span class="cov8" title="1">{

        maxRetry := s.c.GetPullAccesspointMaxRetry()
        if maxRetry &lt;= 0 </span><span class="cov8" title="1">{
                maxRetry = 0
        }</span>

        <span class="cov8" title="1">for retryCount := uint32(0); retryCount &lt;= maxRetry; retryCount++ </span><span class="cov8" title="1">{
                s.log.Debugf("list access points with retry, retry count: %d", retryCount)

                if reply := s.patchAccessPoints(conn, agent.UniqueID, controllerUniqueID); reply != nil </span><span class="cov8" title="1">{
                        return reply, nil
                }</span>

                <span class="cov0" title="0">if retryCount == maxRetry </span><span class="cov0" title="0">{
                        s.log.Error("list access points failed after max retry, change controller to disconnected state in web DB")
                        return nil, ErrorListAccessPointsError("list access points failed after max retry")
                }</span>

                // Even if the API call is canceled, the access points will still need to be updated
                <span class="cov0" title="0">if err := s.waitForNextRetry(context.Background()); err != nil </span><span class="cov0" title="0">{
                        s.log.Errorf("retry wait canceled: %s", err.Error())
                        return nil, ErrorListAccessPointsError("list access points failed due to API call canceled")
                }</span>
        }

        /* unreachable */
        <span class="cov0" title="0">return nil, nil</span>
}

func (s *ControllerService) AddController(ctx context.Context,
        req *controllerV1.AddControllerRequest) (*controllerV1.AddControllerReply, error) <span class="cov8" title="1">{

        agent, err := s.agentUseCase.GetAgent(ctx, req.GetAgent())
        if err != nil </span><span class="cov8" title="1">{
                s.log.Errorf("failed to get agent[%s], error: %s", req.GetAgent(), err.Error())
                return nil, ErrorAddControllerError("failed to get agent[%s], error: %s", req.GetAgent(), err.Error())
        }</span>

        <span class="cov8" title="1">conn, err := s.discoveryService.Get(agent.UniqueID)
        if err != nil </span><span class="cov8" title="1">{
                s.log.Errorf("failed to get gateway connection: %s for agent %s, uniqueID: %s", err.Error(), agent.ID, agent.UniqueID)
                return nil, ErrorCanNotGetGatewayConnection(
                        "failed to get gateway connection: %s for agent %s, uniqueID: %s", err.Error(), agent.ID, agent.UniqueID)
        }</span>

        <span class="cov8" title="1">controllerUniqueID := ksuid.New().String()
        reply, err := conn.Controller.AddController(ctx, &amp;gatewayControllerV1.AddControllerRequest{
                AgentId:  agent.UniqueID,
                Id:       controllerUniqueID,
                Ip:       req.GetBody().GetIp(),
                Model:    req.GetBody().GetModel(),
                Name:     req.GetBody().GetName(),
                Vendor:   req.GetBody().GetVendor(),
                Account:  req.GetBody().GetAccount(),
                Password: req.GetBody().GetPassword(),
        })
        if err != nil </span><span class="cov0" title="0">{
                s.log.Errorf("add controller to agent error: %s", err.Error())
                return nil, ErrorAddControllerError("failed to add controller to agent, error: %s", err.Error())
        }</span>

        <span class="cov8" title="1">if reply.GetId() != controllerUniqueID </span><span class="cov0" title="0">{
                s.log.Errorf("add controller to agent error: uniqueID and controllerID not match")
                return nil, ErrorAddControllerError("failed to add controller to agent, uniqueID and controllerID not match")
        }</span>

        // determine current controller state with list access points result
        <span class="cov8" title="1">controllerState := dto.ControllerStateConnected

        accessPoints, err := s.getAccessPoints(conn, agent, controllerUniqueID)
        if err != nil </span><span class="cov0" title="0">{
                controllerState = dto.ControllerStateDisconnected
        }</span>

        <span class="cov8" title="1">addController := &amp;dto.Controller{
                ID:       ksuid.New().String(),
                UniqueID: controllerUniqueID,
                AgentID:  agent.ID,
                IP:       req.GetBody().GetIp(),
                Vendor:   req.GetBody().GetVendor(),
                Model:    req.GetBody().GetModel(),
                Name:     req.GetBody().GetName(),
                State:    controllerState,
        }
        addController.Doors, addController.IDPoints = addController.AccessPointsToDoorsIDPoints(accessPoints)

        id, err := s.controllerUseCase.AddController(ctx, addController)
        if err != nil </span><span class="cov8" title="1">{
                s.log.Errorf("add webDB controller error: %s", err.Error())
                return nil, ErrorAddControllerError("failed to add webDB controller, error: %s", err.Error())
        }</span>

        <span class="cov8" title="1">err = s.syncService.SyncPostAddController(ctx, addController)
        if err != nil </span><span class="cov8" title="1">{
                s.log.Errorf("sync post add controller error: %s", err.Error())
                return nil, ErrorAddControllerError("failed to sync post add controller, error: %s", err.Error())
        }</span>

        <span class="cov8" title="1">return &amp;controllerV1.AddControllerReply{
                Id: id,
        }, nil</span>
}

func (s *ControllerService) UpdateController(ctx context.Context,
        req *controllerV1.UpdateControllerRequest) (*emptypb.Empty, error) <span class="cov8" title="1">{

        controller, err := s.controllerUseCase.GetController(context.Background(), req.GetId())
        if err != nil </span><span class="cov8" title="1">{
                s.log.Errorf("get webDB controller error: %s", err.Error())
                return nil, ErrorGetControllerError("failed to get webDB controller, error: %s", err.Error())
        }</span>

        <span class="cov8" title="1">if req.GetAgent() != controller.AgentID </span><span class="cov8" title="1">{
                s.log.Errorf("validate agent error: controller agentID not match")
                return nil, ErrorValidateAgentError("validate agent error: controller agentID not match")
        }</span>

        <span class="cov8" title="1">agent, err := s.agentUseCase.GetAgent(ctx, req.GetAgent())
        if err != nil </span><span class="cov8" title="1">{
                s.log.Errorf("failed to get agent[%s], error: %s", req.GetAgent(), err.Error())
                return nil, ErrorUpdateControllerError("failed to get agent[%s], error: %s", req.GetAgent(), err.Error())
        }</span>

        <span class="cov8" title="1">conn, err := s.discoveryService.Get(agent.UniqueID)
        if err != nil </span><span class="cov8" title="1">{
                s.log.Errorf("failed to get gateway connection: %s for agent %s, uniqueID: %s", err.Error(), agent.ID, agent.UniqueID)
                return nil, ErrorCanNotGetGatewayConnection(
                        "failed to get gateway connection: %s for agent %s, uniqueID: %s", err.Error(), agent.ID, agent.UniqueID)
        }</span>

        <span class="cov8" title="1">_, err = conn.Controller.UpdateController(ctx, &amp;gatewayControllerV1.UpdateControllerRequest{
                AgentId:  agent.UniqueID,
                Id:       controller.UniqueID,
                Ip:       req.GetBody().GetIp(),
                Model:    req.GetBody().GetModel(),
                Name:     req.GetBody().GetName(),
                Vendor:   req.GetBody().GetVendor(),
                Account:  req.GetBody().GetAccount(),
                Password: req.GetBody().GetPassword(),
        })
        if err != nil </span><span class="cov0" title="0">{
                s.log.Errorf("update controller to agent error: %s", err.Error())
                return nil, ErrorUpdateControllerError("failed to update controller to agent, error: %s", err.Error())
        }</span>

        // determine current controller state with list access points result
        <span class="cov8" title="1">controllerState := dto.ControllerStateConnected

        accessPoints, err := s.getAccessPoints(conn, agent, controller.UniqueID)
        if err != nil </span><span class="cov0" title="0">{
                controllerState = dto.ControllerStateDisconnected
        }</span>

        <span class="cov8" title="1">updateController := &amp;dto.Controller{
                ID:     req.GetId(),
                IP:     req.GetBody().GetIp(),
                Vendor: req.GetBody().GetVendor(),
                Model:  req.GetBody().GetModel(),
                Name:   req.GetBody().GetName(),
                State:  controllerState,
        }
        updateController.Doors, updateController.IDPoints = updateController.AccessPointsToDoorsIDPoints(accessPoints)

        err = s.controllerUseCase.UpdateController(ctx, updateController)
        if err != nil </span><span class="cov8" title="1">{
                s.log.Errorf("update webDB controller error: %s", err.Error())
                return nil, ErrorUpdateControllerError("failed to update webDB controller, error: %s", err.Error())
        }</span>

        <span class="cov8" title="1">return &amp;emptypb.Empty{}, nil</span>
}

func (s *ControllerService) DeleteController(ctx context.Context,
        req *controllerV1.DeleteControllerRequest) (*emptypb.Empty, error) <span class="cov8" title="1">{

        controller, err := s.controllerUseCase.GetController(context.Background(), req.GetId())
        if err != nil </span><span class="cov8" title="1">{
                s.log.Errorf("get webDB controller error: %s", err.Error())
                return nil, ErrorGetControllerError("failed to get webDB controller, error: %s", err.Error())
        }</span>

        <span class="cov8" title="1">if req.GetAgent() != controller.AgentID </span><span class="cov8" title="1">{
                s.log.Errorf("validate agent error: controller agentID not match")
                return nil, ErrorValidateAgentError("validate agent error: controller agentID not match")
        }</span>

        <span class="cov8" title="1">agent, err := s.agentUseCase.GetAgent(ctx, req.GetAgent())
        if err != nil </span><span class="cov8" title="1">{
                s.log.Errorf("failed to get agent[%s], error: %s", req.GetAgent(), err.Error())
                return nil, ErrorDeleteControllerError("failed to get agent[%s], error: %s", req.GetAgent(), err.Error())
        }</span>

        <span class="cov8" title="1">conn, err := s.discoveryService.Get(agent.UniqueID)
        if err != nil </span><span class="cov8" title="1">{
                s.log.Errorf("failed to get gateway connection: %s for agent %s, uniqueID: %s", err.Error(), agent.ID, agent.UniqueID)
                return nil, ErrorCanNotGetGatewayConnection(
                        "failed to get gateway connection: %s for agent %s, uniqueID: %s", err.Error(), agent.ID, agent.UniqueID)
        }</span>

        <span class="cov8" title="1">_, err = conn.Controller.DeleteController(ctx, &amp;gatewayControllerV1.DeleteControllerRequest{
                Id:      controller.UniqueID,
                AgentId: agent.UniqueID,
        })
        if err != nil </span><span class="cov0" title="0">{
                s.log.Errorf("delete controller to agent error: %s", err.Error())
                return nil, ErrorDeleteControllerError("failed to delete controller to agent, error: %s", err.Error())
        }</span>

        <span class="cov8" title="1">deleteController := &amp;dto.Controller{
                ID:      req.GetId(),
                AgentID: req.GetAgent(),
        }

        err = s.controllerUseCase.DeleteController(ctx, deleteController)
        if err != nil </span><span class="cov8" title="1">{
                s.log.Errorf("delete webDB controller error: %s", err.Error())
                return nil, ErrorDeleteControllerError("failed to delete webDB controller, error: %s", err.Error())
        }</span>

        <span class="cov8" title="1">return &amp;emptypb.Empty{}, nil</span>
}

func (s *ControllerService) GetController(ctx context.Context,
        req *controllerV1.GetControllerRequest) (*controllerV1.GetControllerReply, error) <span class="cov8" title="1">{

        controller, err := s.controllerUseCase.GetController(ctx, req.GetId())
        if err != nil </span><span class="cov8" title="1">{
                s.log.Errorf("get webDB controller error: %s", err.Error())
                return nil, ErrorGetControllerError("failed to get webDB controller, error: %s", err.Error())
        }</span>

        <span class="cov8" title="1">if req.GetAgent() != controller.AgentID </span><span class="cov8" title="1">{
                s.log.Errorf("validate agent error: controller agentID not match")
                return nil, ErrorValidateAgentError("validate agent error: controller agentID not match")
        }</span>

        <span class="cov8" title="1">return &amp;controllerV1.GetControllerReply{
                Controller: controller.ToPbController(),
        }, nil</span>
}

func (s *ControllerService) ListControllerByAgentID(ctx context.Context,
        req *controllerV1.ListControllerByAgentIDRequest) (*controllerV1.ListControllerByAgentIDReply, error) <span class="cov8" title="1">{

        controllers, total, err := s.controllerUseCase.ListControllerByAgentID(ctx,
                req.GetAgent(), req.GetOffset(), req.GetLimit(), req.GetDoor(), req.GetIdPoint())
        if err != nil </span><span class="cov8" title="1">{
                s.log.Errorf("list webDB controllers error: %s", err.Error())
                return nil, ErrorListControllerError("failed to list webDB controllers, error: %s", err.Error())
        }</span>

        <span class="cov8" title="1">reply := &amp;controllerV1.ListControllerByAgentIDReply{
                Total:       total,
                Controllers: make([]*controllerV1.ControllerInfo, len(controllers)),
        }
        for i, controller := range controllers </span><span class="cov8" title="1">{
                reply.Controllers[i] = controller.ToPbController()
        }</span>

        <span class="cov8" title="1">return reply, nil</span>
}

func (s *ControllerService) ListDoorByController(ctx context.Context,
        req *controllerV1.ListDoorByControllerRequest) (*controllerV1.ListDoorByControllerReply, error) <span class="cov8" title="1">{

        s.log.Debugf("ListDoorByController: %+v", req)

        controller, err := s.controllerUseCase.GetController(context.Background(), req.GetController())
        if err != nil </span><span class="cov8" title="1">{
                s.log.Errorf("get webDB controller error: %s", err.Error())
                return nil, ErrorGetControllerError("failed to get webDB controller, error: %s", err.Error())
        }</span>

        <span class="cov8" title="1">if req.GetAgent() != controller.AgentID </span><span class="cov8" title="1">{
                s.log.Errorf("validate agent error: controller agentID not match")
                return nil, ErrorValidateAgentError("validate agent error: controller agentID not match")
        }</span>

        <span class="cov8" title="1">doors, total, err := s.controllerUseCase.ListDoorByController(ctx, req.GetController())
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">reply := &amp;controllerV1.ListDoorByControllerReply{
                Total: total,
                Doors: make([]*controllerV1.DoorInfo, len(doors)),
        }
        for i, door := range doors </span><span class="cov8" title="1">{
                reply.Doors[i] = door.ToPbControllerDoor()
        }</span>

        <span class="cov8" title="1">return reply, nil</span>
}

func (s *ControllerService) ListIDPointByController(ctx context.Context,
        req *controllerV1.ListIDPointByControllerRequest) (*controllerV1.ListIDPointByControllerReply, error) <span class="cov8" title="1">{

        s.log.Debugf("ListIDPointByController: %+v", req)

        controller, err := s.controllerUseCase.GetController(context.Background(), req.GetController())
        if err != nil </span><span class="cov8" title="1">{
                s.log.Errorf("get webDB controller error: %s", err.Error())
                return nil, ErrorGetControllerError("failed to get webDB controller, error: %s", err.Error())
        }</span>

        <span class="cov8" title="1">if req.GetAgent() != controller.AgentID </span><span class="cov8" title="1">{
                s.log.Errorf("validate agent error: controller agentID not match")
                return nil, ErrorValidateAgentError("validate agent error: controller agentID not match")
        }</span>

        <span class="cov8" title="1">idPoints, total, err := s.controllerUseCase.ListIDPointByController(ctx, req.GetController())
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">reply := &amp;controllerV1.ListIDPointByControllerReply{
                Total:    total,
                IdPoints: make([]*controllerV1.IDPointInfo, len(idPoints)),
        }
        for i, idPoint := range idPoints </span><span class="cov8" title="1">{
                reply.IdPoints[i] = idPoint.ToPbControllerIDPoint()
        }</span>

        <span class="cov8" title="1">return reply, nil</span>
}
</pre>

		<pre class="file" id="file44" style="display: none">package service

import (
        discoveryClient "git.synology.inc/sast/access-system/server/discovery/client"
        "git.synology.inc/sast/access-system/server/web/internal/conf"
        "github.com/go-kratos/kratos/v2/log"
)

//go:generate bash ../../../mock.sh

type DiscoveryServiceInterface interface {
        Get(agentID string) (*discoveryClient.GatewayConnection, error)
}

type DiscoveryService struct {
        client discoveryClient.Client

        logger *log.Helper
}

func NewDiscoveryService(externalConfig *conf.External, serverConfig *conf.Server,
        logger log.Logger) (DiscoveryServiceInterface, func(), error) <span class="cov0" title="0">{

        var client discoveryClient.Client
        var cleanup func()
        var err error

        logHelper := log.NewHelper(logger)

        switch externalConfig.GetDiscovery().GetDiscovery().(type) </span>{
        case *conf.Discovery_Static_:<span class="cov0" title="0">
                logHelper.Info("start a static discovery client")
                config := externalConfig.GetDiscovery().GetStatic()

                client, cleanup, err = discoveryClient.NewStaticGatewayClient()
                client.(*discoveryClient.StaticDiscoveryClient).SetStaticGRPCServer(
                        &amp;discoveryClient.GatewayInfo{
                                Protocol: config.GetGateway().GetProtocol(),
                                Addr:     config.GetGateway().GetAddr(),
                                Timeout:  config.GetGateway().GetTimeout().GetSeconds(),
                                CertFile: config.GetGateway().GetCertFile(),
                        },
                )</span>
        case *conf.Discovery_Grpc:<span class="cov0" title="0">
                config := externalConfig.GetDiscovery().GetGrpc()
                logHelper.Infof("start a dynamic discovery client with %+v ", config)

                client, cleanup, err = discoveryClient.NewDynamicGatewayGRPCClient(
                        &amp;discoveryClient.ExternalDiscoveryGRPCConf{
                                Protocol: config.GetProtocol(),
                                Address:  config.GetAddr(),
                                CertFile: config.GetCertFile(),
                        },
                )</span>
        case *conf.Discovery_Http:<span class="cov0" title="0">
                config := externalConfig.GetDiscovery().GetHttp()
                logHelper.Infof("start a dynamic discovery client with %+v ", config)

                client, cleanup, err = discoveryClient.NewDynamicGatewayHTTPClient(
                        &amp;discoveryClient.ExternalDiscoveryHTTPConf{
                                Addr:    config.GetAddr(),
                                Timeout: config.GetTimeout().GetSeconds(),
                        },
                )</span>
        default:<span class="cov0" title="0">
                err = ErrorCanNotCreateDiscoveryClient(
                        "unknown discovery type, failed to create discovery client: %+v", externalConfig.GetDiscovery())</span>
        }

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                logHelper.Errorf("failed to create discovery client: %s", err.Error())
                return nil, nil, ErrorCanNotCreateDiscoveryClient(
                        "failed to create discovery client: %s", err.Error())
        }</span>
        <span class="cov0" title="0">if client == nil </span><span class="cov0" title="0">{
                logHelper.Error("failed to create discovery client: client is nil")
                return nil, nil, ErrorCanNotCreateDiscoveryClient(
                        "failed to create discovery client: %s", "client is nil")
        }</span>

        <span class="cov0" title="0">return &amp;DiscoveryService{
                        client: client,
                        logger: logHelper,
                }, func() </span><span class="cov0" title="0">{
                        cleanup()
                }</span>, err
}

func (s *DiscoveryService) Get(agentID string) (*discoveryClient.GatewayConnection, error) <span class="cov0" title="0">{
        conn, err := s.client.Get(agentID)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Errorf("failed to get connection: %s", err.Error())
                return nil, ErrorCanNotGetGatewayConnection(
                        "failed to get connection: %s", err.Error())
        }</span>

        <span class="cov0" title="0">return conn, nil</span>
}
</pre>

		<pre class="file" id="file45" style="display: none">package service

import (
        "context"

        doorV1 "git.synology.inc/sast/access-system/server/web/api/door/v1"
        "git.synology.inc/sast/access-system/server/web/internal/biz"
        "git.synology.inc/sast/access-system/server/web/internal/datastore/dto"
        "github.com/go-kratos/kratos/v2/log"
)

type DoorService struct {
        doorV1.UnimplementedDoorServer

        doorUseCase       biz.DoorUseCaseInterface
        controllerUseCase biz.ControllerUseCaseInterface
        log               *log.Helper
}

func NewDoorService(doorUseCase biz.DoorUseCaseInterface, controllerUseCase biz.ControllerUseCaseInterface,
        logger log.Logger) *DoorService <span class="cov8" title="1">{

        return &amp;DoorService{
                doorUseCase:       doorUseCase,
                controllerUseCase: controllerUseCase,
                log:               log.NewHelper(logger),
        }
}</span>

func (s *DoorService) UpdateDoor(ctx context.Context, req *doorV1.UpdateDoorRequest) (*doorV1.UpdateDoorReply, error) <span class="cov8" title="1">{
        s.log.Infof("UpdateDoor: %+v", req)

        // TODO: need to update the door on physical controller

        door, err := s.doorUseCase.GetDoor(context.Background(), req.GetId())
        if err != nil </span><span class="cov8" title="1">{
                s.log.Errorf("get webDB door error: %s", err.Error())
                return nil, ErrorGetDoorError("failed to get webDB door, error: %s", err.Error())
        }</span>

        <span class="cov8" title="1">if req.GetController() != door.ControllerID </span><span class="cov8" title="1">{
                s.log.Errorf("validate controller error: door ControllerID not match")
                return nil, ErrorValidateDoorError("validate controller error: door ControllerID not match")
        }</span>

        <span class="cov8" title="1">controller, err := s.controllerUseCase.GetController(context.Background(), door.ControllerID)
        if err != nil </span><span class="cov8" title="1">{
                s.log.Errorf("get webDB controller error: %s", err.Error())
                return nil, ErrorGetControllerError("failed to get webDB controller, error: %s", err.Error())
        }</span>

        <span class="cov8" title="1">if req.GetAgent() != controller.AgentID </span><span class="cov8" title="1">{
                s.log.Errorf("validate agent error: door agentID not match")
                return nil, ErrorValidateDoorError("validate agent error: door agentID not match")
        }</span>

        <span class="cov8" title="1">updateDoor := &amp;dto.Door{
                ID:           door.ID,
                ControllerID: door.ControllerID,
                Name:         req.GetBody().GetName(),
        }

        err = s.doorUseCase.UpdateDoor(context.Background(), updateDoor)
        if err != nil </span><span class="cov8" title="1">{
                s.log.Errorf("update webDB door error: %s", err.Error())
                return nil, ErrorUpdateDoorError("failed to update webDB door, error: %s", err.Error())
        }</span>

        <span class="cov8" title="1">return &amp;doorV1.UpdateDoorReply{}, nil</span>
}

func (s *DoorService) GetDoor(ctx context.Context, req *doorV1.GetDoorRequest) (*doorV1.GetDoorReply, error) <span class="cov8" title="1">{
        s.log.Infof("GetDoor: %+v", req)

        door, err := s.doorUseCase.GetDoor(context.Background(), req.GetId())
        if err != nil </span><span class="cov8" title="1">{
                s.log.Errorf("get webDB door error: %s", err.Error())
                return nil, ErrorGetDoorError("failed to get webDB door, error: %s", err.Error())
        }</span>

        <span class="cov8" title="1">if req.GetController() != door.ControllerID </span><span class="cov8" title="1">{
                s.log.Errorf("validate controller error: door ControllerID not match")
                return nil, ErrorValidateDoorError("validate controller error: door ControllerID not match")
        }</span>

        <span class="cov8" title="1">controller, err := s.controllerUseCase.GetController(context.Background(), door.ControllerID)
        if err != nil </span><span class="cov8" title="1">{
                s.log.Errorf("get webDB controller error: %s", err.Error())
                return nil, ErrorGetControllerError("failed to get webDB controller, error: %s", err.Error())
        }</span>

        <span class="cov8" title="1">if req.GetAgent() != controller.AgentID </span><span class="cov8" title="1">{
                s.log.Errorf("validate agent error: door agentID not match")
                return nil, ErrorValidateDoorError("validate agent error: door agentID not match")
        }</span>

        <span class="cov8" title="1">return &amp;doorV1.GetDoorReply{
                Door: door.ToPbDoor(),
        }, nil</span>
}

func (s *DoorService) ListDoor(ctx context.Context, req *doorV1.ListDoorRequest) (*doorV1.ListDoorReply, error) <span class="cov8" title="1">{
        doors, doorCount, err := s.doorUseCase.ListDoor(ctx, req.GetOffset(), req.GetLimit())
        if err != nil </span><span class="cov8" title="1">{
                s.log.Errorf("list door error: %s", err.Error())
                return nil, ErrorListDoorError("failed to list door, error: %s", err.Error())
        }</span>

        <span class="cov8" title="1">pbDoors := &amp;doorV1.ListDoorReply{
                Doors: make([]*doorV1.DoorInfo, 0, len(doors)),
                Total: doorCount,
        }
        for _, door := range doors </span><span class="cov8" title="1">{
                pbDoor := door.ToPbDoor()
                pbDoors.Doors = append(pbDoors.Doors, pbDoor)
        }</span>

        <span class="cov8" title="1">return pbDoors, nil</span>
}
</pre>

		<pre class="file" id="file46" style="display: none">package service

import (
        "context"
        "errors"
        "strings"
        "time"

        dsmGroupV1 "git.synology.inc/sast/access-system/server/dsm/api/group/v1"
        dsmUserV1 "git.synology.inc/sast/access-system/server/dsm/api/user/v1"
        grpcConn "git.synology.inc/sast/access-system/server/internal/grpc"
        dsmV1 "git.synology.inc/sast/access-system/server/web/api/dsm/v1"
        "git.synology.inc/sast/access-system/server/web/internal/biz"
        "git.synology.inc/sast/access-system/server/web/internal/conf"
        "git.synology.inc/sast/access-system/server/web/internal/taskqueue"
        "github.com/go-kratos/kratos/v2/log"
        "github.com/segmentio/ksuid"
        "google.golang.org/protobuf/types/known/emptypb"
)

type Task string

const (
        TaskSync              Task = "Sync"
        TaskHookDeleteUser    Task = "HookDeleteUser"
        TaskHookSyncUser      Task = "HookSyncUser"
        TaskHookDeleteGroup   Task = "HookDeleteGroup"
        TaskHookSetGroup      Task = "HookSetGroup"
        TaskHookSyncUserGroup Task = "HookSyncUserGroup"
)

func (t Task) String() string <span class="cov0" title="0">{
        return string(t)
}</span>

type SyncStatus uint32

const (
        SyncIdle SyncStatus = iota
        SyncTaskQueueFailed
        SyncUserInProgress
        SyncUserFailed
        DeleteUserInProgress
        DeleteUserFailed
        SyncGroupInProgress
        SyncGroupFailed
        DeleteGroupInProgress
        DeleteGroupFailed
        LinkUserGroupInProgress
        LinkUserGroupFailed
        SyncCompleted
)

type DsmService struct {
        dsmV1.UnimplementedDsmServer

        dsmUseCase *biz.DsmUseCase
        log        *log.Helper
        conf       *conf.Dsm
        status     SyncStatus
        taskqueue  *taskqueue.TaskQueue
}

func NewDsmService(dsmConf *conf.Dsm, dsmUseCase *biz.DsmUseCase, tq *taskqueue.TaskQueue, logger log.Logger) (*DsmService, func(), error) <span class="cov0" title="0">{
        logHelper := log.NewHelper(logger)

        serverGrpcConf := grpcConn.GRPCServerConf{
                Protocol: dsmConf.GetGrpc().GetProtocol(),
                Addr:     dsmConf.GetGrpc().GetAddr(),
        }

        conn, cleanup, err := grpcConn.NewClientConn(&amp;serverGrpcConf)
        if err != nil </span><span class="cov0" title="0">{
                logHelper.Errorf("failed to connect to DSM server: %s", err.Error())
                return nil, nil, ErrorDsmCanNotCreateConnection("failed to connect to DSM server: %s", err.Error())
        }</span>

        <span class="cov0" title="0">userClient := dsmUserV1.NewUserClient(conn)
        groupClient := dsmGroupV1.NewGroupClient(conn)
        dsmUseCase.SetClient(userClient, groupClient)

        s := &amp;DsmService{
                dsmUseCase: dsmUseCase,
                log:        logHelper,
                conf:       dsmConf,
                status:     SyncIdle,
                taskqueue:  tq,
        }

        // TODO: disable periodic temporarily
        // s.startPeriodicSync()

        return s, cleanup, nil</span>
}

func (s *DsmService) Sync(ctx context.Context, _ *emptypb.Empty) (*emptypb.Empty, error) <span class="cov0" title="0">{
        err := s.startSyncTask()
        if err != nil </span><span class="cov0" title="0">{
                s.log.Errorf("start sync task error: %s", err.Error())
                return nil, ErrorDsmSyncError("failed to start sync task, error: %s", err.Error())
        }</span>
        <span class="cov0" title="0">return &amp;emptypb.Empty{}, nil</span>
}

func (s *DsmService) StopSync(ctx context.Context, _ *emptypb.Empty) (*emptypb.Empty, error) <span class="cov0" title="0">{
        if s.taskqueue.IsTaskRunning(TaskSync.String()) </span><span class="cov0" title="0">{
                s.taskqueue.StopTaskByName(TaskSync.String())
                s.status = SyncIdle
        }</span> else<span class="cov0" title="0"> {
                s.log.Errorf("sync task is not running")
                return nil, ErrorDsmStopSyncError("sync task is not running")
        }</span>
        <span class="cov0" title="0">return &amp;emptypb.Empty{}, nil</span>
}

func (s *DsmService) GetSyncProgress(ctx context.Context, req *emptypb.Empty) (*dsmV1.GetSyncProgressReply, error) <span class="cov0" title="0">{
        syncProgress, err := s.dsmUseCase.GetSyncProgress()
        if err != nil </span><span class="cov0" title="0">{
                s.log.Errorf("get sync progress error: %s", err.Error())
                return nil, ErrorDsmGetSyncProgressError("failed to get sync progress, error: %s", err.Error())
        }</span>

        <span class="cov0" title="0">return &amp;dsmV1.GetSyncProgressReply{
                Status:   s.getSyncStatus(),
                Progress: syncProgress,
        }, nil</span>
}

func (s *DsmService) HookDeleteUser(ctx context.Context, req *dsmV1.HookDeleteUserRequest) (*emptypb.Empty, error) <span class="cov0" title="0">{
        err := s.taskqueue.Enqueue(TaskHookDeleteUser.String(), func(ctx context.Context) error </span><span class="cov0" title="0">{
                uidStrList := strings.Split(req.GetUidList(), ",")
                var retryErrors []error

                for _, uidStr := range uidStrList </span><span class="cov0" title="0">{
                        err := s.dsmUseCase.DeleteUserBySyncUID(ctx, strings.TrimSpace(uidStr))
                        if err != nil </span><span class="cov0" title="0">{
                                s.log.Errorf("hook delete user error: %s", err.Error())
                                retryErrors = append(retryErrors, ErrorDsmHookDeleteUserError("failed to delete user, error: %s", err.Error()))
                                continue</span>
                        }
                }

                <span class="cov0" title="0">if len(retryErrors) &gt; 0 </span><span class="cov0" title="0">{
                        return errors.Join(retryErrors...)
                }</span>

                <span class="cov0" title="0">err := s.dsmUseCase.UpdateSyncTime(time.Now().Format("2006/01/02 15:04:05"))
                if err != nil </span><span class="cov0" title="0">{
                        /* Continue sync flow despite time sync failure */
                        s.log.Errorf("update sync time error: %s", err.Error())
                }</span>
                <span class="cov0" title="0">return nil</span>
        })
        <span class="cov0" title="0">return &amp;emptypb.Empty{}, err</span>
}

func (s *DsmService) HookSyncUser(ctx context.Context, req *dsmV1.HookSyncUserRequest) (*emptypb.Empty, error) <span class="cov0" title="0">{
        err := s.taskqueue.Enqueue(TaskHookSyncUser.String(), func(ctx context.Context) error </span><span class="cov0" title="0">{
                err := s.dsmUseCase.SyncUserFromDSMHook(ctx, req.GetUidList())
                if err != nil </span><span class="cov0" title="0">{
                        s.log.Errorf("hook sync user error: %s", err.Error())
                        return ErrorDsmHookSyncUserError("failed to sync user, error: %s", err.Error())
                }</span>

                <span class="cov0" title="0">err = s.dsmUseCase.UpdateSyncTime(time.Now().Format("2006/01/02 15:04:05"))
                if err != nil </span><span class="cov0" title="0">{
                        /* Continue sync flow despite time sync failure */
                        s.log.Errorf("update sync time error: %s", err.Error())
                }</span>
                <span class="cov0" title="0">return nil</span>
        })
        <span class="cov0" title="0">return &amp;emptypb.Empty{}, err</span>
}

func (s *DsmService) HookDeleteGroup(ctx context.Context, req *dsmV1.HookDeleteGroupRequest) (*emptypb.Empty, error) <span class="cov0" title="0">{
        err := s.taskqueue.Enqueue(TaskHookDeleteGroup.String(), func(ctx context.Context) error </span><span class="cov0" title="0">{
                gidStrList := strings.Split(req.GetGidList(), ",")
                var retryErrors []error

                for _, gidStr := range gidStrList </span><span class="cov0" title="0">{
                        err := s.dsmUseCase.DeleteGroupBySyncGID(ctx, strings.TrimSpace(gidStr))
                        if err != nil </span><span class="cov0" title="0">{
                                s.log.Errorf("hook delete group error: %s", err.Error())
                                retryErrors = append(retryErrors, ErrorDsmHookDeleteGroupError("failed to delete group, error: %s", err.Error()))
                                continue</span>
                        }
                }

                <span class="cov0" title="0">if len(retryErrors) &gt; 0 </span><span class="cov0" title="0">{
                        return errors.Join(retryErrors...)
                }</span>

                <span class="cov0" title="0">err := s.dsmUseCase.UpdateSyncTime(time.Now().Format("2006/01/02 15:04:05"))
                if err != nil </span><span class="cov0" title="0">{
                        /* Continue sync flow despite time sync failure */
                        s.log.Errorf("update sync time error: %s", err.Error())
                }</span>
                <span class="cov0" title="0">return nil</span>
        })

        <span class="cov0" title="0">return &amp;emptypb.Empty{}, err</span>
}

func (s *DsmService) HookSetGroup(ctx context.Context, req *dsmV1.HookSetGroupRequest) (*emptypb.Empty, error) <span class="cov0" title="0">{
        err := s.taskqueue.Enqueue(TaskHookSetGroup.String(), func(ctx context.Context) error </span><span class="cov0" title="0">{
                err := s.dsmUseCase.SetGroupFromDSMHook(ctx, req.GetOriginName(), req.GetNewName())
                if err != nil </span><span class="cov0" title="0">{
                        s.log.Errorf("hook set group error: %s", err.Error())
                        return ErrorDsmHookSetGroupError("failed to set group, error: %s", err.Error())
                }</span>

                <span class="cov0" title="0">err = s.dsmUseCase.UpdateSyncTime(time.Now().Format("2006/01/02 15:04:05"))
                if err != nil </span><span class="cov0" title="0">{
                        /* Continue sync flow despite time sync failure */
                        s.log.Errorf("update sync time error: %s", err.Error())
                }</span>
                <span class="cov0" title="0">return nil</span>
        })

        <span class="cov0" title="0">return &amp;emptypb.Empty{}, err</span>
}

func (s *DsmService) HookSyncUserGroup(ctx context.Context, req *dsmV1.HookSyncUserGroupRequest) (*emptypb.Empty, error) <span class="cov0" title="0">{
        if req.GetUidGidList() == "" </span><span class="cov0" title="0">{
                s.log.Errorf("hook sync user group error: empty uid_gid_list")
                return nil, ErrorDsmHookSyncUserGroupError("empty uid_gid_list")
        }</span>
        <span class="cov0" title="0">err := s.taskqueue.Enqueue(TaskHookSyncUserGroup.String(), func(ctx context.Context) error </span><span class="cov0" title="0">{
                // parsing rule: (uid:gid_list;uid:gid_list;...) =&gt; 1037:100 65541;1038:100 65541
                uidGIDList := strings.Split(req.GetUidGidList(), ";")
                for _, pair := range uidGIDList </span><span class="cov0" title="0">{
                        if pair == "" </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        <span class="cov0" title="0">parts := strings.Split(pair, ":")
                        if len(parts) != 2 </span><span class="cov0" title="0">{
                                s.log.Errorf("invalid format for UID:GID_LIST pair: %s", pair)
                                continue</span>
                        }

                        <span class="cov0" title="0">uid := parts[0]
                        gidList := strings.Split(parts[1], " ")

                        err := s.dsmUseCase.SyncUserGroupFromDSMHook(context.Background(), uid, gidList)
                        if err != nil </span><span class="cov0" title="0">{
                                s.log.Errorf("hook sync user group error: %s", err.Error())
                        }</span>
                }
                <span class="cov0" title="0">err := s.dsmUseCase.UpdateSyncTime(time.Now().Format("2006/01/02 15:04:05"))
                if err != nil </span><span class="cov0" title="0">{
                        /* Continue sync flow despite time sync failure */
                        s.log.Errorf("update sync time error: %s", err.Error())
                }</span>
                <span class="cov0" title="0">return nil</span>
        })

        <span class="cov0" title="0">return &amp;emptypb.Empty{}, err</span>
}

func (s *DsmService) GetStatistics(ctx context.Context, _ *emptypb.Empty) (*dsmV1.GetStatisticsReply, error) <span class="cov0" title="0">{
        statistics, err := s.dsmUseCase.GetStatistics(ctx)
        if err != nil </span><span class="cov0" title="0">{
                s.log.Errorf("get statistics error: %s", err.Error())
                return nil, ErrorDsmGetStatisticsError("failed to get statistics, error: %s", err.Error())
        }</span>

        <span class="cov0" title="0">return &amp;dsmV1.GetStatisticsReply{
                LastSyncTime:               statistics.LastSyncTime,
                IsDsmIntegrationEnabled:    statistics.IsDsmIntegrationEnabled,
                SyncedLocalUserCount:       statistics.SyncedLocalUserCount,
                SyncedLocalGroupCount:      statistics.SyncedLocalGroupCount,
                SyncedDomainLdapUserCount:  statistics.SyncedDomainLdapUserCount,
                SyncedDomainLdapGroupCount: statistics.SyncedDomainLdapGroupCount,
        }, nil</span>
}

func (s *DsmService) GetUnsyncedStatistics(ctx context.Context, _ *emptypb.Empty) (*dsmV1.GetUnsyncedStatisticsReply,
        error) <span class="cov0" title="0">{

        unSyncedLocalUserCount, err := s.dsmUseCase.GetSynoUserTotal(ctx, "local")
        if err != nil </span><span class="cov0" title="0">{
                s.log.Errorf("get unsynced local user count error: %s", err.Error())
                return nil, ErrorDsmGetUnsyncedStatisticsError("failed to get unsynced local user count, error: %s", err.Error())
        }</span>

        <span class="cov0" title="0">unSyncedDomainUserCount, err := s.dsmUseCase.GetSynoUserTotal(ctx, "domain")
        if err != nil </span><span class="cov0" title="0">{
                s.log.Errorf("get unsynced domain user count error: %s", err.Error())
                return nil, ErrorDsmGetUnsyncedStatisticsError("failed to get unsynced domain user count, error: %s", err.Error())
        }</span>

        <span class="cov0" title="0">unSyncedLdapUserCount, err := s.dsmUseCase.GetSynoUserTotal(ctx, "ldap")
        if err != nil </span><span class="cov0" title="0">{
                s.log.Errorf("get unsynced ldap user count error: %s", err.Error())
                return nil, ErrorDsmGetUnsyncedStatisticsError("failed to get unsynced ldap user count, error: %s", err.Error())
        }</span>

        <span class="cov0" title="0">unSyncedLocalGroupCount, err := s.dsmUseCase.GetSynoGroupTotal(ctx, "local")
        if err != nil </span><span class="cov0" title="0">{
                s.log.Errorf("get unsynced local group count error: %s", err.Error())
                return nil, ErrorDsmGetUnsyncedStatisticsError("failed to get unsynced local group count, error: %s", err.Error())
        }</span>

        <span class="cov0" title="0">unSyncedDomainGroupCount, err := s.dsmUseCase.GetSynoGroupTotal(ctx, "domain")
        if err != nil </span><span class="cov0" title="0">{
                s.log.Errorf("get unsynced domain group count error: %s", err.Error())
                return nil, ErrorDsmGetUnsyncedStatisticsError("failed to get unsynced domain group count, error: %s", err.Error())
        }</span>

        <span class="cov0" title="0">unSyncedLdapGroupCount, err := s.dsmUseCase.GetSynoGroupTotal(ctx, "ldap")
        if err != nil </span><span class="cov0" title="0">{
                s.log.Errorf("get unsynced ldap group count error: %s", err.Error())
                return nil, ErrorDsmGetUnsyncedStatisticsError("failed to get unsynced ldap group count, error: %s", err.Error())
        }</span>

        <span class="cov0" title="0">return &amp;dsmV1.GetUnsyncedStatisticsReply{
                UnsyncedLocalUserCount:       unSyncedLocalUserCount,
                UnsyncedLocalGroupCount:      unSyncedLocalGroupCount,
                UnsyncedDomainLdapUserCount:  unSyncedDomainUserCount + unSyncedLdapUserCount,
                UnsyncedDomainLdapGroupCount: unSyncedDomainGroupCount + unSyncedLdapGroupCount,
        }, nil</span>
}

func (s *DsmService) EnableSync(ctx context.Context, req *dsmV1.EnableSyncRequest) (*emptypb.Empty, error) <span class="cov0" title="0">{
        err := s.dsmUseCase.EnableSync(ctx, req.GetEnable())
        if err != nil </span><span class="cov0" title="0">{
                s.log.Errorf("enable sync error: %s", err.Error())
                return nil, ErrorDsmEnableSyncError("failed to enable sync, error: %s", err.Error())
        }</span>
        <span class="cov0" title="0">return &amp;emptypb.Empty{}, nil</span>
}

func (s *DsmService) getSyncStatus() dsmV1.SyncStatus <span class="cov0" title="0">{
        switch s.status </span>{
        case SyncIdle:<span class="cov0" title="0">
                return dsmV1.SyncStatus_SYNC_IDLE</span>
        case SyncTaskQueueFailed:<span class="cov0" title="0">
                return dsmV1.SyncStatus_SYNC_TASKQUEUE_FAILED</span>
        case SyncUserInProgress:<span class="cov0" title="0">
                return dsmV1.SyncStatus_SYNC_USER_IN_PROGRESS</span>
        case SyncUserFailed:<span class="cov0" title="0">
                return dsmV1.SyncStatus_SYNC_USER_FAILED</span>
        case DeleteUserInProgress:<span class="cov0" title="0">
                return dsmV1.SyncStatus_DELETE_USER_IN_PROGRESS</span>
        case DeleteUserFailed:<span class="cov0" title="0">
                return dsmV1.SyncStatus_DELETE_USER_FAILED</span>
        case SyncGroupInProgress:<span class="cov0" title="0">
                return dsmV1.SyncStatus_SYNC_GROUP_IN_PROGRESS</span>
        case SyncGroupFailed:<span class="cov0" title="0">
                return dsmV1.SyncStatus_SYNC_GROUP_FAILED</span>
        case DeleteGroupInProgress:<span class="cov0" title="0">
                return dsmV1.SyncStatus_DELETE_GROUP_IN_PROGRESS</span>
        case DeleteGroupFailed:<span class="cov0" title="0">
                return dsmV1.SyncStatus_DELETE_GROUP_FAILED</span>
        case LinkUserGroupInProgress:<span class="cov0" title="0">
                return dsmV1.SyncStatus_LINK_USER_GROUP_IN_PROGRESS</span>
        case LinkUserGroupFailed:<span class="cov0" title="0">
                return dsmV1.SyncStatus_LINK_USER_GROUP_FAILED</span>
        case SyncCompleted:<span class="cov0" title="0">
                return dsmV1.SyncStatus_SYNC_COMPLETED</span>
        default:<span class="cov0" title="0">
                return dsmV1.SyncStatus_SYNC_IDLE</span>
        }
}

//nolint:unused
func (s *DsmService) startPeriodicSync() <span class="cov0" title="0">{
        if err := s.startSyncTask(); err != nil </span><span class="cov0" title="0">{
                s.log.Errorf("initial sync task failed: %v", err)
        }</span>

        <span class="cov0" title="0">ticker := time.NewTicker(s.conf.GetSyncInterval().AsDuration())

        go func() </span><span class="cov0" title="0">{
                for range ticker.C </span><span class="cov0" title="0">{
                        s.log.Infof("start periodic sync task")
                        if err := s.startSyncTask(); err != nil </span><span class="cov0" title="0">{
                                s.log.Errorf("periodic sync task failed: %v", err)
                        }</span>
                }
        }()
}

func (s *DsmService) startSyncTask() error <span class="cov0" title="0">{
        if s.taskqueue.IsTaskRunning(TaskSync.String()) </span><span class="cov0" title="0">{
                s.log.Errorf("sync task is already running")
                return ErrorDsmSyncError("sync task is already running")
        }</span>

        <span class="cov0" title="0">s.status = SyncIdle
        syncTimeID := ksuid.New().String()

        err := s.taskqueue.Enqueue(TaskSync.String(), func(ctx context.Context) error </span><span class="cov0" title="0">{
                s.status = SyncUserInProgress
                err := s.syncUser(syncTimeID)
                if err != nil </span><span class="cov0" title="0">{
                        s.status = SyncUserFailed
                        return err
                }</span>

                <span class="cov0" title="0">s.status = DeleteUserInProgress
                err = s.deleteUser(ctx, syncTimeID)
                if err != nil </span><span class="cov0" title="0">{
                        s.status = DeleteUserFailed
                        return err
                }</span>

                <span class="cov0" title="0">s.status = SyncGroupInProgress
                err = s.syncGroup(syncTimeID)
                if err != nil </span><span class="cov0" title="0">{
                        s.status = SyncGroupFailed
                        return err
                }</span>

                <span class="cov0" title="0">s.status = DeleteGroupInProgress
                err = s.deleteGroup(ctx, syncTimeID)
                if err != nil </span><span class="cov0" title="0">{
                        s.status = DeleteGroupFailed
                        return err
                }</span>

                <span class="cov0" title="0">s.status = LinkUserGroupInProgress
                err = s.linkUserGroup(ctx, syncTimeID)
                if err != nil </span><span class="cov0" title="0">{
                        s.status = LinkUserGroupFailed
                        return err
                }</span>

                <span class="cov0" title="0">s.status = SyncCompleted
                err = s.dsmUseCase.UpdateSyncTime(time.Now().Format("2006/01/02 15:04:05"))
                if err != nil </span><span class="cov0" title="0">{
                        /* Continue sync flow despite time sync failure */
                        s.log.Errorf("update sync time error: %s", err.Error())
                }</span>
                <span class="cov0" title="0">return nil</span>
        })

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                s.log.Errorf("sync task runs with error: %s", err.Error())
                s.status = SyncTaskQueueFailed
                s.log.Errorf("s.status: %s", s.status)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (s *DsmService) syncUser(syncTime string) error <span class="cov0" title="0">{
        err := s.dsmUseCase.SyncUser(s.conf.GetSyncBatchSize(), s.conf.GetSyncTimeout().AsDuration(), syncTime)
        if err != nil </span><span class="cov0" title="0">{
                s.log.Errorf("sync user error: %s", err.Error())
                return ErrorDsmSyncError("failed to sync user, error: %s", err.Error())
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (s *DsmService) deleteUser(ctx context.Context, syncTimeID string) error <span class="cov0" title="0">{
        err := s.dsmUseCase.DeleteUserBySyncTimeID(ctx, syncTimeID)
        if err != nil </span><span class="cov0" title="0">{
                s.log.Errorf("delete user error: %s", err.Error())
                return ErrorDsmSyncError("failed to delete user, error: %s", err.Error())
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (s *DsmService) syncGroup(syncTimeID string) error <span class="cov0" title="0">{
        err := s.dsmUseCase.SyncGroup(s.conf.GetSyncBatchSize(), s.conf.GetSyncTimeout().AsDuration(), syncTimeID)
        if err != nil </span><span class="cov0" title="0">{
                s.log.Errorf("sync group error: %s", err.Error())
                return ErrorDsmSyncError("failed to sync group, error: %s", err.Error())
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (s *DsmService) deleteGroup(ctx context.Context, syncTimeID string) error <span class="cov0" title="0">{
        err := s.dsmUseCase.DeleteGroupBySyncTimeID(ctx, syncTimeID)
        if err != nil </span><span class="cov0" title="0">{
                s.log.Errorf("delete group error: %s", err.Error())
                return ErrorDsmSyncError("failed to delete group, error: %s", err.Error())
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (s *DsmService) linkUserGroup(ctx context.Context, syncTimeID string) error <span class="cov0" title="0">{
        err := s.dsmUseCase.LinkUserGroup(ctx, s.conf.SyncBatchSize, syncTimeID)
        if err != nil </span><span class="cov0" title="0">{
                s.log.Errorf("link user group error: %s", err.Error())
                return ErrorDsmSyncError("failed to link user group, error: %s", err.Error())
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>

		<pre class="file" id="file47" style="display: none">package service

import (
        "context"

        agentV1 "git.synology.inc/sast/access-system/server/gateway/api/agent/v1"
        generalV1 "git.synology.inc/sast/access-system/server/web/api/general/v1"
        "git.synology.inc/sast/access-system/server/web/internal/biz"
        "github.com/go-kratos/kratos/v2/log"
        "google.golang.org/protobuf/types/known/emptypb"
)

type GeneralService struct {
        generalV1.UnimplementedGeneralServer

        discoveryService DiscoveryServiceInterface
        generalUseCase   *biz.GeneralUseCase
        agentUseCase     biz.AgentUseCaseInterface
        logger           *log.Helper
}

func NewGeneralService(discoveryService DiscoveryServiceInterface, generalUseCase *biz.GeneralUseCase,
        agentUseCase biz.AgentUseCaseInterface, logger log.Logger) *GeneralService <span class="cov0" title="0">{

        return &amp;GeneralService{
                discoveryService: discoveryService,
                generalUseCase:   generalUseCase,
                agentUseCase:     agentUseCase,
                logger:           log.NewHelper(logger),
        }
}</span>

func (s *GeneralService) Healthz(ctx context.Context, req *emptypb.Empty) (*generalV1.HealthzReply, error) <span class="cov0" title="0">{
        return &amp;generalV1.HealthzReply{
                Status: s.generalUseCase.Healthz(),
        }, nil
}</span>

func (s *GeneralService) PingAgent(ctx context.Context, req *generalV1.PingAgentRequest) (*generalV1.PingAgentReply, error) <span class="cov0" title="0">{
        // Get agent unique id from agent id
        agent, err := s.agentUseCase.GetAgent(context.Background(), req.GetId())
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Errorf("agent: %s not found", req.GetId())
                return nil, ErrorAgentNotFount("agent: %s not found", req.GetId())
        }</span>

        <span class="cov0" title="0">conn, err := s.discoveryService.Get(agent.UniqueID)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Errorf("failed to get gateway connection: %s for agent %s", err.Error(), agent.ID)
                return nil, ErrorCanNotGetGatewayConnection(
                        "failed to get gateway connection: %s for agent %s", err.Error(), agent.ID)
        }</span>

        <span class="cov0" title="0">if conn == nil </span><span class="cov0" title="0">{
                s.logger.Errorf("gateway connection is nil for agent %s", agent.ID)
                return nil, ErrorCanNotGetGatewayConnection(
                        "gateway connection is nil for agent %s", agent.ID)
        }</span>

        <span class="cov0" title="0">reply, err := conn.Agent.PingAgent(ctx, &amp;agentV1.PingAgentRequest{
                AgentId: agent.UniqueID,
        })
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Errorf("failed to ping agent %s: %s", agent.ID, err.Error())
                return nil, ErrorCanNotPingAgent("failed to ping agent %s: %s", agent.ID, err.Error())
        }</span>

        <span class="cov0" title="0">state := generalV1.PingAgentReply_UNKNOWN

        switch reply.GetAgent().GetState() </span>{
        case agentV1.AgentState_CONNECTED:<span class="cov0" title="0">
                state = generalV1.PingAgentReply_CONNECTED</span>
        case agentV1.AgentState_DISCONNECTED:<span class="cov0" title="0">
                state = generalV1.PingAgentReply_DISCONNECTED</span>
        }

        <span class="cov0" title="0">return &amp;generalV1.PingAgentReply{
                Id:    reply.GetAgent().GetId(),
                State: state,
        }, nil</span>
}
</pre>

		<pre class="file" id="file48" style="display: none">package service

import (
        "context"

        groupV1 "git.synology.inc/sast/access-system/server/web/api/group/v1"
        userV1 "git.synology.inc/sast/access-system/server/web/api/user/v1"
        "git.synology.inc/sast/access-system/server/web/internal/biz"
        "git.synology.inc/sast/access-system/server/web/internal/datastore/dto"
        "github.com/go-kratos/kratos/v2/log"
        "github.com/segmentio/ksuid"
        "google.golang.org/protobuf/types/known/emptypb"
)

type GroupService struct {
        groupV1.UnimplementedGroupServer

        groupUseCase biz.GroupUseCaseInterface
        log          *log.Helper
}

func NewGroupService(groupUseCase biz.GroupUseCaseInterface, logger log.Logger) *GroupService <span class="cov0" title="0">{
        return &amp;GroupService{
                groupUseCase: groupUseCase,
                log:          log.NewHelper(logger),
        }
}</span>

func (s *GroupService) AddGroup(ctx context.Context, req *groupV1.AddGroupRequest) (*groupV1.AddGroupReply, error) <span class="cov0" title="0">{
        // DSM group created by dsm sync service
        // Group api can only create local group
        if req.GetSource() != groupV1.GroupSource_LOCAL </span><span class="cov0" title="0">{
                s.log.Errorf("group source: %s not allowed by api", req.GetSource())
                return nil, ErrorAddGroupError("group source: %s not allowed by api", req.GetSource())
        }</span>

        // transfer group source
        <span class="cov0" title="0">groupSource, err := dto.PbGroupSourceToGroupSource(req.GetSource())
        if err != nil </span><span class="cov0" title="0">{
                s.log.Errorf("add group convert group source error with source: %+v, error: %s", req.GetSource(), err.Error())
                return nil, ErrorAddGroupError("add group convert group source error with source: %+v, error: %s",
                        req.GetSource(), err.Error())
        }</span>

        // Arrange
        <span class="cov0" title="0">addGroup := &amp;dto.Group{
                ID:          ksuid.New().String(),
                UniqueID:    ksuid.New().String(),
                Source:      groupSource,
                Name:        req.GetName(),
                Description: req.GetDescription(),
        }

        // Act
        id, err := s.groupUseCase.AddGroup(ctx, addGroup, req.GetUsers(), req.GetGroups())
        if err != nil </span><span class="cov0" title="0">{
                s.log.Errorf("add group failed due to use case add group error: %s", err.Error())
                return nil, ErrorAddGroupError("add group failed due to use case add group error: %s", err.Error())
        }</span>

        <span class="cov0" title="0">return &amp;groupV1.AddGroupReply{
                Id: id,
        }, nil</span>
}

func (s *GroupService) getGroupDetailed(ctx context.Context, group *dto.Group) (*groupV1.GroupInfoDetailed, error) <span class="cov0" title="0">{
        // Need to add GroupListUserAll, should be defined by UI/UX spec
        // List child user
        users, userCount, err := s.groupUseCase.GroupListUser(ctx, group, groupV1.RelationListMode_SINGLE_LAYER, DefaultOffset, DefaultLimit)
        if err != nil </span><span class="cov0" title="0">{
                s.log.Errorf("group list user failed due to use case group list user error: %s", err.Error())
                return nil, ErrorListGroupError("group list user failed due to use case group list user error: %s", err.Error())
        }</span>

        <span class="cov0" title="0">childUsers := make([]*userV1.UserInfo, 0, len(users))
        for _, user := range users </span><span class="cov0" title="0">{
                pbUser, err := user.ToPbUser()
                if err != nil </span><span class="cov0" title="0">{
                        s.log.Errorf("group list user convert user to pb user error: %s", err.Error())
                        return nil, ErrorListGroupError("group list user convert user to pb user error: %s", err.Error())
                }</span>
                <span class="cov0" title="0">childUsers = append(childUsers, pbUser)</span>
        }

        // Need to add GroupListGroupAll, should be defined by UI/UX spec
        // List child group
        <span class="cov0" title="0">groups, groupCount, err := s.groupUseCase.GroupListGroup(ctx, group, groupV1.RelationListMode_SINGLE_LAYER, DefaultOffset, DefaultLimit)
        if err != nil </span><span class="cov0" title="0">{
                s.log.Errorf("group list group failed due to use case group list group error: %s", err.Error())
                return nil, ErrorListGroupError("group list group failed due to use case group list group error: %s", err.Error())
        }</span>
        <span class="cov0" title="0">childGroups := make([]*groupV1.GroupInfo, 0, len(groups))
        for _, group := range groups </span><span class="cov0" title="0">{
                pbGroup, err := group.ToPbGroup()
                if err != nil </span><span class="cov0" title="0">{
                        s.log.Errorf("list group convert group to pb group error: %s", err.Error())
                        return nil, ErrorListGroupError("list group convert group to pb group error: %s", err.Error())
                }</span>
                <span class="cov0" title="0">childGroups = append(childGroups, pbGroup)</span>
        }

        <span class="cov0" title="0">pbGroup, err := group.ToPbGroupDetailed()
        if err != nil </span><span class="cov0" title="0">{
                s.log.Errorf("get group convert group to pb group error: %s", err.Error())
                return nil, ErrorGetGroupError("get group convert group to pb group error: %s", err.Error())
        }</span>

        <span class="cov0" title="0">pbGroup.GroupTotal = groupCount
        pbGroup.Groups = childGroups
        pbGroup.UserTotal = userCount
        pbGroup.Users = childUsers

        return pbGroup, nil</span>
}

func (s *GroupService) GetGroup(ctx context.Context, req *groupV1.GetGroupRequest) (*groupV1.GetGroupReply, error) <span class="cov0" title="0">{
        getGroup := &amp;dto.Group{
                ID: req.GetId(),
        }

        g, err := s.groupUseCase.GetGroup(ctx, getGroup)
        if err != nil </span><span class="cov0" title="0">{
                s.log.Errorf("get group failed due to use case get group error: %s", err.Error())
                return nil, ErrorGetGroupError("get group failed due to use case get group error: %s", err.Error())
        }</span>

        <span class="cov0" title="0">pbGroup, err := s.getGroupDetailed(ctx, g)
        if err != nil </span><span class="cov0" title="0">{
                s.log.Errorf("get group failed due to use case get group child error: %s", err.Error())
                return nil, ErrorGetGroupError("get group convert group to pb group error: %s", err.Error())
        }</span>

        <span class="cov0" title="0">return &amp;groupV1.GetGroupReply{
                Group: pbGroup,
        }, nil</span>
}

func (s *GroupService) UpdateGroup(ctx context.Context, req *groupV1.UpdateGroupRequest) (*emptypb.Empty, error) <span class="cov0" title="0">{
        groupSource, err := dto.PbGroupSourceToGroupSource(req.GetBody().GetSource())
        if err != nil </span><span class="cov0" title="0">{
                s.log.Errorf("update group failed to map source: %v, error: %s", req.GetBody().GetSource(), err.Error())
                return nil, ErrorUpdateGroupError("update group failed to map source: %v, error: %s",
                        req.GetBody().GetSource(), err.Error())
        }</span>

        <span class="cov0" title="0">updateGroup := &amp;dto.Group{
                ID:          req.GetId(),
                UniqueID:    req.GetBody().GetUniqueId(),
                Source:      groupSource,
                Name:        req.GetBody().GetName(),
                Description: req.GetBody().GetDescription(),
        }

        err = s.groupUseCase.UpdateGroup(ctx, updateGroup)
        if err != nil </span><span class="cov0" title="0">{
                s.log.Errorf("update group failed due to use case update group error: %s", err.Error())
                return nil, ErrorUpdateGroupError("update group failed due to use case update group error: %s", err.Error())
        }</span>

        <span class="cov0" title="0">return &amp;emptypb.Empty{}, nil</span>
}

func (s *GroupService) DeleteGroup(ctx context.Context, req *groupV1.DeleteGroupRequest) (*emptypb.Empty, error) <span class="cov0" title="0">{
        deleteGroup := &amp;dto.Group{
                ID: req.GetId(),
        }

        err := s.groupUseCase.DeleteGroup(ctx, deleteGroup)
        if err != nil </span><span class="cov0" title="0">{
                s.log.Errorf("delete group failed due to use case delete group error: %s", err.Error())
                return nil, ErrorDeleteGroupError("delete group failed due to use case delete group error: %s", err.Error())
        }</span>

        <span class="cov0" title="0">return &amp;emptypb.Empty{}, nil</span>
}

func (s *GroupService) ListGroup(ctx context.Context, req *groupV1.ListGroupRequest) (*groupV1.ListGroupReply, error) <span class="cov0" title="0">{
        offset := req.GetOffset()
        limit := req.GetLimit()

        groups, groupCount, err := s.groupUseCase.ListGroup(ctx, offset, limit)
        if err != nil </span><span class="cov0" title="0">{
                s.log.Errorf("list group failed due to use case list group error: %s", err.Error())
                return nil, ErrorListGroupError("list group failed due to use case list group error: %s", err.Error())
        }</span>

        <span class="cov0" title="0">pbGroups := &amp;groupV1.ListGroupReply{
                Groups: make([]*groupV1.GroupInfoDetailed, 0, len(groups)),
                Total:  groupCount,
        }
        for _, group := range groups </span><span class="cov0" title="0">{
                pbGroup, err := s.getGroupDetailed(ctx, group)
                if err != nil </span><span class="cov0" title="0">{
                        s.log.Errorf("list group convert group to pb group error: %s", err.Error())
                        return nil, ErrorListGroupError("list group convert group to pb group error: %s", err.Error())
                }</span>
                <span class="cov0" title="0">pbGroups.Groups = append(pbGroups.Groups, pbGroup)</span>
        }

        <span class="cov0" title="0">return pbGroups, nil</span>
}

func (s *GroupService) GroupAddUser(ctx context.Context, req *groupV1.GroupAddUserRequest) (*emptypb.Empty, error) <span class="cov0" title="0">{
        targetGroup := &amp;dto.Group{
                ID: req.GetId(),
        }
        users := make([]*dto.User, 0, len(req.GetBody().GetUsers()))
        for _, userID := range req.GetBody().GetUsers() </span><span class="cov0" title="0">{
                users = append(users, &amp;dto.User{
                        ID: userID,
                })
        }</span>

        <span class="cov0" title="0">err := s.groupUseCase.GroupAddUser(ctx, targetGroup, users)
        if err != nil </span><span class="cov0" title="0">{
                s.log.Errorf("group add user failed due to use case group add user error: %s", err.Error())
                return nil, ErrorGroupAddUserError("group add user failed due to use case group add user error: %s", err.Error())
        }</span>

        <span class="cov0" title="0">return &amp;emptypb.Empty{}, nil</span>
}

func (s *GroupService) GroupDeleteUser(ctx context.Context, req *groupV1.GroupDeleteUserRequest) (*emptypb.Empty, error) <span class="cov0" title="0">{
        targetGroup := &amp;dto.Group{
                ID: req.GetId(),
        }
        users := make([]*dto.User, 0, len(req.GetUsers()))
        for _, userID := range req.GetUsers() </span><span class="cov0" title="0">{
                users = append(users, &amp;dto.User{
                        ID: userID,
                })
        }</span>

        <span class="cov0" title="0">err := s.groupUseCase.GroupDeleteUser(ctx, targetGroup, users)
        if err != nil </span><span class="cov0" title="0">{
                s.log.Errorf("group delete user failed due to use case group delete user error: %s", err.Error())
                return nil, ErrorGroupDeleteUserError("group delete user failed due to use case group delete user error: %s", err.Error())
        }</span>

        <span class="cov0" title="0">return &amp;emptypb.Empty{}, nil</span>
}

func (s *GroupService) GroupListUser(ctx context.Context, req *groupV1.GroupListUserRequest) (*groupV1.GroupListUserReply, error) <span class="cov0" title="0">{
        targetGroup := &amp;dto.Group{
                ID: req.GetId(),
        }
        offset := req.GetOffset()
        limit := req.GetLimit()
        mode := req.GetMode()

        users, userCount, err := s.groupUseCase.GroupListUser(ctx, targetGroup, mode, offset, limit)
        if err != nil </span><span class="cov0" title="0">{
                s.log.Errorf("group list user failed due to use case group list user error: %s", err.Error())
                return nil, ErrorListGroupError("group list user failed due to use case group list user error: %s", err.Error())
        }</span>

        <span class="cov0" title="0">pbUsers := &amp;groupV1.GroupListUserReply{
                Users: make([]*userV1.UserInfo, 0, len(users)),
                Total: userCount,
        }
        for _, user := range users </span><span class="cov0" title="0">{
                pbGroup, err := user.ToPbUser()
                if err != nil </span><span class="cov0" title="0">{
                        s.log.Errorf("group list user convert user to pb user error: %s", err.Error())
                        return nil, ErrorListGroupError("group list user convert user to pb user error: %s", err.Error())
                }</span>
                <span class="cov0" title="0">pbUsers.Users = append(pbUsers.Users, pbGroup)</span>
        }

        <span class="cov0" title="0">return pbUsers, nil</span>
}

func (s *GroupService) GroupAddGroup(ctx context.Context, req *groupV1.GroupAddGroupRequest) (*emptypb.Empty, error) <span class="cov0" title="0">{
        targetGroup := &amp;dto.Group{
                ID: req.GetId(),
        }
        groups := make([]*dto.Group, 0, len(req.GetBody().GetGroups()))
        for _, groupID := range req.GetBody().GetGroups() </span><span class="cov0" title="0">{
                groups = append(groups, &amp;dto.Group{
                        ID: groupID,
                })
        }</span>

        <span class="cov0" title="0">err := s.groupUseCase.GroupAddGroup(ctx, targetGroup, groups)
        if err != nil </span><span class="cov0" title="0">{
                s.log.Errorf("group add group failed due to use case group add group error: %s", err.Error())
                return nil, ErrorGroupAddGroupError("group add group failed due to use case group add group error: %s", err.Error())
        }</span>

        <span class="cov0" title="0">return &amp;emptypb.Empty{}, nil</span>
}

func (s *GroupService) GroupDeleteGroup(ctx context.Context, req *groupV1.GroupDeleteGroupRequest) (*emptypb.Empty, error) <span class="cov0" title="0">{
        targetGroup := &amp;dto.Group{
                ID: req.GetId(),
        }
        groups := make([]*dto.Group, 0, len(req.GetGroups()))
        for _, groupID := range req.GetGroups() </span><span class="cov0" title="0">{
                groups = append(groups, &amp;dto.Group{
                        ID: groupID,
                })
        }</span>

        <span class="cov0" title="0">err := s.groupUseCase.GroupDeleteGroup(ctx, targetGroup, groups)
        if err != nil </span><span class="cov0" title="0">{
                s.log.Errorf("group delete group failed due to use case group delete group error: %s", err.Error())
                return nil, ErrorGroupDeleteGroupError("group delete group failed due to use case group delete group error: %s", err.Error())
        }</span>

        <span class="cov0" title="0">return &amp;emptypb.Empty{}, nil</span>
}

func (s *GroupService) GroupListGroup(ctx context.Context, req *groupV1.GroupListGroupRequest) (*groupV1.GroupListGroupReply, error) <span class="cov0" title="0">{
        targetGroup := &amp;dto.Group{
                ID: req.GetId(),
        }
        offset := req.GetOffset()
        limit := req.GetLimit()
        mode := req.GetMode()

        groups, groupCount, err := s.groupUseCase.GroupListGroup(ctx, targetGroup, mode, offset, limit)
        if err != nil </span><span class="cov0" title="0">{
                s.log.Errorf("group list group failed due to use case group list group error: %s", err.Error())
                return nil, ErrorListGroupError("group list group failed due to use case group list group error: %s", err.Error())
        }</span>

        <span class="cov0" title="0">pbGroups := &amp;groupV1.GroupListGroupReply{
                Groups: make([]*groupV1.GroupInfo, 0, len(groups)),
                Total:  groupCount,
        }
        for _, group := range groups </span><span class="cov0" title="0">{
                pbGroup, err := group.ToPbGroup()
                if err != nil </span><span class="cov0" title="0">{
                        s.log.Errorf("group list group convert group to pb group error: %s", err.Error())
                        return nil, ErrorListGroupError("group list group convert group to pb group error: %s", err.Error())
                }</span>
                <span class="cov0" title="0">pbGroups.Groups = append(pbGroups.Groups, pbGroup)</span>
        }

        <span class="cov0" title="0">return pbGroups, nil</span>
}
</pre>

		<pre class="file" id="file49" style="display: none">package service

import (
        "context"

        importV1 "git.synology.inc/sast/access-system/server/web/api/import/v1"
        "git.synology.inc/sast/access-system/server/web/internal/biz"
        "git.synology.inc/sast/access-system/server/web/internal/datastore/dto"
        "github.com/go-kratos/kratos/v2/log"
)

type ImportService struct {
        importV1.UnimplementedImportServer

        importUseCase       biz.ImportUseCaseInterface
        importUserValidator biz.ImportUserValidatorInterface
        log                 *log.Helper
}

func NewImportService(importUseCase biz.ImportUseCaseInterface, importUserValidator biz.ImportUserValidatorInterface, logger log.Logger,
) *ImportService <span class="cov8" title="1">{

        return &amp;ImportService{
                importUseCase:       importUseCase,
                importUserValidator: importUserValidator,
                log:                 log.NewHelper(logger),
        }
}</span>

func (s *ImportService) UserValidation(ctx context.Context, req *importV1.UserValidationRequest) (*importV1.UserValidationReply, error) <span class="cov8" title="1">{
        action, err := dto.PbImportActionToImportAction(req.GetAction())
        if err != nil </span><span class="cov8" title="1">{
                s.log.Errorf("Import action error: %v", err)
                return nil, ErrorImportActionInvalid("invalid import action")
        }</span>

        <span class="cov8" title="1">if len(req.Users) == 0 </span><span class="cov8" title="1">{
                return nil, ErrorUserListEmpty("user list empty")
        }</span>

        // transform to dto
        <span class="cov8" title="1">users := make([]*dto.ImportUserInfo, 0)
        for _, user := range req.GetUsers() </span><span class="cov8" title="1">{
                users = append(users, dto.PbImportUserInfoToImportUserInfo(user))
        }</span>

        // validate users
        <span class="cov8" title="1">errorUsers, err := s.importUserValidator.Validate(ctx, action, users, req.GetPhotoFiles())
        if err != nil </span><span class="cov8" title="1">{
                s.log.Errorf("Import user validator error: %v", err)
                return nil, ErrorUserValidationFailed("user validation failed: %s", err.Error())
        }</span>

        // transform to protobuf
        <span class="cov8" title="1">pbErrorUsers := make([]*importV1.ErrorUserInfo, 0)
        for _, user := range errorUsers </span><span class="cov8" title="1">{
                pbErrorUsers = append(pbErrorUsers, dto.ImportErrorUserInfoToPbImportErrorUserInfo(user))
        }</span>

        <span class="cov8" title="1">return &amp;importV1.UserValidationReply{
                ErrorUsers: pbErrorUsers,
        }, nil</span>
}

func (s *ImportService) UserSync(ctx context.Context, req *importV1.UserSyncRequest) (*importV1.UserSyncReply, error) <span class="cov8" title="1">{
        // 1.     user validation
        // 2.     start import

        action, err := dto.PbImportActionToImportAction(req.GetAction())
        if err != nil </span><span class="cov8" title="1">{
                s.log.Errorf("Import action error: %v", err)
                return nil, ErrorImportActionInvalid("invalid import action")
        }</span>

        <span class="cov8" title="1">if len(req.GetUsers()) == 0 </span><span class="cov8" title="1">{
                return nil, ErrorUserListEmpty("user list empty")
        }</span>

        // transform to dto
        <span class="cov8" title="1">users := make([]*dto.ImportUserInfo, 0)
        for _, user := range req.GetUsers() </span><span class="cov8" title="1">{
                users = append(users, dto.PbImportUserInfoToImportUserInfo(user))
        }</span>

        // validate users
        <span class="cov8" title="1">errorUsers, err := s.importUserValidator.Validate(ctx, action, users, req.GetPhotoFiles())
        if err != nil </span><span class="cov8" title="1">{
                s.log.Errorf("Import user validator error: %v", err)
                return nil, ErrorUserValidationFailed("user validation failed: %s", err.Error())
        }</span>
        <span class="cov8" title="1">if len(errorUsers) &gt; 0 </span><span class="cov8" title="1">{
                // transform to protobuf
                pbErrorUsers := make([]*importV1.ErrorUserInfo, 0)
                for _, user := range errorUsers </span><span class="cov8" title="1">{
                        pbErrorUsers = append(pbErrorUsers, dto.ImportErrorUserInfoToPbImportErrorUserInfo(user))
                }</span>

                <span class="cov8" title="1">return &amp;importV1.UserSyncReply{
                        SuccessUsers:  make([]*importV1.SuccessUserInfo, 0),
                        ErrorUsers:    pbErrorUsers,
                        CreateUser:    0,
                        SkipUser:      0,
                        OverwriteUser: 0,
                        ErrorUser:     uint32(len(pbErrorUsers)),
                }, nil</span>
        }

        <span class="cov8" title="1">res := &amp;importV1.UserSyncReply{
                SuccessUsers:  make([]*importV1.SuccessUserInfo, 0),
                ErrorUsers:    make([]*importV1.ErrorUserInfo, 0),
                CreateUser:    0,
                SkipUser:      0,
                OverwriteUser: 0,
                ErrorUser:     0,
        }

        // import user
        for _, user := range users </span><span class="cov8" title="1">{
                userID, importResult, errorUserInfo, err := s.importUseCase.ImportUser(ctx, action, user)

                switch importResult </span>{
                case dto.ImportResultCreate:<span class="cov8" title="1">
                        res.CreateUser++
                        res.SuccessUsers = append(res.SuccessUsers, &amp;importV1.SuccessUserInfo{
                                TempId:        user.TempID,
                                UniqueId:      userID,
                                PhotoFileName: user.PhotoFileName,
                        })</span>
                case dto.ImportResultSkip:<span class="cov8" title="1">
                        res.SkipUser++</span>
                case dto.ImportResultOverwrite:<span class="cov8" title="1">
                        res.OverwriteUser++
                        res.SuccessUsers = append(res.SuccessUsers, &amp;importV1.SuccessUserInfo{
                                TempId:        user.TempID,
                                UniqueId:      userID,
                                PhotoFileName: user.PhotoFileName,
                        })</span>
                case dto.ImportResultError:<span class="cov8" title="1">
                        s.log.Errorf("import user error: %v", err)
                        res.ErrorUsers = append(res.ErrorUsers, dto.ImportErrorUserInfoToPbImportErrorUserInfo(errorUserInfo))
                        res.ErrorUser++</span>
                }
        }

        <span class="cov8" title="1">return res, nil</span>
}
</pre>

		<pre class="file" id="file50" style="display: none">package service

import (
        "context"

        internalAgentV1 "git.synology.inc/sast/access-system/server/web/api/internal_agent/v1"
        "git.synology.inc/sast/access-system/server/web/internal/biz"
        "git.synology.inc/sast/access-system/server/web/internal/datastore/dto"
        "github.com/go-kratos/kratos/v2/log"
        "github.com/segmentio/ksuid"
)

type InternalAgentService struct {
        internalAgentV1.UnimplementedInternalAgentServer

        agentUseCase biz.AgentUseCaseInterface
        log          *log.Helper
}

func NewInternalAgentService(agentUseCase biz.AgentUseCaseInterface, logger log.Logger) *InternalAgentService <span class="cov8" title="1">{
        return &amp;InternalAgentService{
                agentUseCase: agentUseCase,
                log:          log.NewHelper(logger),
        }
}</span>

func (s *InternalAgentService) AddAgent(ctx context.Context, req *internalAgentV1.AddAgentRequest) (*internalAgentV1.AddAgentReply, error) <span class="cov8" title="1">{
        // web.agent
        // id        =&gt; api usage
        // unique id =&gt; agent-gateway-discovery internal usage
        s.log.Infof("add agent request: %+v", req)

        addAgent := &amp;dto.Agent{
                ID:       ksuid.New().String(),
                UniqueID: req.GetId(),
                Version:  req.GetVersion(),
        }

        aid, err := s.agentUseCase.AddAgent(ctx, addAgent)
        if err != nil </span><span class="cov8" title="1">{
                s.log.Errorf("add agent error: %s", err.Error())
                return nil, ErrorAddAgentError("failed to add new agent, error: %s", err.Error())
        }</span>

        <span class="cov8" title="1">return &amp;internalAgentV1.AddAgentReply{
                Id: aid,
        }, nil</span>
}
</pre>

		<pre class="file" id="file51" style="display: none">package service

import (
        "context"

        gatewayOperationV1 "git.synology.inc/sast/access-system/server/gateway/api/operation/v1"
        userCredentialV1 "git.synology.inc/sast/access-system/server/web/api/user_credential/v1"

        operationV1 "git.synology.inc/sast/access-system/server/web/api/operation/v1"
        "git.synology.inc/sast/access-system/server/web/internal/biz"
        "github.com/go-kratos/kratos/v2/log"
)

type OperationService struct {
        operationV1.UnimplementedOperationServer

        discoveryService  DiscoveryServiceInterface
        agentUseCase      biz.AgentUseCaseInterface
        doorUseCase       biz.DoorUseCaseInterface
        controllerUseCase biz.ControllerUseCaseInterface
        idPointUseCase    biz.IDPointUseCaseInterface
        log               *log.Helper
}

func NewOperationService(doorUseCase biz.DoorUseCaseInterface, controllerUseCase biz.ControllerUseCaseInterface,
        discoveryService DiscoveryServiceInterface,
        agentUseCase biz.AgentUseCaseInterface,
        idPointUseCase biz.IDPointUseCaseInterface, logger log.Logger) *OperationService <span class="cov0" title="0">{

        return &amp;OperationService{
                discoveryService:  discoveryService,
                doorUseCase:       doorUseCase,
                controllerUseCase: controllerUseCase,
                agentUseCase:      agentUseCase,
                idPointUseCase:    idPointUseCase,
                log:               log.NewHelper(logger),
        }
}</span>

func (s *OperationService) TestConnection(ctx context.Context, req *operationV1.TestConnectionRequest,
) (*operationV1.TestConnectionReply, error) <span class="cov0" title="0">{

        // Get agent unique id from agent id
        agent, err := s.agentUseCase.GetAgent(context.Background(), req.GetAgent())
        if err != nil </span><span class="cov0" title="0">{
                s.log.Errorf("agent: %s not found", req.GetAgent())
                return nil, ErrorAgentNotFount("agent: %s not found", req.GetAgent())
        }</span>

        // Get gateway connection
        <span class="cov0" title="0">conn, err := s.discoveryService.Get(agent.UniqueID)
        if err != nil </span><span class="cov0" title="0">{
                s.log.Errorf("failed to get gateway connection: %s for agent %s, uniqueID: %s", err.Error(), agent.ID, agent.UniqueID)
                return nil, ErrorCanNotGetGatewayConnection(
                        "failed to get gateway connection: %s for agent %s, uniqueID: %s", err.Error(), agent.ID, agent.UniqueID)
        }</span>

        // Act
        <span class="cov0" title="0">_, err = conn.Operation.TestConnection(ctx, &amp;gatewayOperationV1.TestConnectionRequest{
                AgentId:  agent.UniqueID,
                Ip:       req.GetBody().GetIp(),
                Model:    req.GetBody().GetModel(),
                Vendor:   req.GetBody().GetVendor(),
                Account:  req.GetBody().GetAccount(),
                Password: req.GetBody().GetPassword(),
        })
        if err != nil </span><span class="cov0" title="0">{
                s.log.Errorf("failed to test connection %s: %s", req.GetAgent(), err.Error())
                return nil, ErrorCanNotPingAgent("failed to ping agent %s: %s", req.GetAgent(), err.Error())
        }</span>

        <span class="cov0" title="0">return &amp;operationV1.TestConnectionReply{}, nil</span>
}

// The door will only open briefly and will automatically lock when closed
func (s *OperationService) AccessDoor(ctx context.Context, req *operationV1.AccessDoorRequest) (*operationV1.AccessDoorReply, error) <span class="cov0" title="0">{
        s.log.Infof("AccessDoor: %+v", req)

        door, err := s.doorUseCase.GetDoor(context.Background(), req.GetId())
        if err != nil </span><span class="cov0" title="0">{
                s.log.Errorf("get webDB door error: %s", err.Error())
                return nil, ErrorGetDoorError("failed to get webDB door, error: %s", err.Error())
        }</span>

        <span class="cov0" title="0">if req.GetController() != door.ControllerID </span><span class="cov0" title="0">{
                s.log.Errorf("validate controller error: door ControllerID not match")
                return nil, ErrorValidateDoorError("validate controller error: door ControllerID not match")
        }</span>

        <span class="cov0" title="0">controller, err := s.controllerUseCase.GetController(context.Background(), door.ControllerID)
        if err != nil </span><span class="cov0" title="0">{
                s.log.Errorf("get webDB controller error: %s", err.Error())
                return nil, ErrorGetControllerError("failed to get webDB controller, error: %s", err.Error())
        }</span>

        <span class="cov0" title="0">if req.GetAgent() != controller.AgentID </span><span class="cov0" title="0">{
                s.log.Errorf("validate agent error: door agentID not match")
                return nil, ErrorValidateDoorError("validate agent error: door agentID not match")
        }</span>

        <span class="cov0" title="0">agent, err := s.agentUseCase.GetAgent(context.Background(), req.GetAgent())
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">conn, err := s.discoveryService.Get(agent.UniqueID)
        if err != nil </span><span class="cov0" title="0">{
                s.log.Errorf("failed to get gateway connection: %s for agent %s, uniqueID: %s", err.Error(), agent.ID, agent.UniqueID)
                return nil, ErrorCanNotGetGatewayConnection(
                        "failed to get gateway connection: %s for agent %s, uniqueID: %s", err.Error(), agent.ID, agent.UniqueID)
        }</span>

        <span class="cov0" title="0">_, err = conn.Operation.AccessDoor(ctx, &amp;gatewayOperationV1.AccessDoorRequest{
                AgentId:      agent.UniqueID,
                ControllerId: controller.UniqueID,
                DoorEntity:   door.Entity,
        })
        if err != nil </span><span class="cov0" title="0">{
                s.log.Errorf("access door to agent error: %s", err.Error())
                return nil, ErrorAccessDoorError("failed to access door to agent, error: %s", err.Error())
        }</span>

        <span class="cov0" title="0">return &amp;operationV1.AccessDoorReply{}, nil</span>
}

// The door will remain open continuously
func (s *OperationService) UnlockDoor(ctx context.Context, req *operationV1.UnlockDoorRequest) (*operationV1.UnlockDoorReply, error) <span class="cov0" title="0">{
        s.log.Infof("UnlockDoor: %+v", req)

        door, err := s.doorUseCase.GetDoor(context.Background(), req.GetId())
        if err != nil </span><span class="cov0" title="0">{
                s.log.Errorf("get webDB door error: %s", err.Error())
                return nil, ErrorGetDoorError("failed to get webDB door, error: %s", err.Error())
        }</span>

        <span class="cov0" title="0">if req.GetController() != door.ControllerID </span><span class="cov0" title="0">{
                s.log.Errorf("validate controller error: door ControllerID not match")
                return nil, ErrorValidateDoorError("validate controller error: door ControllerID not match")
        }</span>

        <span class="cov0" title="0">controller, err := s.controllerUseCase.GetController(context.Background(), door.ControllerID)
        if err != nil </span><span class="cov0" title="0">{
                s.log.Errorf("get webDB controller error: %s", err.Error())
                return nil, ErrorGetControllerError("failed to get webDB controller, error: %s", err.Error())
        }</span>

        <span class="cov0" title="0">if req.GetAgent() != controller.AgentID </span><span class="cov0" title="0">{
                s.log.Errorf("validate agent error: door agentID not match")
                return nil, ErrorValidateDoorError("validate agent error: door agentID not match")
        }</span>

        <span class="cov0" title="0">agent, err := s.agentUseCase.GetAgent(context.Background(), req.GetAgent())
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">conn, err := s.discoveryService.Get(agent.UniqueID)
        if err != nil </span><span class="cov0" title="0">{
                s.log.Errorf("failed to get gateway connection: %s for agent %s, uniqueID: %s", err.Error(), agent.ID, agent.UniqueID)
                return nil, ErrorCanNotGetGatewayConnection(
                        "failed to get gateway connection: %s for agent %s, uniqueID: %s", err.Error(), agent.ID, agent.UniqueID)
        }</span>

        <span class="cov0" title="0">_, err = conn.Operation.UnlockDoor(ctx, &amp;gatewayOperationV1.UnlockDoorRequest{
                AgentId:      agent.UniqueID,
                ControllerId: controller.UniqueID,
                DoorEntity:   door.Entity,
        })
        if err != nil </span><span class="cov0" title="0">{
                s.log.Errorf("unlock door to agent error: %s", err.Error())
                return nil, ErrorUnlockDoorError("failed to unlock door to agent, error: %s", err.Error())
        }</span>

        <span class="cov0" title="0">return &amp;operationV1.UnlockDoorReply{}, nil</span>
}

// Lock the door
func (s *OperationService) LockDoor(ctx context.Context, req *operationV1.LockDoorRequest) (*operationV1.LockDoorReply, error) <span class="cov0" title="0">{
        s.log.Infof("LockDoor: %+v", req)

        door, err := s.doorUseCase.GetDoor(context.Background(), req.GetId())
        if err != nil </span><span class="cov0" title="0">{
                s.log.Errorf("get webDB door error: %s", err.Error())
                return nil, ErrorGetDoorError("failed to get webDB door, error: %s", err.Error())
        }</span>

        <span class="cov0" title="0">if req.GetController() != door.ControllerID </span><span class="cov0" title="0">{
                s.log.Errorf("validate controller error: door ControllerID not match")
                return nil, ErrorValidateDoorError("validate controller error: door ControllerID not match")
        }</span>

        <span class="cov0" title="0">controller, err := s.controllerUseCase.GetController(context.Background(), door.ControllerID)
        if err != nil </span><span class="cov0" title="0">{
                s.log.Errorf("get webDB controller error: %s", err.Error())
                return nil, ErrorGetControllerError("failed to get webDB controller, error: %s", err.Error())
        }</span>

        <span class="cov0" title="0">if req.GetAgent() != controller.AgentID </span><span class="cov0" title="0">{
                s.log.Errorf("validate agent error: door agentID not match")
                return nil, ErrorValidateDoorError("validate agent error: door agentID not match")
        }</span>

        <span class="cov0" title="0">agent, err := s.agentUseCase.GetAgent(context.Background(), req.GetAgent())
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">conn, err := s.discoveryService.Get(agent.UniqueID)
        if err != nil </span><span class="cov0" title="0">{
                s.log.Errorf("failed to get gateway connection: %s for agent %s, uniqueID: %s", err.Error(), agent.ID, agent.UniqueID)
                return nil, ErrorCanNotGetGatewayConnection(
                        "failed to get gateway connection: %s for agent %s, uniqueID: %s", err.Error(), agent.ID, agent.UniqueID)
        }</span>

        <span class="cov0" title="0">_, err = conn.Operation.LockDoor(ctx, &amp;gatewayOperationV1.LockDoorRequest{
                AgentId:      agent.UniqueID,
                ControllerId: controller.UniqueID,
                DoorEntity:   door.Entity,
        })
        if err != nil </span><span class="cov0" title="0">{
                s.log.Errorf("lock door to agent error: %s", err.Error())
                return nil, ErrorLockDoorError("failed to lock door to agent, error: %s", err.Error())
        }</span>

        <span class="cov0" title="0">return &amp;operationV1.LockDoorReply{}, nil</span>
}

func (s *OperationService) GetReaderLastCard(ctx context.Context, req *operationV1.GetReaderLastCardRequest,
) (*operationV1.GetReaderLastCardReply, error) <span class="cov0" title="0">{

        s.log.Debugf("GetReaderLastCard: %+v", req)

        idPoint, err := s.idPointUseCase.GetIDPoint(context.Background(), req.GetId())
        if err != nil </span><span class="cov0" title="0">{
                s.log.Errorf("get webDB id point error: %s", err.Error())
                return nil, ErrorGetIdPointError("failed to get webDB id point, error: %s", err.Error())
        }</span>

        <span class="cov0" title="0">if req.GetController() != idPoint.ControllerID </span><span class="cov0" title="0">{
                s.log.Errorf("validate controller error: id point ControllerID not match")
                return nil, ErrorValidateIdPointError("validate controller error: id point ControllerID not match")
        }</span>

        <span class="cov0" title="0">controller, err := s.controllerUseCase.GetController(context.Background(), idPoint.ControllerID)
        if err != nil </span><span class="cov0" title="0">{
                s.log.Errorf("get webDB controller error: %s", err.Error())
                return nil, ErrorGetControllerError("failed to get webDB controller, error: %s", err.Error())
        }</span>

        <span class="cov0" title="0">if req.GetAgent() != controller.AgentID </span><span class="cov0" title="0">{
                s.log.Errorf("validate agent error: id point agentID not match")
                return nil, ErrorValidateIdPointError("validate agent error: id point agentID not match")
        }</span>

        <span class="cov0" title="0">agent, err := s.agentUseCase.GetAgent(context.Background(), req.GetAgent())
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">conn, err := s.discoveryService.Get(agent.UniqueID)
        if err != nil </span><span class="cov0" title="0">{
                s.log.Errorf("failed to get gateway connection: %s for agent %s, uniqueID: %s", err.Error(), agent.ID, agent.UniqueID)
                return nil, ErrorCanNotGetGatewayConnection(
                        "failed to get gateway connection: %s for agent %s, uniqueID: %s", err.Error(), agent.ID, agent.UniqueID)
        }</span>

        <span class="cov0" title="0">CardInfo, err := conn.Operation.GetReaderLastCard(ctx, &amp;gatewayOperationV1.GetReaderLastCardRequest{
                AgentId:      agent.UniqueID,
                ControllerId: controller.UniqueID,
                ReaderToken:  idPoint.Token,
        })
        if err != nil </span><span class="cov0" title="0">{
                s.log.Errorf("get reader last card to agent error: %s", err.Error())
                return nil, ErrorGetLastCardError("failed to get reader last card to agent, error: %s", err.Error())
        }</span>

        <span class="cov0" title="0">return &amp;operationV1.GetReaderLastCardReply{
                Card: &amp;userCredentialV1.Data_CardInfo{
                        CardNumber:   CardInfo.CardNumber,
                        FacilityCode: CardInfo.Card,
                },
        }, nil</span>
}
</pre>

		<pre class="file" id="file52" style="display: none">package service

import (
        "context"
        "time"

        scheduleV1 "git.synology.inc/sast/access-system/server/web/api/schedule/v1"
        "git.synology.inc/sast/access-system/server/web/internal/biz"
        "git.synology.inc/sast/access-system/server/web/internal/datastore/dto"
        "github.com/go-kratos/kratos/v2/log"
        "github.com/segmentio/ksuid"
        "google.golang.org/protobuf/types/known/emptypb"
)

const (
        layout = "20060102"
)

type ScheduleService struct {
        scheduleV1.UnimplementedScheduleServer

        scheduleUseCase biz.ScheduleUseCaseInterface
        log             *log.Helper
}

func NewScheduleService(scheduleUseCase biz.ScheduleUseCaseInterface, logger log.Logger) *ScheduleService <span class="cov0" title="0">{
        return &amp;ScheduleService{
                scheduleUseCase: scheduleUseCase,
                log:             log.NewHelper(logger),
        }
}</span>

func isValidDate(date string) bool <span class="cov0" title="0">{
        _, err := time.Parse(layout, date)
        return err == nil
}</span>

func (s *ScheduleService) AddSchedule(ctx context.Context, req *scheduleV1.AddScheduleRequest) (*scheduleV1.AddScheduleReply, error) <span class="cov0" title="0">{
        schedule := &amp;dto.Schedule{
                ID:          ksuid.New().String(),
                Name:        req.GetBody().GetSchedule().GetName(),
                Description: req.GetBody().GetSchedule().GetDescription(),
                Schedules:   req.GetBody().GetSchedule().GetSchedule(),
        }

        scheduleID, err := s.scheduleUseCase.AddSchedule(ctx, schedule)
        if err != nil </span><span class="cov0" title="0">{
                s.log.Errorf("add webDB schedule error: %s", err.Error())
                return nil, ErrorAddScheduleError("failed to add webDB schedule, error: %s", err.Error())
        }</span>

        <span class="cov0" title="0">return &amp;scheduleV1.AddScheduleReply{
                Id: scheduleID,
        }, nil</span>
}

func (s *ScheduleService) UpdateSchedule(ctx context.Context,
        req *scheduleV1.UpdateScheduleRequest) (*emptypb.Empty, error) <span class="cov0" title="0">{

        schedule := &amp;dto.Schedule{
                ID:          req.GetId(),
                Name:        req.GetBody().GetSchedule().GetName(),
                Description: req.GetBody().GetSchedule().GetDescription(),
                Schedules:   req.GetBody().GetSchedule().GetSchedule(),
        }

        err := s.scheduleUseCase.UpdateSchedule(ctx, schedule)
        if err != nil </span><span class="cov0" title="0">{
                s.log.Errorf("update webDB schedule error: %s", err.Error())
                return nil, ErrorUpdateScheduleError("failed to update webDB schedule, error: %s", err.Error())
        }</span>

        <span class="cov0" title="0">return &amp;emptypb.Empty{}, nil</span>
}

func (s *ScheduleService) DeleteSchedule(ctx context.Context,
        req *scheduleV1.DeleteScheduleRequest) (*emptypb.Empty, error) <span class="cov0" title="0">{

        schedule := &amp;dto.Schedule{
                ID: req.GetId(),
        }

        err := s.scheduleUseCase.DeleteSchedule(ctx, schedule)
        if err != nil </span><span class="cov0" title="0">{
                s.log.Errorf("delete webDB schedule error: %s", err.Error())
                return nil, ErrorDeleteScheduleError("failed to delete webDB schedule, error: %s", err.Error())
        }</span>

        <span class="cov0" title="0">return &amp;emptypb.Empty{}, nil</span>
}

func (s *ScheduleService) GetSchedule(ctx context.Context, req *scheduleV1.GetScheduleRequest) (*scheduleV1.GetScheduleReply, error) <span class="cov0" title="0">{
        scheduleID := req.GetId()

        schedule, err := s.scheduleUseCase.GetSchedule(ctx, scheduleID)
        if err != nil </span><span class="cov0" title="0">{
                s.log.Errorf("get webDB schedule error: %s", err.Error())
                return nil, ErrorGetScheduleError("failed to get webDB schedule, error: %s", err.Error())
        }</span>

        <span class="cov0" title="0">return &amp;scheduleV1.GetScheduleReply{
                Schedule: schedule.ToPbSchedule(),
        }, nil</span>
}

func (s *ScheduleService) ListSchedule(ctx context.Context, req *scheduleV1.ListScheduleRequest) (*scheduleV1.ListScheduleReply, error) <span class="cov0" title="0">{
        scheduleWithException, total, err := s.scheduleUseCase.ListSchedule(ctx, req.GetOffset(), req.GetLimit())
        if err != nil </span><span class="cov0" title="0">{
                s.log.Errorf("list webDB schedule error: %s", err.Error())
                return nil, ErrorListScheduleError("failed to list webDB schedule, error: %s", err.Error())
        }</span>

        <span class="cov0" title="0">reply := &amp;scheduleV1.ListScheduleReply{
                Total:     total,
                Schedules: make([]*scheduleV1.ScheduleWithException, 0, len(scheduleWithException)),
        }

        for _, schedule := range scheduleWithException </span><span class="cov0" title="0">{
                reply.Schedules = append(reply.Schedules, schedule.ToPbScheduleWithException())
        }</span>

        <span class="cov0" title="0">return reply, nil</span>
}

func (s *ScheduleService) AddException(ctx context.Context, req *scheduleV1.AddExceptionRequest) (*scheduleV1.AddExceptionReply, error) <span class="cov0" title="0">{
        exception := &amp;dto.Exception{
                ID:             ksuid.New().String(),
                Name:           req.GetBody().GetException().GetName(),
                Description:    req.GetBody().GetException().GetDescription(),
                ExceptionDates: make([]*dto.ExceptionDate, 0, len(req.GetBody().GetException().GetDates())),
        }
        for _, exceptionDate := range req.GetBody().GetException().GetDates() </span><span class="cov0" title="0">{
                if !isValidDate(exceptionDate.GetDate()) </span><span class="cov0" title="0">{
                        s.log.Errorf("invalid date format: %s", exceptionDate.GetDate())
                        continue</span>
                }
                <span class="cov0" title="0">exception.ExceptionDates = append(exception.ExceptionDates, &amp;dto.ExceptionDate{
                        ID:             ksuid.New().String(),
                        Date:           exceptionDate.GetDate(),
                        Description:    exceptionDate.GetDescription(),
                        ExceptionID:    exception.ID,
                        RepeatedYearly: exceptionDate.GetRepeatedYearly(),
                })</span>
        }

        <span class="cov0" title="0">exceptionID, err := s.scheduleUseCase.AddException(ctx, exception)
        if err != nil </span><span class="cov0" title="0">{
                s.log.Errorf("add webDB exception error: %s", err.Error())
                return nil, ErrorAddExceptionError("failed to add webDB exception, error: %s", err.Error())
        }</span>

        <span class="cov0" title="0">return &amp;scheduleV1.AddExceptionReply{
                Id: exceptionID,
        }, nil</span>
}

func (s *ScheduleService) UpdateException(ctx context.Context,
        req *scheduleV1.UpdateExceptionRequest) (*emptypb.Empty, error) <span class="cov0" title="0">{

        exception := &amp;dto.Exception{
                ID:             req.GetId(),
                Name:           req.GetBody().GetException().GetName(),
                Description:    req.GetBody().GetException().GetDescription(),
                ExceptionDates: make([]*dto.ExceptionDate, 0, len(req.GetBody().GetException().GetDates())),
        }
        for _, exceptionDate := range req.GetBody().GetException().GetDates() </span><span class="cov0" title="0">{
                exception.ExceptionDates = append(exception.ExceptionDates, &amp;dto.ExceptionDate{
                        ID:             ksuid.New().String(),
                        Date:           exceptionDate.GetDate(),
                        Description:    exceptionDate.GetDescription(),
                        ExceptionID:    exception.ID,
                        RepeatedYearly: exceptionDate.GetRepeatedYearly(),
                })
        }</span>

        <span class="cov0" title="0">err := s.scheduleUseCase.UpdateException(ctx, exception)
        if err != nil </span><span class="cov0" title="0">{
                s.log.Errorf("update webDB exception error: %s", err.Error())
                return nil, ErrorUpdateExceptionError("failed to update webDB exception, error: %s", err.Error())
        }</span>

        <span class="cov0" title="0">return &amp;emptypb.Empty{}, nil</span>
}

func (s *ScheduleService) DeleteException(ctx context.Context,
        req *scheduleV1.DeleteExceptionRequest) (*emptypb.Empty, error) <span class="cov0" title="0">{

        exception := &amp;dto.Exception{
                ID: req.GetId(),
        }

        err := s.scheduleUseCase.DeleteException(ctx, exception)
        if err != nil </span><span class="cov0" title="0">{
                s.log.Errorf("delete webDB exception error: %s", err.Error())
                return nil, ErrorDeleteExceptionError("failed to delete webDB exception, error: %s", err.Error())
        }</span>

        <span class="cov0" title="0">return &amp;emptypb.Empty{}, nil</span>
}

func (s *ScheduleService) GetException(ctx context.Context, req *scheduleV1.GetExceptionRequest) (*scheduleV1.GetExceptionReply, error) <span class="cov0" title="0">{
        exceptionID := req.GetId()

        exception, err := s.scheduleUseCase.GetException(ctx, exceptionID)
        if err != nil </span><span class="cov0" title="0">{
                s.log.Errorf("get webDB exception error: %s", err.Error())
                return nil, ErrorGetExceptionError("failed to get webDB exception, error: %s", err.Error())
        }</span>

        <span class="cov0" title="0">return &amp;scheduleV1.GetExceptionReply{
                Exception: exception.ToPbExceptionWithDates(),
        }, nil</span>
}

func (s *ScheduleService) ListException(ctx context.Context, req *scheduleV1.ListExceptionRequest) (*scheduleV1.ListExceptionReply, error) <span class="cov0" title="0">{
        exceptions, total, err := s.scheduleUseCase.ListException(ctx, req.GetOffset(), req.GetLimit())
        if err != nil </span><span class="cov0" title="0">{
                s.log.Errorf("list webDB exception error: %s", err.Error())
                return nil, ErrorListExceptionError("failed to list webDB exception, error: %s", err.Error())
        }</span>

        <span class="cov0" title="0">reply := &amp;scheduleV1.ListExceptionReply{
                Total:      total,
                Exceptions: make([]*scheduleV1.ExceptionInfoWithID, 0, len(exceptions)),
        }

        for _, exception := range exceptions </span><span class="cov0" title="0">{
                reply.Exceptions = append(reply.Exceptions, exception.ToPbExceptionWithDates())
        }</span>

        <span class="cov0" title="0">return reply, nil</span>
}

func (s *ScheduleService) ListExceptionBySchedule(ctx context.Context,
        req *scheduleV1.ListExceptionByScheduleRequest) (*scheduleV1.ListExceptionByScheduleReply, error) <span class="cov0" title="0">{

        exceptions, total, err := s.scheduleUseCase.ListExceptionBySchedule(ctx, req.GetSchedule(), req.GetOffset(), req.GetLimit())
        if err != nil </span><span class="cov0" title="0">{
                s.log.Errorf("list webDB exception by schedule error: %s", err.Error())
                return nil, ErrorListExceptionByScheduleError("failed to list webDB exception by schedule, error: %s", err.Error())
        }</span>

        <span class="cov0" title="0">reply := &amp;scheduleV1.ListExceptionByScheduleReply{
                Total:      total,
                Exceptions: make([]*scheduleV1.ExceptionWithDailySchedule, 0, len(exceptions)),
        }

        for _, exception := range exceptions </span><span class="cov0" title="0">{
                reply.Exceptions = append(reply.Exceptions, exception.ToPbExceptionWithDailySchedule())
        }</span>

        <span class="cov0" title="0">return reply, nil</span>
}

func (s *ScheduleService) ApplyException(ctx context.Context,
        req *scheduleV1.ApplyExceptionRequest) (*emptypb.Empty, error) <span class="cov0" title="0">{

        exceptionSchedules := make([]*dto.ExceptionSchedule, 0, len(req.GetBody().GetScheduleExceptions()))
        for _, exceptionSchedule := range req.GetBody().GetScheduleExceptions() </span><span class="cov0" title="0">{
                exceptionSchedules = append(exceptionSchedules, &amp;dto.ExceptionSchedule{
                        ExceptionID:   exceptionSchedule.GetExceptionId(),
                        DailySchedule: exceptionSchedule.GetDailySchedule(),
                })
        }</span>

        <span class="cov0" title="0">err := s.scheduleUseCase.ApplyException(ctx, req.GetSchedule(), exceptionSchedules)
        if err != nil </span><span class="cov0" title="0">{
                s.log.Errorf("apply webDB exceptions on a schedule error: %s", err.Error())
                return nil, ErrorApplyExceptionError("failed to apply webDB exceptions on a schedule, error: %s", err.Error())
        }</span>

        <span class="cov0" title="0">return &amp;emptypb.Empty{}, nil</span>
}
</pre>

		<pre class="file" id="file53" style="display: none">package service

import (
        "context"
        "fmt"

        "github.com/go-kratos/kratos/v2/log"
        "github.com/samber/lo"
        "google.golang.org/protobuf/types/known/emptypb"

        "git.synology.inc/sast/access-system/server/internal/taskqueue"
        taskqueueSync "git.synology.inc/sast/access-system/server/internal/taskqueue/sync"
        "git.synology.inc/sast/access-system/server/internal/taskqueue/task"
        "git.synology.inc/sast/access-system/server/internal/taskqueue/taskbase"

        "git.synology.inc/sast/access-system/server/discovery/client"
        gatewaySyncV1 "git.synology.inc/sast/access-system/server/gateway/api/sync/v1"
        syncV1 "git.synology.inc/sast/access-system/server/web/api/sync/v1"
        "git.synology.inc/sast/access-system/server/web/internal/biz"
        "git.synology.inc/sast/access-system/server/web/internal/conf"
        "git.synology.inc/sast/access-system/server/web/internal/data"
        "git.synology.inc/sast/access-system/server/web/internal/datastore/dto"
)

const (
        agentQueueNameTemplate = "agent_%s"
        syncTaskQueueName      = "sync"
)

//go:generate bash ../../../mock.sh

type SyncServiceInterface interface {
        Close()

        // public api
        Resync(context.Context, *syncV1.ResyncRequest) (*emptypb.Empty, error)

        // internal api
        SyncPostAddController(context.Context, *dto.Controller) error

        SyncPostAddUser(context.Context, *dto.User) error
        SyncPostDeleteUser(context.Context, *dto.User) error

        SyncPostAddAccessRule(context.Context, *dto.AccessRule) error
        SyncPostDeleteAccessRule(context.Context, *dto.AccessRule) error
        SyncPostAccessRuleAddUser(context.Context, string, []string) error
        SyncPostAccessRuleDeleteUser(context.Context, string, []string) error
        SyncPostAccessRuleAddDoor(ctx context.Context, accessRuleID string, doorIDs []string) error
        SyncPostAccessRuleDeleteDoor(ctx context.Context, accessRuleID string, doorIDs []string) error

        SyncPostAddCredential(ctx context.Context, c *dto.User, credentials []*dto.UserCredential) error
        SyncPostDeleteCredential(ctx context.Context, credentials *dto.UserCredential) error
}

type SyncService struct {
        syncV1.UnimplementedSyncServer

        log  *log.Helper
        data data.DataInterface

        // task queue ,cancel, and routine cancel
        syncQueueManager       taskqueue.TaskQueueManager
        syncQueueManagerCancel func()
        syncQueueRoutineCancel func()

        discoveryService      DiscoveryServiceInterface
        agentUseCase          biz.AgentUseCaseInterface
        controllerUseCase     biz.ControllerUseCaseInterface
        userUseCase           biz.UserUseCaseInterface
        userCredentialUseCase biz.UserCredentialUseCaseInterface
}

func NewSyncService(logger log.Logger, c *conf.Sync, d data.DataInterface,
        discoveryService DiscoveryServiceInterface,
        agentUseCase biz.AgentUseCaseInterface, controllerUseCase biz.ControllerUseCaseInterface,
        userUseCase biz.UserUseCaseInterface, userCredentialUseCase biz.UserCredentialUseCaseInterface) (
        SyncServiceInterface, func(), error) <span class="cov0" title="0">{

        // cancel function should cancel all running routines on task queue
        tqm, cancel, err := taskqueue.NewTaskQueueManager(c.GetTaskQueue(), logger)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, ErrorNewSyncServiceFail("failed to create task queue manager, error: %s", err.Error())
        }</span>

        <span class="cov0" title="0">syncService := &amp;SyncService{
                log:                    log.NewHelper(logger),
                data:                   d,
                syncQueueManager:       tqm,
                syncQueueManagerCancel: cancel,
                syncQueueRoutineCancel: nil,
                discoveryService:       discoveryService,
                agentUseCase:           agentUseCase,
                controllerUseCase:      controllerUseCase,
                userUseCase:            userUseCase,
                userCredentialUseCase:  userCredentialUseCase,
        }

        err = syncService.init()
        if err != nil </span><span class="cov0" title="0">{
                return nil, syncService.Close, ErrorNewSyncServiceFail("failed to init sync service, error: %s", err.Error())
        }</span>

        <span class="cov0" title="0">return syncService, syncService.Close, nil</span>
}

func (s *SyncService) setupTaskQueueManager() error <span class="cov0" title="0">{
        s.log.Debugf("sync service setup task queue")

        err := s.syncQueueManager.CreateQueue(syncTaskQueueName)
        if err != nil </span><span class="cov0" title="0">{
                s.log.Errorf("failed to create task queue, error: %s", err.Error())
                return ErrorSetupTaskQueueManagerFail("failed to create task queue, error: %s", err.Error())
        }</span>

        // setup sync queue routine env context
        <span class="cov0" title="0">bgCtx := context.Background()
        routineCtx := context.WithValue(bgCtx, taskbase.TaskResourceWebData, s.data)
        routineCtx, cancel := context.WithCancel(routineCtx)
        s.syncQueueRoutineCancel = func() </span><span class="cov0" title="0">{
                cancel()
                err := s.syncQueueManager.DeleteQueue(syncTaskQueueName)
                if err != nil </span><span class="cov0" title="0">{
                        s.log.Errorf("failed to delete task queue, error: %s", err.Error())
                }</span>
        }

        <span class="cov0" title="0">handlerMap := map[string]taskbase.TaskHandler{
                taskqueueSync.SyncResetControllerTaskID: func(ctx context.Context, t taskbase.Task) error </span><span class="cov0" title="0">{
                        task, ok := t.(*taskqueueSync.SyncResetControllerTask)
                        if !ok </span><span class="cov0" title="0">{
                                s.log.Errorf("failed to cast task to SyncResetControllerTask, task: %+v", t)
                                return ErrorPrerunTaskFail("failed to cast task to SyncResetControllerTask, task: %+v", t)
                        }</span>
                        <span class="cov0" title="0">s.log.Infof("web run sync reset controller task, task: %+v", task)
                        // nothing to do in the web part except for waiting result from agent
                        // TODO: handle reported result from agent
                        return nil</span>
                },
                taskqueueSync.SyncInitControllerTaskID: func(ctx context.Context, t taskbase.Task) error <span class="cov0" title="0">{
                        task, ok := t.(*taskqueueSync.SyncInitControllerTask)
                        if !ok </span><span class="cov0" title="0">{
                                s.log.Errorf("failed to cast task to SyncInitControllerTask, task: %+v", t)
                                return ErrorPrerunTaskFail("failed to cast task to SyncInitControllerTask, task: %+v", t)
                        }</span>
                        <span class="cov0" title="0">s.log.Infof("web run sync init controller task, task: %+v", task)
                        // nothing to do in the web part except for waiting result from agent
                        // TODO: handle reported result from agent
                        return nil</span>
                },
                taskqueueSync.SyncAddUserTaskID: func(ctx context.Context, t taskbase.Task) error <span class="cov0" title="0">{
                        task, ok := t.(*taskqueueSync.SyncAddUserTask)
                        if !ok </span><span class="cov0" title="0">{
                                s.log.Errorf("failed to cast task to SyncAddUserTask, task: %+v", t)
                                return ErrorPrerunTaskFail("failed to cast task to SyncAddUserTask, task: %+v", t)
                        }</span>
                        <span class="cov0" title="0">s.log.Infof("web run sync add user task, task: %+v", task)
                        // nothing to do in the web part except for waiting result from agent
                        // TODO: handle reported result from agent
                        return nil</span>
                },
                taskqueueSync.SyncDeleteUserTaskID: func(ctx context.Context, t taskbase.Task) error <span class="cov0" title="0">{
                        task, ok := t.(*taskqueueSync.SyncDeleteUserTask)
                        if !ok </span><span class="cov0" title="0">{
                                s.log.Errorf("failed to cast task to SyncDeleteUserTask, task: %+v", t)
                                return ErrorPrerunTaskFail("failed to cast task to SyncDeleteUserTask, task: %+v", t)
                        }</span>
                        <span class="cov0" title="0">s.log.Infof("web run sync delete user task, task: %+v", task)
                        // nothing to do in the web part except for waiting result from agent
                        // TODO: handle reported result from agent
                        return nil</span>
                },
                taskqueueSync.SyncAddAccessRuleTaskID: func(ctx context.Context, t taskbase.Task) error <span class="cov0" title="0">{
                        task, ok := t.(*taskqueueSync.SyncAddAccessRuleTask)
                        if !ok </span><span class="cov0" title="0">{
                                s.log.Errorf("failed to cast task to SyncAddAccessRuleTask, task: %+v", t)
                                return ErrorPrerunTaskFail("failed to cast task to SyncAddAccessRuleTask, task: %+v", t)
                        }</span>
                        <span class="cov0" title="0">s.log.Infof("web run sync add access rule task, task: %+v", task)
                        // nothing to do in the web part except for waiting result from agent
                        // TODO: handle reported result from agent
                        return nil</span>
                },
                taskqueueSync.SyncDeleteAccessRuleTaskID: func(ctx context.Context, t taskbase.Task) error <span class="cov0" title="0">{
                        task, ok := t.(*taskqueueSync.SyncDeleteAccessRuleTask)
                        if !ok </span><span class="cov0" title="0">{
                                s.log.Errorf("failed to cast task to SyncDeleteAccessRuleTask, task: %+v", t)
                                return ErrorPrerunTaskFail("failed to cast task to SyncDeleteAccessRuleTask, task: %+v", t)
                        }</span>
                        <span class="cov0" title="0">s.log.Infof("web run sync delete access rule task, task: %+v", task)
                        // nothing to do in the web part except for waiting result from agent
                        // TODO: handle reported result from agent
                        return nil</span>
                },
                taskqueueSync.SyncAccessRuleAddUserTaskID: func(ctx context.Context, t taskbase.Task) error <span class="cov0" title="0">{
                        task, ok := t.(*taskqueueSync.SyncAccessRuleAddUserTask)
                        if !ok </span><span class="cov0" title="0">{
                                s.log.Errorf("failed to cast task to SyncAccessRuleAddUserTask, task: %+v", t)
                                return ErrorPrerunTaskFail("failed to cast task to SyncAccessRuleAddUserTask, task: %+v", t)
                        }</span>
                        <span class="cov0" title="0">s.log.Infof("web run sync access rule add user task, task: %+v", task)
                        // nothing to do in the web part except for waiting result from agent
                        // TODO: handle reported result from agent
                        return nil</span>
                },
                taskqueueSync.SyncAccessRuleDeleteUserTaskID: func(ctx context.Context, t taskbase.Task) error <span class="cov0" title="0">{
                        task, ok := t.(*taskqueueSync.SyncAccessRuleDeleteUserTask)
                        if !ok </span><span class="cov0" title="0">{
                                s.log.Errorf("failed to cast task to SyncAccessRuleDeleteUserTask, task: %+v", t)
                                return ErrorPrerunTaskFail("failed to cast task to SyncAccessRuleDeleteUserTask, task: %+v", t)
                        }</span>
                        <span class="cov0" title="0">s.log.Infof("web run sync access rule delete user task, task: %+v", task)
                        // nothing to do in the web part except for waiting result from agent
                        // TODO: handle reported result from agent
                        return nil</span>
                },
                taskqueueSync.SyncAccessRuleAddDoorTaskID: func(ctx context.Context, t taskbase.Task) error <span class="cov0" title="0">{
                        task, ok := t.(*taskqueueSync.SyncAccessRuleAddDoorTask)
                        if !ok </span><span class="cov0" title="0">{
                                s.log.Errorf("failed to cast task to SyncAccessRuleAddDoorTask, task: %+v", t)
                                return ErrorPrerunTaskFail("failed to cast task to SyncAccessRuleAddDoorTask, task: %+v", t)
                        }</span>
                        <span class="cov0" title="0">s.log.Infof("web run sync access rule add door task, task: %+v", task)
                        // nothing to do in the web part except for waiting result from agent
                        // TODO: handle reported result from agent
                        return nil</span>
                },
                taskqueueSync.SyncAccessRuleDeleteDoorTaskID: func(ctx context.Context, t taskbase.Task) error <span class="cov0" title="0">{
                        task, ok := t.(*taskqueueSync.SyncAccessRuleDeleteDoorTask)
                        if !ok </span><span class="cov0" title="0">{
                                s.log.Errorf("failed to cast task to SyncAccessRuleDeleteDoorTask, task: %+v", t)
                                return ErrorPrerunTaskFail("failed to cast task to SyncAccessRuleDeleteDoorTask, task: %+v", t)
                        }</span>
                        <span class="cov0" title="0">s.log.Infof("web run sync access rule delete door task, task: %+v", task)
                        // nothing to do in the web part except for waiting result from agent
                        // TODO: handle reported result from agent
                        return nil</span>
                },
                taskqueueSync.SyncAddCredentialTaskID: func(ctx context.Context, t taskbase.Task) error <span class="cov0" title="0">{
                        task, ok := t.(*taskqueueSync.SyncAddCredentialTask)
                        if !ok </span><span class="cov0" title="0">{
                                s.log.Errorf("failed to cast task to SyncAddCredentialTask, task: %+v", t)
                                return ErrorPrerunTaskFail("failed to cast task to SyncAddCredentialTask, task: %+v", t)
                        }</span>
                        <span class="cov0" title="0">s.log.Infof("web run sync add credential task, task: %+v", task)
                        // nothing to do in the web part except for waiting result from agent
                        // TODO: handle reported result from agent
                        return nil</span>
                },
                taskqueueSync.SyncDeleteCredentialTaskID: func(ctx context.Context, t taskbase.Task) error <span class="cov0" title="0">{
                        task, ok := t.(*taskqueueSync.SyncDeleteCredentialTask)
                        if !ok </span><span class="cov0" title="0">{
                                s.log.Errorf("failed to cast task to SyncDeleteCredentialTask, task: %+v", t)
                                return ErrorPrerunTaskFail("failed to cast task to SyncDeleteCredentialTask, task: %+v", t)
                        }</span>
                        <span class="cov0" title="0">s.log.Infof("web run sync delete credential task, task: %+v", task)
                        // nothing to do in the web part except for waiting result from agent
                        // TODO: handle reported result from agent
                        return nil</span>
                },
        }

        <span class="cov0" title="0">err = s.syncQueueManager.RegisterRunner(syncTaskQueueName, routineCtx, handlerMap)
        if err != nil </span><span class="cov0" title="0">{
                s.log.Errorf("failed to register runner, error: %s", err.Error())
                return ErrorSetupTaskQueueManagerFail("failed to register runner, error: %s", err.Error())
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (s *SyncService) runByAgentRoutine() error <span class="cov0" title="0">{
        s.log.Debugf("sync service run by agent routine")
        // TODO: get all agent in db and run a routine to handle by agent task queue
        return nil
}</span>

func (s *SyncService) init() error <span class="cov0" title="0">{
        s.log.Debugf("sync service init")

        err := s.setupTaskQueueManager()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = s.runByAgentRoutine()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (s *SyncService) getAgentQueueName(agentID string) string <span class="cov0" title="0">{
        return fmt.Sprintf(agentQueueNameTemplate, agentID)
}</span>

func (s *SyncService) addByAgentTask(agentID string, ctx context.Context, t taskbase.Task) error <span class="cov0" title="0">{
        // get agent queue name
        _ = s.getAgentQueueName(agentID)

        // TODO: wrap agent id and task into SyncDispatchAgentTask and push into sync queue
        //      then run sync queue routine to dispatch task to agent queue
        err := s.syncQueueManager.AddTask(syncTaskQueueName, ctx, t)
        if err != nil </span><span class="cov0" title="0">{
                s.log.Errorf("failed to add task to agent queue: %s", err.Error())
                return ErrorAddByAgentTaskFail("failed to add task to agent queue: %s", err.Error())
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// TODO: add GetGatewaySyncV1User in data interface user api and take userID for param only
func (s *SyncService) getSyncUserByUser(ctx context.Context, user *dto.User) (*gatewaySyncV1.UserInfo, error) <span class="cov0" title="0">{
        credentials, err := s.userCredentialUseCase.ListUserCredential(ctx, user.ID)
        if err != nil </span><span class="cov0" title="0">{
                s.log.Errorf("sync access rule list user credential error: %s", err.Error())
                return nil, ErrorGetSyncUserByUserFail("failed to list user credential, error: %s", err.Error())
        }</span>

        // Mapping credential user
        <span class="cov0" title="0">syncUser, err := user.ToGatewaySyncV1User(credentials)
        if err != nil </span><span class="cov0" title="0">{
                s.log.Errorf("sync access rule convert user to pb user error: %s", err.Error())
                return nil, ErrorGetSyncUserByUserFail("failed to convert user to pb user, error: %s", err.Error())
        }</span>

        <span class="cov0" title="0">return syncUser, nil</span>
}

func (s *SyncService) getAgentUniqueIDAndConnection(ctx context.Context, agentID string) (
        *client.GatewayConnection, string, error) <span class="cov0" title="0">{

        // Get controller agent
        agent, err := s.agentUseCase.GetAgent(ctx, agentID)
        if err != nil </span><span class="cov0" title="0">{
                s.log.Errorf("sync access rule get agent error: %s", err.Error())
                return nil, "", ErrorGetAgentUniqueIdAndConnectionFail("failed to get agent, error: %s", err.Error())
        }</span>
        // Get connection by agent
        <span class="cov0" title="0">conn, err := s.discoveryService.Get(agent.UniqueID)
        if err != nil </span><span class="cov0" title="0">{
                s.log.Errorf("failed to get gateway connection for agent %s, uniqueID: %s, err: %s",
                        agent.ID, agent.UniqueID, err.Error())
                return nil, "", ErrorGetAgentUniqueIdAndConnectionFail(
                        "failed to get gateway connection for agent %s, uniqueID: %s, err: %s",
                        agent.ID, agent.UniqueID, err.Error())
        }</span>

        <span class="cov0" title="0">return conn, agent.UniqueID, nil</span>
}

func (s *SyncService) addTaskToQueueAndSendTaskToAgent(ctx context.Context, agentID string, tasks []taskbase.Task) error <span class="cov0" title="0">{
        s.log.Infof("add task to queue and send task to agent: %s, task: %+v", agentID, tasks)

        taskDatas := make([]string, 0)
        for _, t := range tasks </span><span class="cov0" title="0">{
                // add task to by agent queue
                err := s.addByAgentTask(agentID, ctx, t)
                if err != nil </span><span class="cov0" title="0">{
                        s.log.Errorf("failed to add by agent task, error: %s", err.Error())
                        return ErrorAddTaskToQueueAndSendTaskToAgentFail("failed to add by agent task, error: %s", err.Error())
                }</span>

                <span class="cov0" title="0">taskBytes, err := task.ToBytes(t)
                if err != nil </span><span class="cov0" title="0">{
                        s.log.Errorf("failed to marshal task, error: %s", err.Error())
                        return ErrorAddTaskToQueueAndSendTaskToAgentFail("failed to marshal task, error: %s", err.Error())
                }</span>

                <span class="cov0" title="0">s.log.Debugf("taskBytes: %s\n", string(taskBytes))
                taskDatas = append(taskDatas, string(taskBytes))</span>
        }

        <span class="cov0" title="0">conn, agentUniqueID, err := s.getAgentUniqueIDAndConnection(ctx, agentID)
        if err != nil </span><span class="cov0" title="0">{
                s.log.Errorf("failed to get agent info, error: %s", err.Error())
                return ErrorAddTaskToQueueAndSendTaskToAgentFail("failed to get agent info, error: %s", err.Error())
        }</span>

        // do blocking call through gateway to trigger agent to sync access rule
        <span class="cov0" title="0">reply, err := conn.Sync.SyncAddAsyncTask(ctx, &amp;gatewaySyncV1.SyncAddAsyncTaskRequest{
                AgentId:   agentUniqueID,
                TaskDatas: taskDatas,
        })
        s.log.Infof("done sync add async task, reply: %+v", reply)
        if err != nil </span><span class="cov0" title="0">{
                s.log.Errorf("failed to do sync add async task failed, error: %s", err.Error())
                return ErrorAddTaskToQueueAndSendTaskToAgentFail("failed to do sync add async task, error: %s", err.Error())
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (s *SyncService) Close() <span class="cov0" title="0">{
        s.log.Infof("sync service close")

        // cancel thie running routines dealing with sync task queue
        if s.syncQueueRoutineCancel != nil </span><span class="cov0" title="0">{
                s.syncQueueRoutineCancel()
        }</span>

        // run sync task queue manager cancel
        <span class="cov0" title="0">s.syncQueueManagerCancel()</span>
}

// TODO: handle user &lt;----&gt; agent registration and task dispatch in cloud env
// after add controller, clear all controller data and sync all data to controller
func (s *SyncService) SyncPostAddController(ctx context.Context, c *dto.Controller) error <span class="cov0" title="0">{
        s.log.Infof("sync post add controller, controller: %+v", c)

        // TODO: this part should be handled by by agent queue routine
        // get all the users need to be registered to the controller
        users, err := s.data.ListAllUser(ctx)
        if err != nil </span><span class="cov0" title="0">{
                s.log.Errorf("failed to list all user, error: %s", err.Error())
                return ErrorSyncPostAddControllerFail("failed to list all user, error: %s", err.Error())
        }</span>

        // conver user to gateway sync user info
        <span class="cov0" title="0">pbUsers := make([]*gatewaySyncV1.UserInfo, 0)
        for _, user := range users </span><span class="cov0" title="0">{
                pbUser, err := s.getSyncUserByUser(ctx, user)
                if err != nil </span><span class="cov0" title="0">{
                        s.log.Errorf("failed to get sync user by user, error: %s", err.Error())
                        return ErrorSyncPostAddControllerFail("failed to get sync user by user, error: %s", err.Error())
                }</span>

                <span class="cov0" title="0">pbUsers = append(pbUsers, pbUser)</span>
        }

        // TODO: should use SyncDispatchAgentTask instead and dispatch task to by agent queue
        <span class="cov0" title="0">resetTask := taskqueueSync.NewSyncResetControllerTask().WithControllerID(c.UniqueID)
        initTask := taskqueueSync.NewSyncInitControllerTask().WithControllerInfo(c.UniqueID).WithUsers(pbUsers)

        err = s.addTaskToQueueAndSendTaskToAgent(ctx, c.AgentID, []taskbase.Task{resetTask, initTask})
        if err != nil </span><span class="cov0" title="0">{
                s.log.Errorf("failed to do sync add async task, error: %s", err.Error())
                return ErrorSyncPostAddControllerFail("failed to do sync add async task, error: %s", err.Error())
        }</span>

        <span class="cov0" title="0">s.log.Infof("done sync post add controller")

        return nil</span>
}

func (s *SyncService) SyncPostAddUser(ctx context.Context, u *dto.User) error <span class="cov0" title="0">{
        s.log.Infof("sync post add user, user: %+v", u)

        // TODO: this part should be handled by by agent queue routine
        // get all the users need to be registered to the controller
        controllers, _, err := s.data.ListAllController(ctx)
        if err != nil </span><span class="cov0" title="0">{
                s.log.Errorf("failed to list all controller, error: %s", err.Error())
                return ErrorSyncPostAddUserFail("failed to list all controller, error: %s", err.Error())
        }</span>

        // conver user to gateway sync user info
        <span class="cov0" title="0">syncUser, err := s.getSyncUserByUser(ctx, u)
        if err != nil </span><span class="cov0" title="0">{
                s.log.Errorf("failed to get sync user by user, error: %s", err.Error())
                return ErrorSyncPostAddUserFail("failed to get sync user by user, error: %s", err.Error())
        }</span>
        <span class="cov0" title="0">syncUsers := []*gatewaySyncV1.UserInfo{syncUser}

        // TODO: group controller by agent
        for _, controller := range controllers </span><span class="cov0" title="0">{
                addUserTask := taskqueueSync.NewSyncAddUserTask().
                        WithControllerInfo(controller.UniqueID).WithUsers(syncUsers)

                err = s.addTaskToQueueAndSendTaskToAgent(ctx, controller.AgentID, []taskbase.Task{addUserTask})
                if err != nil </span><span class="cov0" title="0">{
                        s.log.Errorf("failed to add task to agent and queue, error: %s", err.Error())
                        return ErrorSyncPostAddUserFail("failed to add task to agent and queue, error: %s", err.Error())
                }</span>
        }

        <span class="cov0" title="0">s.log.Infof("done sync post add user")

        return nil</span>
}

func (s *SyncService) SyncPostDeleteUser(ctx context.Context, user *dto.User) error <span class="cov0" title="0">{
        s.log.Infof("sync post delete user, user: %+v", user)

        // TODO: this part should be handled by by agent queue routine
        // get all the users need to be registered to the controller
        controllers, _, err := s.data.ListAllController(ctx)
        if err != nil </span><span class="cov0" title="0">{
                s.log.Errorf("failed to list all controller, error: %s", err.Error())
                return ErrorSyncPostDeleteUserFail("failed to list all controller, error: %s", err.Error())
        }</span>

        // conver user to gateway sync user info
        <span class="cov0" title="0">unsyncUser, err := s.getSyncUserByUser(ctx, user)
        if err != nil </span><span class="cov0" title="0">{
                s.log.Errorf("Failed to get sync user by user id, error: %s", err.Error())
                return ErrorSyncPostDeleteUserFail("failed to get sync user by user id, error: %s", err.Error())
        }</span>

        // TODO: group controller by agent
        <span class="cov0" title="0">for _, controller := range controllers </span><span class="cov0" title="0">{
                deleteUserTask := taskqueueSync.NewSyncDeleteUserTask().
                        WithControllerInfo(controller.UniqueID).WithUser(unsyncUser)

                err = s.addTaskToQueueAndSendTaskToAgent(ctx, controller.AgentID, []taskbase.Task{deleteUserTask})
                if err != nil </span><span class="cov0" title="0">{
                        s.log.Errorf("failed to add task to agent and queue, error: %s", err.Error())
                        return ErrorSyncPostDeleteUserFail("failed to add task to agent and queue, error: %s", err.Error())
                }</span>
        }

        <span class="cov0" title="0">s.log.Infof("done sync post delete user")

        return nil</span>
}

func (s *SyncService) SyncPostAddAccessRule(ctx context.Context, ar *dto.AccessRule) error <span class="cov0" title="0">{
        s.log.Infof("sync post add access rule, access rule: %+v", ar)

        syncAccessRule := ar.ToSyncAccessRule()

        // TODO: this part should be handled by by agent queue routine
        // get all the users need to be registered to the controller
        controllers, _, err := s.data.ListAllController(ctx)
        if err != nil </span><span class="cov0" title="0">{
                s.log.Errorf("failed to list all controller, error: %s", err.Error())
                return ErrorSyncPostAddAccessRuleFail("failed to list all controller, error: %s", err.Error())
        }</span>

        // TODO: group controller by agent
        <span class="cov0" title="0">for _, controller := range controllers </span><span class="cov0" title="0">{
                addAccessRuleTask := taskqueueSync.NewSyncAddAccessRuleTask().
                        WithControllerInfo(controller.UniqueID).WithAccessRule(syncAccessRule)

                err = s.addTaskToQueueAndSendTaskToAgent(ctx, controller.AgentID, []taskbase.Task{addAccessRuleTask})
                if err != nil </span><span class="cov0" title="0">{
                        s.log.Errorf("failed to add task to agent and queue, error: %s", err.Error())
                        return ErrorSyncPostAddAccessRuleFail("failed to add task to agent and queue, error: %s", err.Error())
                }</span>
        }

        <span class="cov0" title="0">s.log.Infof("done sync post add access rule")

        return nil</span>
}

func (s *SyncService) SyncPostDeleteAccessRule(ctx context.Context, ar *dto.AccessRule) error <span class="cov0" title="0">{
        s.log.Infof("sync post delete access rule, access rule: %+v", ar)

        syncAccessRule := ar.ToSyncAccessRule()

        // TODO: this part should be handled by by agent queue routine
        // get all the users need to be registered to the controller
        controllers, _, err := s.data.ListAllController(ctx)
        if err != nil </span><span class="cov0" title="0">{
                s.log.Errorf("failed to list all controller, error: %s", err.Error())
                return ErrorSyncPostDeleteAccessRuleFail("failed to list all controller, error: %s", err.Error())
        }</span>

        // TODO: group controller by agent
        <span class="cov0" title="0">for _, controller := range controllers </span><span class="cov0" title="0">{
                deleteAccessRuleTask := taskqueueSync.NewSyncDeleteAccessRuleTask().
                        WithControllerInfo(controller.UniqueID).WithAccessRule(syncAccessRule)

                err = s.addTaskToQueueAndSendTaskToAgent(ctx, controller.AgentID, []taskbase.Task{deleteAccessRuleTask})
                if err != nil </span><span class="cov0" title="0">{
                        s.log.Errorf("failed to delete task to agent and queue, error: %s", err.Error())
                        return ErrorSyncPostDeleteAccessRuleFail("failed to delete task to agent and queue, error: %s", err.Error())
                }</span>
        }

        <span class="cov0" title="0">s.log.Infof("done sync post delete access rule")

        return nil</span>
}

func (s *SyncService) SyncPostAccessRuleAddUser(ctx context.Context, accessRuleID string, userIDs []string) error <span class="cov0" title="0">{
        s.log.Infof("sync post acess rule add user, access rule id: %s, user ids: %+v", accessRuleID, userIDs)

        validAccessRule, validUsers, err := s.data.AddSyncUserToAccessRule(ctx, accessRuleID, userIDs)
        if err != nil </span><span class="cov0" title="0">{
                s.log.Errorf("failed to add sync user to access rule, error: %s", err.Error())
                return ErrorSyncPostAccessRuleAddUserFail("failed to add sync user to access rule, error: %s", err.Error())
        }</span>

        <span class="cov0" title="0">syncAccessRule := validAccessRule.ToSyncAccessRule()
        syncUsers := make([]*gatewaySyncV1.UserInfo, 0)
        for _, user := range validUsers </span><span class="cov0" title="0">{
                syncUser, err := s.getSyncUserByUser(ctx, user)
                if err != nil </span><span class="cov0" title="0">{
                        s.log.Errorf("failed to get sync user by user, error: %s", err.Error())
                        return ErrorSyncPostAccessRuleAddUserFail("failed to get sync user by user, error: %s", err.Error())
                }</span>
                <span class="cov0" title="0">syncUsers = append(syncUsers, syncUser)</span>
        }

        // TODO: this part should be handled by by agent queue routine
        // get all the users need to be registered to the controller
        <span class="cov0" title="0">controllers, _, err := s.data.ListAllController(ctx)
        if err != nil </span><span class="cov0" title="0">{
                s.log.Errorf("failed to list all controller: %s", err.Error())
                return ErrorSyncPostAccessRuleAddUserFail("failed to list all controller: %s", err.Error())
        }</span>

        // TODO: group controller by agent
        <span class="cov0" title="0">for _, controller := range controllers </span><span class="cov0" title="0">{
                accessRuleAddUserTask := taskqueueSync.NewSyncAccessRuleAddUserTask().
                        WithControllerInfo(controller.UniqueID).WithAccessRuleInfo(syncAccessRule).WithUsersInfo(syncUsers)

                err = s.addTaskToQueueAndSendTaskToAgent(ctx, controller.AgentID, []taskbase.Task{accessRuleAddUserTask})
                if err != nil </span><span class="cov0" title="0">{
                        s.log.Errorf("failed to add task to agent and queue: %s", err.Error())
                        return ErrorSyncPostAccessRuleAddUserFail("failed to add task to agent and queue: %s", err.Error())
                }</span>
        }

        <span class="cov0" title="0">s.log.Infof("done sync post add access rule add user")

        return nil</span>
}

func (s *SyncService) SyncPostAccessRuleDeleteUser(ctx context.Context, accessRuleID string, userIDs []string) error <span class="cov0" title="0">{
        s.log.Infof("sync post acess rule delete user, access rule id: %s, user ids: %+v", accessRuleID, userIDs)

        validAccessRule, validUsers, err := s.data.DeleteSyncUserToAccessRule(ctx, accessRuleID, userIDs)
        if err != nil </span><span class="cov0" title="0">{
                s.log.Errorf("failed to delete sync user to access rule, error: %s", err.Error())
                return ErrorSyncPostAccessRuleDeleteUserFail("failed to delete sync user to access rule, error: %s", err.Error())
        }</span>

        <span class="cov0" title="0">syncAccessRule := validAccessRule.ToSyncAccessRule()
        syncUsers := make([]*gatewaySyncV1.UserInfo, 0)
        for _, user := range validUsers </span><span class="cov0" title="0">{
                syncUser, err := s.getSyncUserByUser(ctx, user)
                if err != nil </span><span class="cov0" title="0">{
                        s.log.Errorf("failed to get sync user by user, error: %s", err.Error())
                        return ErrorSyncPostAccessRuleDeleteUserFail("failed to get sync user by user, error: %s", err.Error())
                }</span>
                <span class="cov0" title="0">syncUsers = append(syncUsers, syncUser)</span>
        }

        // TODO: this part should be handled by by agent queue routine
        // get all the users need to be registered to the controller
        <span class="cov0" title="0">controllers, _, err := s.data.ListAllController(ctx)
        if err != nil </span><span class="cov0" title="0">{
                s.log.Errorf("failed to list all controller, error: %s", err.Error())
                return ErrorSyncPostAccessRuleDeleteUserFail("failed to list all controller, error: %s", err.Error())
        }</span>

        // TODO: group controller by agent
        <span class="cov0" title="0">for _, controller := range controllers </span><span class="cov0" title="0">{
                accessRuleDeleteUserTask := taskqueueSync.NewSyncAccessRuleDeleteUserTask().
                        WithControllerInfo(controller.UniqueID).WithAccessRuleInfo(syncAccessRule).WithUsersInfo(syncUsers)

                err = s.addTaskToQueueAndSendTaskToAgent(ctx, controller.AgentID, []taskbase.Task{accessRuleDeleteUserTask})
                if err != nil </span><span class="cov0" title="0">{
                        s.log.Errorf("failed to add task to agent and queue, error: %s", err.Error())
                        return ErrorSyncPostAccessRuleDeleteUserFail("failed to add task to agent and queue, error: %s",
                                err.Error())
                }</span>
        }

        <span class="cov0" title="0">s.log.Infof("done sync post delete access rule delete user")

        return nil</span>
}

func (s *SyncService) SyncPostAccessRuleAddDoor(ctx context.Context, accessRuleID string, doorIDs []string) error <span class="cov0" title="0">{
        s.log.Infof("sync post acess rule add door, access rule id: %s, door ids: %+v", accessRuleID, doorIDs)

        validAccessRule, validDoors, err := s.data.AddSyncDoorToAccessRule(ctx, accessRuleID, doorIDs)
        if err != nil </span><span class="cov0" title="0">{
                s.log.Errorf("failed to add sync door to access rule, error: %s", err.Error())
                return ErrorSyncPostAccessRuleAddDoorFail("failed to add sync door to access rule, error: %s", err.Error())
        }</span>

        <span class="cov0" title="0">syncAccessRule := validAccessRule.ToSyncAccessRule()
        syncDoors := lo.Map(validDoors, func(door *dto.Door, _ int) *gatewaySyncV1.DoorInfo </span><span class="cov0" title="0">{
                return &amp;gatewaySyncV1.DoorInfo{
                        Token: door.Token,
                }
        }</span>)

        // TODO: this part should be handled by by agent queue routine
        // get all the users need to be registered to the controller
        <span class="cov0" title="0">controllers, _, err := s.data.ListAllController(ctx)
        if err != nil </span><span class="cov0" title="0">{
                s.log.Errorf("failed to list all controller, error: %s", err.Error())
                return ErrorSyncPostAccessRuleAddDoorFail("failed to list all controller, error: %s", err.Error())
        }</span>

        // TODO: group controller by agent
        <span class="cov0" title="0">for _, controller := range controllers </span><span class="cov0" title="0">{
                accessRuleAddDoorTask := taskqueueSync.NewSyncAccessRuleAddDoorTask().
                        WithControllerInfo(controller.UniqueID).WithAccessRuleInfo(syncAccessRule).WithDoorsInfo(syncDoors)

                err = s.addTaskToQueueAndSendTaskToAgent(ctx, controller.AgentID, []taskbase.Task{accessRuleAddDoorTask})
                if err != nil </span><span class="cov0" title="0">{
                        s.log.Errorf("failed to add task to agent and queue, error: %s", err.Error())
                        return ErrorSyncPostAccessRuleAddDoorFail("failed to add task to agent and queue, error: %s", err.Error())
                }</span>
        }

        <span class="cov0" title="0">s.log.Infof("done sync post add access rule add door")

        return nil</span>
}

func (s *SyncService) SyncPostAccessRuleDeleteDoor(ctx context.Context, accessRuleID string, doorIDs []string) error <span class="cov0" title="0">{
        s.log.Infof("sync post access rule delete door, access rule id: %s, door ids: %+v", accessRuleID, doorIDs)

        validAccessRule, validDoors, err := s.data.DeleteSyncDoorToAccessRule(ctx, accessRuleID, doorIDs)
        if err != nil </span><span class="cov0" title="0">{
                s.log.Errorf("failed to delete sync door to access rule, error: %s", err.Error())
                return ErrorSyncPostAccessRuleDeleteDoorFail("failed to delete sync door to access rule, error: %s",
                        err.Error())
        }</span>

        <span class="cov0" title="0">syncAccessRule := validAccessRule.ToSyncAccessRule()
        syncDoors := lo.Map(validDoors, func(door *dto.Door, _ int) *gatewaySyncV1.DoorInfo </span><span class="cov0" title="0">{
                return &amp;gatewaySyncV1.DoorInfo{
                        Token: door.Token,
                }
        }</span>)

        // TODO: this part should be handled by by agent queue routine
        // get all the users need to be registered to the controller
        <span class="cov0" title="0">controllers, _, err := s.data.ListAllController(ctx)
        if err != nil </span><span class="cov0" title="0">{
                s.log.Errorf("failed to list all controller, error: %s", err.Error())
                return ErrorSyncPostAccessRuleDeleteDoorFail("failed to list all controller, error: %s", err.Error())
        }</span>

        // TODO: group controller by agent
        <span class="cov0" title="0">for _, controller := range controllers </span><span class="cov0" title="0">{
                accessRuleDeleteDoorTask := taskqueueSync.NewSyncAccessRuleDeleteDoorTask().
                        WithControllerInfo(controller.UniqueID).WithAccessRuleInfo(syncAccessRule).WithDoorsInfo(syncDoors)

                err = s.addTaskToQueueAndSendTaskToAgent(ctx, controller.AgentID, []taskbase.Task{accessRuleDeleteDoorTask})
                if err != nil </span><span class="cov0" title="0">{
                        s.log.Errorf("failed to delete task to agent and queue, error: %s", err.Error())
                        return ErrorSyncPostAccessRuleDeleteDoorFail("failed to delete task to agent and queue, error: %s",
                                err.Error())
                }</span>
        }

        <span class="cov0" title="0">s.log.Infof("done sync post delete access rule delete door")

        return nil</span>
}

func (s *SyncService) SyncPostAddCredential(ctx context.Context, u *dto.User, credentials []*dto.UserCredential) error <span class="cov0" title="0">{
        s.log.Infof("sync post add credential, user: %+v, credentials: %+v", u, credentials)

        user, err := s.data.SyncGetUser(ctx, u.ID)
        if err != nil </span><span class="cov0" title="0">{
                s.log.Errorf("failed to get user, error: %s", err.Error())
                return ErrorSyncPostAddCredentialFail("failed to get user, error: %s", err.Error())
        }</span>

        <span class="cov0" title="0">syncAccessRules := lo.Map(user.AccessRules, func(accessRule *dto.AccessRule, _ int) *gatewaySyncV1.AccessRuleInfo </span><span class="cov0" title="0">{
                return accessRule.ToSyncAccessRule()
        }</span>)
        <span class="cov0" title="0">syncUser, err := s.getSyncUserByUser(ctx, user)
        if err != nil </span><span class="cov0" title="0">{
                s.log.Errorf("failed to get sync user by user, error: %s", err.Error())
                return ErrorSyncPostAddCredentialFail("failed to get sync user by user, error: %s", err.Error())
        }</span>

        // TODO: this part should be handled by by agent queue routine
        <span class="cov0" title="0">controllers, _, err := s.data.ListAllController(ctx)
        if err != nil </span><span class="cov0" title="0">{
                s.log.Errorf("failed to list all controller, error: %s", err.Error())
                return ErrorSyncPostAddCredentialFail("failed to list all controller, error: %s", err.Error())
        }</span>

        // TODO: group controller by agent
        <span class="cov0" title="0">for _, controller := range controllers </span><span class="cov0" title="0">{
                accessRuleAddUserTask := taskqueueSync.NewSyncAddCredentialTask().
                        WithControllerInfo(controller.UniqueID).WithAccessRulesInfo(syncAccessRules).WithUserInfo(syncUser)

                err = s.addTaskToQueueAndSendTaskToAgent(ctx, controller.AgentID, []taskbase.Task{accessRuleAddUserTask})
                if err != nil </span><span class="cov0" title="0">{
                        s.log.Errorf("failed to add task to agent and queue, error: %s", err.Error())
                        return ErrorSyncPostAddCredentialFail("failed to add task to agent and queue, error: %s", err.Error())
                }</span>
        }

        <span class="cov0" title="0">s.log.Infof("done sync post add credential")

        return nil</span>
}

func (s *SyncService) SyncPostDeleteCredential(ctx context.Context, credential *dto.UserCredential) error <span class="cov0" title="0">{
        s.log.Infof("sync post delete credential, credential: %+v", credential)

        unsyncCrecential, err := credential.ToGatewaySyncV1UserCredential()
        if err != nil </span><span class="cov0" title="0">{
                s.log.Errorf("failed to get sync user uncredential, error: %s", err.Error())
                return ErrorSyncPostDeleteCredentialFail("failed to get sync user uncredential, error: %s", err.Error())
        }</span>

        // TODO: this part should be handled by by agent queue routine
        <span class="cov0" title="0">controllers, _, err := s.data.ListAllController(ctx)
        if err != nil </span><span class="cov0" title="0">{
                s.log.Errorf("failed to list all user, error: %s", err.Error())
                return ErrorSyncPostDeleteCredentialFail("failed to list all user, error: %s", err.Error())
        }</span>

        // TODO: group controller by agent
        <span class="cov0" title="0">for _, controller := range controllers </span><span class="cov0" title="0">{
                accessRuleDeleteUserTask := taskqueueSync.NewSyncDeleteCredentialTask().
                        WithControllerInfo(controller.UniqueID).WithCredentialInfo(unsyncCrecential)

                err = s.addTaskToQueueAndSendTaskToAgent(ctx, controller.AgentID, []taskbase.Task{accessRuleDeleteUserTask})
                if err != nil </span><span class="cov0" title="0">{
                        s.log.Errorf("failed to delete task to agent and queue, error: %s", err.Error())
                        return ErrorSyncPostDeleteCredentialFail("failed to delete task to agent and queue, error: %s",
                                err.Error())
                }</span>
        }

        <span class="cov0" title="0">s.log.Infof("done sync post delete credential")

        return nil</span>
}
</pre>

		<pre class="file" id="file54" style="display: none">package service

import (
        "context"
        "fmt"
        "io"

        UpnpV1 "git.synology.inc/sast/access-system/server/gateway/api/upnp/v1"
        "git.synology.inc/sast/access-system/server/transport/websocket"
        "git.synology.inc/sast/access-system/server/web/internal/biz"
        "git.synology.inc/sast/access-system/server/web/internal/conf"
        "github.com/go-kratos/kratos/v2/log"
)

type UpnpService struct {
        discoveryService DiscoveryServiceInterface
        ws               *websocket.Server
        agentUseCase     biz.AgentUseCaseInterface
        logger           *log.Helper
        c                *conf.Upnp
}

type UpnpSearchRequest struct {
        AgentID string `json:"agent_id"`
        Method  string `json:"method"`
}

type UpnpSearchReply struct {
        Vendor string `json:"vendor"`
        Model  string `json:"model"`
        IP     string `json:"ip"`
}

type UpnpSearchError struct {
        Error string `json:"error"`
}

type UpnpSearchCancel struct {
        Result string `json:"result"`
}

const (
        MessageTypeUpnp websocket.MessageType = "upnp_v1"
)

func NewUpnpService(c *conf.Upnp, discoveryService DiscoveryServiceInterface, agentUseCase biz.AgentUseCaseInterface,
        logger log.Logger) *UpnpService <span class="cov0" title="0">{

        return &amp;UpnpService{
                discoveryService: discoveryService,
                agentUseCase:     agentUseCase,
                logger:           log.NewHelper(logger),
                c:                c,
        }
}</span>

func (s *UpnpService) SetWsServer(wsServer *websocket.Server) <span class="cov0" title="0">{
        s.ws = wsServer
}</span>

func (s *UpnpService) Handler(sessionID websocket.SessionID, message *UpnpSearchRequest) error <span class="cov0" title="0">{
        switch message.Method </span>{
        case "start":<span class="cov0" title="0">
                return s.Search(sessionID, message)</span>
        case "stop":<span class="cov0" title="0">
                return s.Stop(sessionID)</span>
        default:<span class="cov0" title="0">
                s.ws.SendMessage(sessionID, MessageTypeUpnp, &amp;UpnpSearchError{
                        Error: fmt.Sprintf("Unknown method %s", message.Method),
                })

                s.logger.Errorf("unknown method %s", message.Method)
                return ErrorUnknownMethod("unknown method %s", message.Method)</span>
        }
}

func (s *UpnpService) stopSearch(sessionID websocket.SessionID) <span class="cov0" title="0">{
        if !s.ws.IsBusy(sessionID, MessageTypeUpnp) </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">s.ws.SessionClose(sessionID, MessageTypeUpnp)</span>
}

func (s *UpnpService) Search(sessionID websocket.SessionID, message *UpnpSearchRequest) error <span class="cov0" title="0">{
        if !s.ws.IsIdle(sessionID, MessageTypeUpnp) </span><span class="cov0" title="0">{
                s.ws.SendMessage(sessionID, MessageTypeUpnp, &amp;UpnpSearchError{
                        Error: "Please wait for the current search to finish",
                })

                s.logger.Errorf("please wait for the current search to finish")
                return ErrorUpnpSearching("please wait for the current search to finish")
        }</span>

        // Get agent unique id from agent id
        <span class="cov0" title="0">agent, err := s.agentUseCase.GetAgent(context.Background(), message.AgentID)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Errorf("failed to get agent[%s], error: %s", message.AgentID, err.Error())
                s.ws.SendMessage(sessionID, MessageTypeUpnp, &amp;UpnpSearchError{
                        Error: "Agent not found",
                })

                return err
        }</span>

        // Request mutex lock
        <span class="cov0" title="0">s.ws.SessionStart(sessionID, MessageTypeUpnp)

        // Get gateway connection
        conn, err := s.discoveryService.Get(agent.UniqueID)
        if err != nil </span><span class="cov0" title="0">{
                s.stopSearch(sessionID)
                s.logger.Errorf("failed to get gateway connection: %s for agent %s, uniqueID: %s", err.Error(), agent.ID, agent.UniqueID)
                return ErrorCanNotGetGatewayConnection(
                        "failed to get gateway connection: %s for agent %s, uniqueID: %s", err.Error(), agent.ID, agent.UniqueID)
        }</span>

        // Arrange cancel func
        <span class="cov0" title="0">ctx, cancel := context.WithTimeout(context.Background(), s.c.GetTimeout().AsDuration())
        s.ws.SetCancelFn(sessionID, MessageTypeUpnp, cancel)

        // Call grpc func
        stream, err := conn.Upnp.Search(ctx, &amp;UpnpV1.UpnpSearchRequest{
                AgentId: agent.UniqueID,
        })
        if err != nil </span><span class="cov0" title="0">{
                s.stopSearch(sessionID)
                s.logger.Errorf("failed to search UPnP: %s", err.Error())
                return ErrorCanNotSearchUpnp("failed to search UPnP: %s", err.Error())
        }</span>

        // Handle upnp search result
        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                defer s.stopSearch(sessionID)
                for </span><span class="cov0" title="0">{
                        select </span>{
                        case &lt;-ctx.Done():<span class="cov0" title="0">
                                s.ws.SendMessage(sessionID, MessageTypeUpnp, &amp;UpnpSearchCancel{
                                        Result: "UPnP search timeout",
                                })
                                return</span>
                        default:<span class="cov0" title="0">
                                reply, err := stream.Recv()
                                if err == io.EOF </span><span class="cov0" title="0">{
                                        s.ws.SendMessage(sessionID, MessageTypeUpnp, &amp;UpnpSearchCancel{
                                                Result: "UPnP search finished",
                                        })
                                        return
                                }</span>
                                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                                        s.logger.Errorf("receive failed: %s", err.Error())
                                        return
                                }</span>

                                // Send message
                                <span class="cov0" title="0">s.ws.SendMessage(sessionID, MessageTypeUpnp, &amp;UpnpSearchReply{
                                        Vendor: reply.Vendor,
                                        Model:  reply.Model,
                                        IP:     reply.Ip,
                                })</span>
                        }
                }
        }()

        <span class="cov0" title="0">return nil</span>
}

func (s *UpnpService) Stop(sessionID websocket.SessionID) error <span class="cov0" title="0">{
        if !s.ws.IsBusy(sessionID, MessageTypeUpnp) </span><span class="cov0" title="0">{
                s.ws.SendMessage(sessionID, MessageTypeUpnp, &amp;UpnpSearchError{
                        Error: "Nothing to stop",
                })

                s.logger.Errorf("nothing to stop")
                return ErrorNoActiveSearch("nothing to stop")
        }</span>

        // Send message
        <span class="cov0" title="0">s.ws.SendMessage(sessionID, MessageTypeUpnp, &amp;UpnpSearchCancel{
                Result: "UPnP search stopped",
        })

        // Set status and stop
        s.stopSearch(sessionID)
        return nil</span>
}
</pre>

		<pre class="file" id="file55" style="display: none">package service

import (
        "context"
        "fmt"
        "time"

        "git.synology.inc/sast/access-system/server/internal/utility"
        userV1 "git.synology.inc/sast/access-system/server/web/api/user/v1"
        "git.synology.inc/sast/access-system/server/web/internal/biz"
        "git.synology.inc/sast/access-system/server/web/internal/conf"
        "git.synology.inc/sast/access-system/server/web/internal/datastore/dto"
        "github.com/go-kratos/kratos/v2/log"
        "github.com/segmentio/ksuid"
        "google.golang.org/protobuf/types/known/emptypb"
)

type UserService struct {
        userV1.UnimplementedUserServer

        conf             *conf.Public
        discoveryService DiscoveryServiceInterface
        agentService     AgentServiceInterface
        syncService      SyncServiceInterface
        userUseCase      biz.UserUseCaseInterface
        log              *log.Helper
}

func NewUserService(public *conf.Public, userUseCase biz.UserUseCaseInterface, logger log.Logger,
        discoveryService DiscoveryServiceInterface, agentService AgentServiceInterface, syncService SyncServiceInterface) *UserService <span class="cov0" title="0">{

        return &amp;UserService{
                conf:             public,
                discoveryService: discoveryService,
                agentService:     agentService,
                syncService:      syncService,
                userUseCase:      userUseCase,
                log:              log.NewHelper(logger),
        }
}</span>

func mapUserSources(pbUserSource userV1.UserSource) (
        dto.UserSource, error) <span class="cov0" title="0">{

        userType, err := dto.PbUserSourceToUserSource(pbUserSource)
        if err != nil </span><span class="cov0" title="0">{
                return dto.UserSourceLocal, err
        }</span>
        <span class="cov0" title="0">return userType, nil</span>
}

func (s *UserService) AddUser(ctx context.Context, req *userV1.AddUserRequest) (*userV1.AddUserReply, error) <span class="cov0" title="0">{
        // DSM user created by dsm sync service
        // User api can only create local user
        if req.GetSource() != userV1.UserSource_LOCAL </span><span class="cov0" title="0">{
                s.log.Errorf("user source: %s not allowed by api", req.GetSource())
                return nil, ErrorAddUserError("user source: %s not allowed by api", req.GetSource())
        }</span>

        // transfer user source, access rule type, valid
        <span class="cov0" title="0">userSource, err := mapUserSources(req.GetSource())
        if err != nil </span><span class="cov0" title="0">{
                s.log.Errorf("convert user sources error with source: %+v, error: %s",
                        req.GetSource(), err.Error())
                return nil, ErrorAddUserError("add user failed to map source: %v, error: %s",
                        req.GetSource(), err.Error())
        }</span>
        <span class="cov0" title="0">validFromUnix, validUntilUnix, err := dto.MapUserValidDurations(time.RFC3339, req.GetValidFrom(), req.GetValidUntil())
        if err != nil </span><span class="cov0" title="0">{
                s.log.Errorf("convert user valid durations error with valid from: %+v, valid until: %+v, error: %s",
                        req.GetValidFrom(), req.GetValidUntil(), err.Error())
                return nil, ErrorAddUserError("add user failed to map valid durations: %v, %v, error: %s",
                        req.GetValidFrom(), req.GetValidUntil(), err.Error())
        }</span>

        // Arrange
        <span class="cov0" title="0">addUser := &amp;dto.User{
                ID:             ksuid.New().String(),
                UniqueID:       req.GetUniqueId(),
                Source:         userSource,
                FirstName:      req.GetFirstName(),
                LastName:       req.GetLastName(),
                EMail:          req.GetEmail(),
                State:          dto.GetUserStateFromValidTime(validFromUnix, validUntilUnix, dto.UserStateActivated),
                Description:    req.GetDescription(),
                ValidFrom:      validFromUnix,
                ValidUntil:     validUntilUnix,
                LongAccessTime: req.GetLongAccessTime(),
        }

        // Act
        cid, err := s.userUseCase.AddUser(ctx, addUser)
        if err != nil </span><span class="cov0" title="0">{
                s.log.Errorf("add user error: %s", err.Error())
                return nil, ErrorAddUserError("failed to add new user, error: %s", err.Error())
        }</span>

        <span class="cov0" title="0">err = s.syncService.SyncPostAddUser(ctx, addUser)
        if err != nil </span><span class="cov0" title="0">{
                s.log.Errorf("sync post add user error: %s", err.Error())
                return nil, ErrorAddControllerError("failed to sync post add user, error: %s", err.Error())
        }</span>

        <span class="cov0" title="0">return &amp;userV1.AddUserReply{
                Id: cid,
        }, nil</span>
}

func (s *UserService) UpdateUser(ctx context.Context, req *userV1.UpdateUserRequest) (*emptypb.Empty, error) <span class="cov0" title="0">{
        // check user existed
        u, err := s.userUseCase.GetUser(ctx, req.GetId())
        if err != nil </span><span class="cov0" title="0">{
                s.log.Errorf("get user error: %s", err.Error())
                return nil, ErrorUpdateUserError("failed to get user, error: %s", err.Error())
        }</span>

        <span class="cov0" title="0">userSource, err := mapUserSources(req.GetBody().GetSource())
        if err != nil </span><span class="cov0" title="0">{
                s.log.Errorf("convert user sources error with source: %+v, error: %s",
                        req.GetBody().GetSource(), err.Error())
                return nil, ErrorUpdateUserError("update user failed to map source: %v, error: %s",
                        req.GetBody().GetSource(), err.Error())
        }</span>
        <span class="cov0" title="0">validFromUnix, validUntilUnix, err := dto.MapUserValidDurations(time.RFC3339, req.GetBody().GetValidFrom(), req.GetBody().GetValidUntil())
        if err != nil </span><span class="cov0" title="0">{
                s.log.Errorf("convert user valid durations error with valid from: %+v, valid until: %+v, error: %s",
                        req.GetBody().GetValidFrom(), req.GetBody().GetValidUntil(), err.Error())
                return nil, ErrorUpdateUserError("update user failed to map valid durations: %v, %v, error: %s",
                        req.GetBody().GetValidFrom(), req.GetBody().GetValidUntil(), err.Error())
        }</span>

        // set up update field
        <span class="cov0" title="0">u.UniqueID = req.GetBody().GetUniqueId()
        u.Source = userSource
        u.State = dto.GetUserStateFromValidTime(validFromUnix, validUntilUnix, u.State)
        u.FirstName = req.GetBody().GetFirstName()
        u.LastName = req.GetBody().GetLastName()
        u.EMail = req.GetBody().GetEmail()
        u.Description = req.GetBody().GetDescription()
        u.ValidFrom = validFromUnix
        u.ValidUntil = validUntilUnix
        u.LongAccessTime = req.GetBody().GetLongAccessTime()

        err = s.userUseCase.UpdateUser(ctx, u)
        if err != nil </span><span class="cov0" title="0">{
                s.log.Errorf("update user error: %s", err.Error())
                return nil, ErrorUpdateUserError("failed to update user, error: %s", err.Error())
        }</span>

        <span class="cov0" title="0">return &amp;emptypb.Empty{}, nil</span>
}

func (s *UserService) UpdateUserProfileImage(ctx context.Context, req *userV1.UpdateUserProfileImageRequest) (*emptypb.Empty, error) <span class="cov0" title="0">{
        // check user existed
        u, err := s.userUseCase.GetUser(ctx, req.GetId())
        if err != nil </span><span class="cov0" title="0">{
                s.log.Errorf("get user error: %s", err.Error())
                return nil, ErrorUpdateUserProfileImageError("failed to get user, error: %s", err.Error())
        }</span>

        // cache origin file path
        <span class="cov0" title="0">originFilePath := u.ProfileImagePath

        // save image from base64
        fileName := fmt.Sprintf("%s_%d.jpg", u.ID, time.Now().Unix())
        filePath := fmt.Sprintf("%s/%s", s.conf.GetProfileImage().GetFileFolder(), fileName)
        err = utility.SaveBase64Image(req.GetBody().GetData(), filePath)
        if err != nil </span><span class="cov0" title="0">{
                s.log.Errorf("save user profile image error: %s", err.Error())
                return nil, ErrorUpdateUserProfileImageError("failed to save user profile image, error: %s", err.Error())
        }</span>

        // update user profile image
        <span class="cov0" title="0">u.ProfileImagePath = filePath

        err = s.userUseCase.UpdateUser(ctx, u)
        if err != nil </span><span class="cov0" title="0">{
                s.log.Errorf("update user error: %s", err.Error())
                return nil, ErrorUpdateUserProfileImageError("failed to update user, error: %s", err.Error())
        }</span>

        // delete previous profile image
        <span class="cov0" title="0">err = utility.RemoveFile(originFilePath)
        if err != nil </span><span class="cov0" title="0">{
                s.log.Errorf("remove user profile image error: %s", err.Error())
        }</span>

        <span class="cov0" title="0">return &amp;emptypb.Empty{}, nil</span>
}

func (s *UserService) GetUser(ctx context.Context, req *userV1.GetUserRequest) (*userV1.GetUserReply, error) <span class="cov0" title="0">{
        u, err := s.userUseCase.GetUser(ctx, req.GetId())
        if err != nil </span><span class="cov0" title="0">{
                s.log.Errorf("get user error: %s", err.Error())
                return nil, ErrorGetUserError("failed to delete user, error: %s", err.Error())
        }</span>

        <span class="cov0" title="0">pbUser, err := u.ToPbUser()
        if err != nil </span><span class="cov0" title="0">{
                s.log.Errorf("convert user to userV1 user error: %s", err.Error())
                return nil, ErrorGetUserError("failed to convert user to userV1 user, error: %s", err.Error())
        }</span>

        // handle public path
        <span class="cov0" title="0">pbUser.ProfileImagePath = utility.GetPublicPath(pbUser.ProfileImagePath, s.conf.GetProfileImage().GetDefaultFile())

        // return
        return &amp;userV1.GetUserReply{
                User: pbUser,
        }, nil</span>
}

func (s *UserService) DeleteUser(ctx context.Context, req *userV1.DeleteUserRequest) (*emptypb.Empty, error) <span class="cov0" title="0">{
        user, err := s.userUseCase.GetUser(ctx, req.GetId())
        if err != nil </span><span class="cov0" title="0">{
                s.log.Errorf("get user error: %s", err.Error())
                return nil, ErrorDeleteUserError("failed to get user, error: %s", err.Error())
        }</span>

        <span class="cov0" title="0">err = s.userUseCase.DeleteUser(ctx, req.GetId())
        if err != nil </span><span class="cov0" title="0">{
                s.log.Errorf("delete user error: %s", err.Error())
                return nil, ErrorDeleteUserError("failed to delete user, error: %s", err.Error())
        }</span>

        <span class="cov0" title="0">err = s.syncService.SyncPostDeleteUser(ctx, user)
        if err != nil </span><span class="cov0" title="0">{
                s.log.Errorf("sync post add user error: %s", err.Error())
                return nil, ErrorDeleteUserError("failed to sync post add user, error: %s", err.Error())
        }</span>

        <span class="cov0" title="0">return &amp;emptypb.Empty{}, nil</span>
}

func (s *UserService) ListUser(ctx context.Context, req *userV1.ListUserRequest) (*userV1.ListUserReply, error) <span class="cov0" title="0">{
        users, userCount, err := s.userUseCase.ListUser(ctx, req.GetOffset(), req.GetLimit())
        if err != nil </span><span class="cov0" title="0">{
                s.log.Errorf("list user error: %s", err.Error())
                return nil, ErrorListUserError("failed to list user, error: %s", err.Error())
        }</span>

        <span class="cov0" title="0">pbUsers := &amp;userV1.ListUserReply{
                Users: make([]*userV1.UserInfo, 0, len(users)),
                Total: userCount,
        }
        for _, user := range users </span><span class="cov0" title="0">{
                pbUser, err := user.ToPbUser()
                if err != nil </span><span class="cov0" title="0">{
                        s.log.Errorf("convert user to userV1 user error: %s", err.Error())
                        return nil, ErrorListUserError("failed to convert user to userV1 user, error: %s", err.Error())
                }</span>

                // handle public path
                <span class="cov0" title="0">pbUser.ProfileImagePath = utility.GetPublicPath(pbUser.ProfileImagePath, s.conf.GetProfileImage().GetDefaultFile())

                pbUsers.Users = append(pbUsers.Users, pbUser)</span>
        }

        <span class="cov0" title="0">return pbUsers, nil</span>
}
</pre>

		<pre class="file" id="file56" style="display: none">package service

import (
        "context"

        userCredentialV1 "git.synology.inc/sast/access-system/server/web/api/user_credential/v1"
        "git.synology.inc/sast/access-system/server/web/internal/biz"
        "git.synology.inc/sast/access-system/server/web/internal/datastore/dto"
        "github.com/go-kratos/kratos/v2/log"
        "github.com/segmentio/ksuid"
        "google.golang.org/protobuf/types/known/emptypb"
)

type UserCredentialService struct {
        userCredentialV1.UnimplementedUserCredentialServer

        userUseCase           biz.UserUseCaseInterface
        userCredentialUseCase biz.UserCredentialUseCaseInterface
        log                   *log.Helper

        syncService SyncServiceInterface
}

func NewUserCredentialService(userUseCase biz.UserUseCaseInterface,
        userCredentialUseCase biz.UserCredentialUseCaseInterface, syncService SyncServiceInterface,
        logger log.Logger) *UserCredentialService <span class="cov8" title="1">{

        return &amp;UserCredentialService{
                userUseCase:           userUseCase,
                userCredentialUseCase: userCredentialUseCase,
                log:                   log.NewHelper(logger),
                syncService:           syncService,
        }
}</span>

func (s *UserCredentialService) addUserCredential(ctx context.Context, userID string,
        credential *userCredentialV1.AddUserCredentialInfo) (string, *dto.UserCredential, error) <span class="cov8" title="1">{

        userCredentialType, err := dto.PbUserCredentialTypeToUserCredentialType(credential.GetType())
        if err != nil </span><span class="cov8" title="1">{
                s.log.Errorf("map type failed: %v, error: %s", credential.GetType(), err.Error())
                return "", nil, err
        }</span>

        <span class="cov8" title="1">dataString, err := dto.UserCredentialDataEncode(userCredentialType, credential.GetData())
        if err != nil </span><span class="cov8" title="1">{
                s.log.Errorf("failed to parse user credential, error: %s", err.Error())
                return "", nil, err
        }</span>

        <span class="cov8" title="1">addUserCredential := &amp;dto.UserCredential{
                ID:       ksuid.New().String(),
                UniqueID: ksuid.New().String(),
                UserID:   userID,
                Type:     userCredentialType,
                Data:     dataString,
        }

        id, err := s.userCredentialUseCase.AddUserCredential(ctx, addUserCredential)
        if err != nil </span><span class="cov8" title="1">{
                s.log.Errorf("add user credential error: %s", err.Error())
                return "", nil, err
        }</span>

        <span class="cov8" title="1">return id, addUserCredential, nil</span>
}

func (s *UserCredentialService) updateUserCredential(ctx context.Context, data *userCredentialV1.Data,
        updateCredentialID, userID string) error <span class="cov8" title="1">{

        userCredential, err := s.userCredentialUseCase.GetUserCredential(ctx, updateCredentialID)
        if err != nil </span><span class="cov8" title="1">{
                s.log.Errorf("get user credential error: %s", err.Error())
                return ErrorUpdateUserCredentialError("get user credential error: %s", err.Error())
        }</span>
        <span class="cov8" title="1">if userCredential.UserID != userID </span><span class="cov8" title="1">{
                return ErrorUpdateUserCredentialError("user credential not belong to user")
        }</span>

        <span class="cov8" title="1">dataString, err := dto.UserCredentialDataEncode(userCredential.Type, data)
        if err != nil </span><span class="cov0" title="0">{
                return ErrorUpdateUserCredentialError("failed to parse user credential, error: %s", err.Error())
        }</span>

        <span class="cov8" title="1">userCredential.Data = dataString
        return s.userCredentialUseCase.UpdateUserCredential(ctx, userCredential)</span>
}

func (s *UserCredentialService) deleteUserCredential(ctx context.Context,
        userID, deleteCredentialID string) (*dto.UserCredential, error) <span class="cov8" title="1">{

        userCredential, err := s.userCredentialUseCase.GetUserCredential(ctx, deleteCredentialID)
        if err != nil </span><span class="cov8" title="1">{
                s.log.Errorf("get user credential error: %s", err.Error())
                return nil, ErrorDeleteUserCredentialError("get user credential error: %s", err.Error())
        }</span>
        <span class="cov8" title="1">if userCredential.UserID != userID </span><span class="cov8" title="1">{
                return nil, ErrorDeleteUserCredentialError("user credential not belong to user")
        }</span>

        <span class="cov8" title="1">err = s.userCredentialUseCase.DeleteUserCredential(ctx, deleteCredentialID)
        if err != nil </span><span class="cov8" title="1">{
                s.log.Errorf("delete user credential error: %s", err.Error())
                return nil, ErrorDeleteUserCredentialError("failed to delete user credential, error: %s", err.Error())
        }</span>

        <span class="cov8" title="1">return userCredential, nil</span>
}

func (s *UserCredentialService) AddUserCredential(ctx context.Context, req *userCredentialV1.AddUserCredentialRequest,
) (*userCredentialV1.AddUserCredentialReply, error) <span class="cov8" title="1">{

        // Validate user
        user, err := s.userUseCase.GetUser(ctx, req.GetUser())
        if err != nil </span><span class="cov8" title="1">{
                s.log.Errorf("get user error: %s", err.Error())
                return nil, ErrorAddUserCredentialError("get user error: %s", err.Error())
        }</span>

        <span class="cov8" title="1">ids := make([]string, 0, len(req.GetBody().GetCredentials()))
        errorUserCredentials := make([]*userCredentialV1.AddUserCredentialInfo, 0, len(req.GetBody().GetCredentials()))

        addedCredentials := make([]*dto.UserCredential, 0)
        for _, credential := range req.GetBody().GetCredentials() </span><span class="cov8" title="1">{
                id, addUserCredential, err := s.addUserCredential(ctx, req.GetUser(), credential)
                if err != nil </span><span class="cov8" title="1">{
                        errorUserCredentials = append(errorUserCredentials, credential)
                        continue</span>
                }

                <span class="cov8" title="1">ids = append(ids, id)
                addedCredentials = append(addedCredentials, addUserCredential)</span>
        }

        <span class="cov8" title="1">if len(addedCredentials) &gt; 0 </span><span class="cov8" title="1">{
                err = s.syncService.SyncPostAddCredential(ctx, user, addedCredentials)
                if err != nil </span><span class="cov8" title="1">{
                        s.log.Errorf("sync post add credential error: %s", err.Error())
                        return nil, ErrorAddUserCredentialError("failed to sync post access rule add user, error: %s", err.Error())
                }</span>
        }

        <span class="cov8" title="1">return &amp;userCredentialV1.AddUserCredentialReply{
                Ids:              ids,
                ErrorCredentials: errorUserCredentials,
        }, nil</span>
}

func (s *UserCredentialService) UpdateUserCredential(ctx context.Context, req *userCredentialV1.UpdateUserCredentialRequest,
) (*emptypb.Empty, error) <span class="cov8" title="1">{

        // Validate user
        _, err := s.userUseCase.GetUser(ctx, req.GetUser())
        if err != nil </span><span class="cov8" title="1">{
                s.log.Errorf("get user error: %s", err.Error())
                return nil, ErrorUpdateUserCredentialError("get user error: %s", err.Error())
        }</span>

        <span class="cov8" title="1">return &amp;emptypb.Empty{}, s.updateUserCredential(ctx, req.GetBody().GetData(), req.GetId(), req.GetUser())</span>
}

func (s *UserCredentialService) BatchUpdateUserCredential(ctx context.Context, req *userCredentialV1.BatchUpdateUserCredentialRequest,
) (*emptypb.Empty, error) <span class="cov8" title="1">{

        user, err := s.userUseCase.GetUser(ctx, req.GetUser())
        if err != nil </span><span class="cov8" title="1">{
                s.log.Errorf("get user error: %s", err.Error())
                return nil, ErrorUpdateUserCredentialError("get user error: %s", err.Error())
        }</span>

        /* Add credentials */
        <span class="cov8" title="1">addedCredentials := make([]*dto.UserCredential, 0)
        for _, credential := range req.GetBody().GetAdd() </span><span class="cov8" title="1">{
                _, addUserCredential, err := s.addUserCredential(ctx, req.GetUser(), credential)
                if err != nil </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov8" title="1">addedCredentials = append(addedCredentials, addUserCredential)</span>
        }

        <span class="cov8" title="1">if len(addedCredentials) &gt; 0 </span><span class="cov8" title="1">{
                err = s.syncService.SyncPostAddCredential(ctx, user, addedCredentials)
                if err != nil </span><span class="cov8" title="1">{
                        s.log.Errorf("sync post add credential error: %s", err.Error())
                        return nil, ErrorAddUserCredentialError("failed to sync post access rule add user, error: %s", err.Error())
                }</span>
        }

        /* Delete credentials */
        <span class="cov8" title="1">for _, deleteCredentialID := range req.GetBody().GetDelete() </span><span class="cov8" title="1">{
                userCredential, err := s.deleteUserCredential(ctx, req.GetUser(), deleteCredentialID)
                if err != nil </span><span class="cov8" title="1">{
                        return nil, err
                }</span>

                <span class="cov8" title="1">err = s.syncService.SyncPostDeleteCredential(ctx, userCredential)
                if err != nil </span><span class="cov8" title="1">{
                        s.log.Errorf("sync post delete credential fail, error: %s", err.Error())
                        return nil, ErrorAddUserCredentialError("failed to sync post access rule add user, error: %s", err.Error())
                }</span>
        }

        /* Update credentials */
        <span class="cov8" title="1">for _, updateCredential := range req.GetBody().GetUpdate() </span><span class="cov8" title="1">{
                err := s.updateUserCredential(ctx, updateCredential.GetData(), updateCredential.GetId(), req.GetUser())
                if err != nil </span><span class="cov8" title="1">{
                        return nil, err
                }</span>
        }

        <span class="cov8" title="1">return &amp;emptypb.Empty{}, nil</span>
}

func (s *UserCredentialService) GetUserCredential(ctx context.Context, req *userCredentialV1.GetUserCredentialRequest,
) (*userCredentialV1.GetUserCredentialReply, error) <span class="cov8" title="1">{

        // Validate user
        _, err := s.userUseCase.GetUser(ctx, req.GetUser())
        if err != nil </span><span class="cov8" title="1">{
                s.log.Errorf("get user error: %s", err.Error())
                return nil, ErrorGetUserCredentialError("get user error: %s", err.Error())
        }</span>

        // Get user credential
        <span class="cov8" title="1">uc, err := s.userCredentialUseCase.GetUserCredential(ctx, req.GetId())
        if err != nil </span><span class="cov8" title="1">{
                s.log.Errorf("get user credential error: %s", err.Error())
                return nil, ErrorGetUserCredentialError("get user credential error: %s", err.Error())
        }</span>
        <span class="cov8" title="1">if uc.UserID != req.GetUser() </span><span class="cov8" title="1">{
                return nil, ErrorGetUserCredentialError("user credential not belong to user")
        }</span>

        // Result mapping
        <span class="cov8" title="1">pbUserCredential, err := uc.ToPbUserCredential()
        if err != nil </span><span class="cov8" title="1">{
                s.log.Errorf("convert user credential to pb user credential error: %s", err.Error())
                return nil, ErrorGetUserCredentialError("failed to convert user credential to pb user credential, error: %s", err.Error())
        }</span>

        <span class="cov8" title="1">return &amp;userCredentialV1.GetUserCredentialReply{
                Credential: pbUserCredential,
        }, nil</span>
}

func (s *UserCredentialService) DeleteUserCredential(ctx context.Context, req *userCredentialV1.DeleteUserCredentialRequest,
) (*emptypb.Empty, error) <span class="cov8" title="1">{

        // Validate user
        _, err := s.userUseCase.GetUser(ctx, req.GetUser())
        if err != nil </span><span class="cov8" title="1">{
                s.log.Errorf("get user error: %s", err.Error())
                return nil, ErrorDeleteUserCredentialError("get user error: %s", err.Error())
        }</span>

        <span class="cov8" title="1">userCredential, err := s.deleteUserCredential(ctx, req.GetUser(), req.GetId())
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">err = s.syncService.SyncPostDeleteCredential(ctx, userCredential)
        if err != nil </span><span class="cov8" title="1">{
                s.log.Errorf("sync post delete credential fail, error: %s", err.Error())
                return nil, ErrorAddUserCredentialError("failed to sync post access rule add user, error: %s", err.Error())
        }</span>

        <span class="cov8" title="1">return &amp;emptypb.Empty{}, nil</span>
}

func (s *UserCredentialService) ListUserCredential(ctx context.Context, req *userCredentialV1.ListUserCredentialRequest,
) (*userCredentialV1.ListUserCredentialReply, error) <span class="cov8" title="1">{

        // Validate user
        _, err := s.userUseCase.GetUser(ctx, req.GetUser())
        if err != nil </span><span class="cov8" title="1">{
                s.log.Errorf("get user error: %s", err.Error())
                return nil, ErrorListUserCredentialError("get user error: %s", err.Error())
        }</span>

        // Act
        <span class="cov8" title="1">userCredentials, err := s.userCredentialUseCase.ListUserCredential(ctx, req.GetUser())
        if err != nil </span><span class="cov8" title="1">{
                s.log.Errorf("list user credential error: %s", err.Error())
                return nil, err
        }</span>

        // Result mapping
        <span class="cov8" title="1">pbUserCredentials := make([]*userCredentialV1.UserCredentialInfo, 0, len(userCredentials))
        for _, userCredential := range userCredentials </span><span class="cov8" title="1">{
                pbUserCredential, err := userCredential.ToPbUserCredential()
                if err != nil </span><span class="cov8" title="1">{
                        s.log.Errorf("convert user credential to pb user credential error: %s", err.Error())
                        return nil, err
                }</span>
                <span class="cov8" title="1">pbUserCredentials = append(pbUserCredentials, pbUserCredential)</span>
        }

        <span class="cov8" title="1">return &amp;userCredentialV1.ListUserCredentialReply{
                Credentials: pbUserCredentials,
        }, nil</span>
}
</pre>

		<pre class="file" id="file57" style="display: none">package service

import (
        "context"

        doorV1 "git.synology.inc/sast/access-system/server/web/api/door/v1"
        zoneV1 "git.synology.inc/sast/access-system/server/web/api/zone/v1"
        "git.synology.inc/sast/access-system/server/web/internal/biz"
        "git.synology.inc/sast/access-system/server/web/internal/datastore/dto"
        "github.com/go-kratos/kratos/v2/log"
        "github.com/segmentio/ksuid"
        "google.golang.org/protobuf/types/known/emptypb"
)

type ZoneService struct {
        zoneV1.UnimplementedZoneServer

        zoneUseCase biz.ZoneUseCaseInterface
        log         *log.Helper
}

func NewZoneService(zoneUseCase biz.ZoneUseCaseInterface, logger log.Logger) *ZoneService <span class="cov0" title="0">{
        return &amp;ZoneService{
                zoneUseCase: zoneUseCase,
                log:         log.NewHelper(logger),
        }
}</span>

func (s *ZoneService) addDoor(ctx context.Context, zoneID string, doors []*doorV1.DoorInfo) error <span class="cov0" title="0">{
        if len(doors) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">doorIDs := make([]string, 0, len(doors))
        for _, door := range doors </span><span class="cov0" title="0">{
                doorIDs = append(doorIDs, door.GetId())
        }</span>

        <span class="cov0" title="0">if err := s.zoneUseCase.ZoneAddDoor(ctx, zoneID, doorIDs); err != nil </span><span class="cov0" title="0">{
                s.log.Errorf("add door to webDB zone error: %s", err.Error())
                return ErrorZoneAddDoorError("failed to add door to webDB zone, error: %s", err.Error())
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (s *ZoneService) AddZone(ctx context.Context, req *zoneV1.AddZoneRequest) (*zoneV1.AddZoneReply, error) <span class="cov0" title="0">{
        /*
                TODO:
                zone := &amp;dto.Zone{
                        ID:           ksuid.New().String(),
                        Name:         req.GetBody().GetZone().GetName(),
                        AccessRuleID: req.GetBody().GetZone().GetAccessRule(),
                }
        */
        zone := &amp;dto.Zone{
                ID:   ksuid.New().String(),
                Name: req.GetBody().GetZone().GetName(),
        }

        zoneID, err := s.zoneUseCase.AddZone(ctx, zone)
        if err != nil </span><span class="cov0" title="0">{
                s.log.Errorf("add webDB zone error: %s", err.Error())
                return nil, ErrorAddZoneError("failed to add webDB zone, error: %s", err.Error())
        }</span>

        <span class="cov0" title="0">err = s.addDoor(ctx, zoneID, req.GetBody().GetZone().GetDoors())
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;zoneV1.AddZoneReply{
                Id: zoneID,
        }, nil</span>
}

func (s *ZoneService) UpdateZone(ctx context.Context, req *zoneV1.UpdateZoneRequest) (*emptypb.Empty, error) <span class="cov0" title="0">{
        /*
                TODO:
                zone := &amp;dto.Zone{
                        ID:           req.GetId(),
                        Name:         req.GetBody().GetZone().GetName(),
                        AccessRuleID: req.GetBody().GetZone().GetAccessRule(),
                }
        */

        zone := &amp;dto.Zone{
                ID:   req.GetId(),
                Name: req.GetBody().GetZone().GetName(),
        }

        err := s.zoneUseCase.UpdateZone(ctx, zone)
        if err != nil </span><span class="cov0" title="0">{
                s.log.Errorf("update webDB zone error: %s", err.Error())
                return nil, ErrorUpdateZoneError("failed to update webDB zone, error: %s", err.Error())
        }</span>

        <span class="cov0" title="0">err = s.addDoor(ctx, req.GetId(), req.GetBody().GetZone().GetDoors())
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;emptypb.Empty{}, nil</span>
}

func (s *ZoneService) DeleteZone(ctx context.Context, req *zoneV1.DeleteZoneRequest) (*emptypb.Empty, error) <span class="cov0" title="0">{
        zone := &amp;dto.Zone{
                ID: req.GetId(),
        }
        err := s.zoneUseCase.DeleteZone(ctx, zone)
        if err != nil </span><span class="cov0" title="0">{
                s.log.Errorf("delete webDB zone error: %s", err.Error())
                return nil, ErrorDeleteZoneError("failed to delete webDB zone, error: %s", err.Error())
        }</span>

        <span class="cov0" title="0">return &amp;emptypb.Empty{}, nil</span>
}

func (s *ZoneService) getZoneDetailed(ctx context.Context, zone *dto.Zone) (*zoneV1.ZoneInfoDetailed, error) <span class="cov0" title="0">{
        doors, doorCount, err := s.zoneUseCase.ZoneListDoor(ctx, zone.ID, DefaultOffset, DefaultLimit)
        if err != nil </span><span class="cov0" title="0">{
                s.log.Errorf("list webDB zone door error: %s", err.Error())
                return nil, ErrorZoneListDoorError("failed to list webDB zone door, error: %s", err.Error())
        }</span>

        // TODO: need to get AccessRules
        <span class="cov0" title="0">reply := &amp;zoneV1.ZoneInfoDetailed{
                Id:    zone.ID,
                Name:  zone.Name,
                Doors: make([]*doorV1.DoorInfo, 0, doorCount),
        }

        for _, door := range doors </span><span class="cov0" title="0">{
                reply.Doors = append(reply.Doors, door.ToPbDoor())
        }</span>

        <span class="cov0" title="0">return reply, nil</span>
}

func (s *ZoneService) GetZone(ctx context.Context, req *zoneV1.GetZoneRequest) (*zoneV1.GetZoneReply, error) <span class="cov0" title="0">{
        zone, err := s.zoneUseCase.GetZone(ctx, req.GetId())
        if err != nil </span><span class="cov0" title="0">{
                s.log.Errorf("get webDB zone error: %s", err.Error())
                return nil, ErrorGetZoneError("failed to get webDB zone, error: %s", err.Error())
        }</span>

        <span class="cov0" title="0">pbZone, err := s.getZoneDetailed(ctx, zone)
        if err != nil </span><span class="cov0" title="0">{
                s.log.Errorf("get webDB zone child error: %s", err.Error())
                return nil, ErrorGetZoneError("failed to get webDB zone child, error: %s", err.Error())
        }</span>

        <span class="cov0" title="0">return &amp;zoneV1.GetZoneReply{
                Zone: pbZone,
        }, nil</span>
}

func (s *ZoneService) ListZone(ctx context.Context, req *zoneV1.ListZoneRequest) (*zoneV1.ListZoneReply, error) <span class="cov0" title="0">{
        zones, total, err := s.zoneUseCase.ListZone(ctx, req.GetOffset(), req.GetLimit())
        if err != nil </span><span class="cov0" title="0">{
                s.log.Errorf("list webDB zone error: %s", err.Error())
                return nil, ErrorListZoneError("failed to list webDB zone, error: %s", err.Error())
        }</span>

        <span class="cov0" title="0">pbZones := make([]*zoneV1.ZoneInfoDetailed, 0, len(zones))
        for _, zone := range zones </span><span class="cov0" title="0">{
                pbZone, err := s.getZoneDetailed(ctx, zone)
                if err != nil </span><span class="cov0" title="0">{
                        s.log.Errorf("get webDB zone child error: %s", err.Error())
                        return nil, ErrorGetZoneError("failed to get webDB zone child, error: %s", err.Error())
                }</span>
                <span class="cov0" title="0">pbZones = append(pbZones, pbZone)</span>
        }

        <span class="cov0" title="0">return &amp;zoneV1.ListZoneReply{
                Total: total,
                Zones: pbZones,
        }, nil</span>
}

func (s *ZoneService) ZoneAddDoor(ctx context.Context, req *zoneV1.ZoneAddDoorRequest) (*emptypb.Empty, error) <span class="cov0" title="0">{
        err := s.zoneUseCase.ZoneAddDoor(ctx, req.GetId(), req.GetBody().GetDoors())
        if err != nil </span><span class="cov0" title="0">{
                s.log.Errorf("add door to webDB zone error: %s", err.Error())
                return nil, ErrorZoneAddDoorError("failed to add door to webDB zone, error: %s", err.Error())
        }</span>

        <span class="cov0" title="0">return &amp;emptypb.Empty{}, nil</span>
}

func (s *ZoneService) ZoneDeleteDoor(ctx context.Context, req *zoneV1.ZoneDeleteDoorRequest) (*emptypb.Empty, error) <span class="cov0" title="0">{
        err := s.zoneUseCase.ZoneDeleteDoor(ctx, req.GetId(), req.GetDoors())
        if err != nil </span><span class="cov0" title="0">{
                s.log.Errorf("delete door from webDB zone error: %s", err.Error())
                return nil, ErrorZoneDeleteDoorError("failed to delete door from webDB zone, error: %s", err.Error())
        }</span>

        <span class="cov0" title="0">return &amp;emptypb.Empty{}, nil</span>
}

func (s *ZoneService) ZoneListDoor(ctx context.Context, req *zoneV1.ZoneListDoorRequest) (*zoneV1.ZoneListDoorReply, error) <span class="cov0" title="0">{
        doors, total, err := s.zoneUseCase.ZoneListDoor(ctx, req.GetId(), req.GetOffset(), req.GetLimit())
        if err != nil </span><span class="cov0" title="0">{
                s.log.Errorf("list webDB zone door error: %s", err.Error())
                return nil, ErrorZoneListDoorError("failed to list webDB zone door, error: %s", err.Error())
        }</span>

        <span class="cov0" title="0">pbDoors := make([]*doorV1.DoorInfo, 0, len(doors))
        for _, door := range doors </span><span class="cov0" title="0">{
                pbDoors = append(pbDoors, door.ToPbDoor())
        }</span>

        <span class="cov0" title="0">return &amp;zoneV1.ZoneListDoorReply{
                Total: total,
                Doors: pbDoors,
        }, nil</span>
}
</pre>

		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
